<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js/TAG/util/TAG.Util.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Authoring.EditorMenu.html">TAG.Authoring.EditorMenu</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkEditor.html">TAG.Layout.ArtworkEditor</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ArtworkTrack.html">TAG.TourAuthoring.ArtworkTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.AudioTrack.html">TAG.TourAuthoring.AudioTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Command.html">TAG.TourAuthoring.Command</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ComponentControls.html">TAG.TourAuthoring.ComponentControls</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Display.html">TAG.TourAuthoring.Display</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ImageTrack.html">TAG.TourAuthoring.ImageTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.InkAuthoring.html">TAG.TourAuthoring.InkAuthoring</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.InkTrack.html">TAG.TourAuthoring.InkTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Keyframe.html">TAG.TourAuthoring.Keyframe</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.PlaybackControl.html">TAG.TourAuthoring.PlaybackControl</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Timeline.html">TAG.TourAuthoring.Timeline</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TimeManager.html">TAG.TourAuthoring.TimeManager</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TopMenu.html">TAG.TourAuthoring.TopMenu</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TourOptions.html">TAG.TourAuthoring.TourOptions</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Track.html">TAG.TourAuthoring.Track</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.UndoManager.html">TAG.TourAuthoring.UndoManager</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.VideoTrack.html">TAG.TourAuthoring.VideoTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Viewer.html">TAG.TourAuthoring.Viewer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG.Util.Splitscreen.html">TAG.Util.Splitscreen</a></li>
            
                <li><a href="../classes/tagInk.html">tagInk</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js/TAG/util/TAG.Util.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//TAG Utilities
TAG.Util = (function () {
    &quot;use strict&quot;;

    var tagContainerId = &#x27;tagRoot&#x27;;

    //TAG.Util public methods and members
    return {
        makeNamespace: namespace,
        setToDefaults: setToDefaults,
        getGestureRecognizer: getGestureRecognizer,
        makeXmlRequest: makeXmlRequest,
        makeManipulatable: makeManipulatable,
        makeManipulatableWin: makeManipulatableWin,
        applyD3DataRec: applyD3DataRec,
        elementInDocument: elementInDocument,
        fitText: fitText,
        encodeText: encodeText,
        disableDrag: disableDrag,
        getFontSize: getFontSize,
        parseDateToYear : parseDateToYear,
        showLoading: showLoading,
        hideLoading: hideLoading,
        removeProgressCircle: removeProgressCircle,
        showProgressCircle: showProgressCircle,
        createQueue: createQueue,
        createDoubleEndedPQ: createDoubleEndedPQ,
        replaceSVGImg: replaceSVGImg,
        getMaxFontSizeEM: getMaxFontSizeEM,
        getMaxFontSize: getMaxFontSize,
        encodeXML: encodeXML,
        constrainAndPosition: constrainAndPosition,
        getFieldValueFromMetadata: getFieldValueFromMetadata,
        formatAddress: formatAddress,
        safeCall: safeCall,
        safeCallHandler: safeCallHandler,
        multiFnHandler: multiFnHandler,
        contains: contains,
        defaultVal: defaultVal,
        searchData: searchData,
        searchString: searchString,
        saveThumbnail: saveThumbnail,
        htmlEntityEncode: htmlEntityEncode,
        htmlEntityDecode: htmlEntityDecode,
        checkVideoConverted4Track: checkVideoConverted4Track,
        createConversionLoading: createConversionLoading,
        videoErrorHandler: videoErrorHandler,
        getHtmlAjax: getHtmlAjax,
        localVisibility: localVisibility,
        dimColor: dimColor,
        hexToRGBA: hexToRGBA
    };

    /* 
    constrainAndPosition takes in a set of relative and absolute 
    constraints and positioning as well as an HTML element and 
    its intended container, and returns a dictionary of position 
    and sizing data which conforms to the specified requirements.
    For this to work, the container must already be initialized 
    to its correct size.

    Possible constraints for propertySpec object:
    width: w 
        // mandatory, target relative width as decimal percent
    height: h 
        // mandatory, target relative height as decimal percent

    max_height: max_h 
        // optional, max absolute height in px 
        // ignored if unspecified
    max_width: max_w 
        // optional, max absolute width in px
        // ignored if unspecified

    x_offset: x_off 
        // optional, relative offset from left border of container as decimal percent
        // ignored if unspecified
    y_offset: y_off 
        // optional, relative offset from top border of container as decimal percent
        // ignored if unspecified

    x_max_offset: x_max_off 
        // optional, max absolute offset from left border of container in px
        // ignored if unspecified
    y_max_offset: y_max_off 
        // optional, max absolute offset from top border of container in px
        // ignored if unspecified

    center_h: center_h 
        // optional, boolean indicating whether element should be horizontally centered
        // defaults to false if unspecified
        // overrides any x-offset/x-max-offset as well as align_right if set to true
    center_v: center_v 
        // optional, boolean indicating whether element should be vertically centered
        // defaults to false if unspecified
        // overrides any y-offset/y-max-offset as well as align_bottom if set to true

    align_right: align_right
        // optional, boolean indicating whether element should be aligned from the right
        // NOTE: in this mode, positive offset values work like negative values in that they 
        // will shift the element leftwards TOWARDS THE CENTER, not the right.
    align_bottom: align_bottom
        // optional, boolean indicating whether element should be aligned from the bottom
        // NOTE: in this mode, positive offset values work like negative values in that they 
        // will shift the element upwards TOWARDS THE CENTER, not the bottom.
    */
    function constrainAndPosition(container_width, container_height, propertySpec) {
        var adjustedProperties,
            center_h = propertySpec.center_h || false,
            center_v = propertySpec.center_v || false;

        var cw = container_width,
            ch = container_height;

        var adjHeight, adjWidth;
        if (propertySpec.max_height) {
            // constrain to max height if specified
            adjHeight = Math.min(propertySpec.height * ch, propertySpec.max_height);
        } else {
            adjHeight = propertySpec.height * ch;
        }

        if (propertySpec.max_width) {
            // constrain to max width if specified
            adjWidth = Math.min(propertySpec.width * cw, propertySpec.max_width);
        } else {
            adjWidth = propertySpec.width * cw;
        }

        var xPos, yPos;
        // horizontal (x) value determined based on alignment/centering and offsets
        if (center_h) {
            // if horizontal centering enabled, account for in processing of x-offset
            if (propertySpec.x_max_offset) {
                // if max offset specified
                xPos = 0.5 * (cw - adjWidth) + Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset);
            } else {
                // if unspecified, ignore
                xPos = 0.5 * (cw - adjWidth);
            }

        } else {
            // otherwise, take care of offset from horiz axis
            if (propertySpec.x_max_offset) {
                // if max offset specified
                if (propertySpec.align_right) {
                    // if right alignment also specified, factor in width of object 
                    // and subtract offset from container width
                    xPos = cw - Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset) - adjWidth;
                } else {
                    // otherwise just select offset based on minimum of relative and absolute constraints
                    xPos = Math.min(propertySpec.x_offset * cw, propertySpec.x_max_offset);
                }
            } else {
                // if unspecified, ignore
                xPos = propertySpec.x_offset * cw;
            }
        }

        // vertical (y) value determined based on alignment/centering and offsets
        if (center_v) {
            // if vertically centering enabled, account for in processing of y-offset
            if (propertySpec.y_max_offset) {
                // if max offset specified
                yPos = 0.5 * (ch - adjHeight) + Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset);
            } else {
                // if unspecified, ignore
                yPos = 0.5 * (ch - adjHeight);
            }  
            
        } else {
            //otherwise, take care of offset from vertical axis
            if (propertySpec.y_max_offset) {
                // if max offset specified
                if (propertySpec.align_bottom) {
                    // if bottom alignment also specified, factor in width of object 
                    // and subtract offset from container high
                    yPos = ch - Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset) - adjHeight;
                } else {
                    // otherwise just select offset based on minimum of relative and absolute constraints
                    yPos = Math.min(propertySpec.y_offset * ch, propertySpec.y_max_offset);
                }
            } else {
                // if unspecified, ignore
                yPos = propertySpec.y_offset * ch;
            }
        }
        
        adjustedProperties = {
            height: adjHeight,
            width: adjWidth,
            x: xPos,
            y: yPos,
        };
        
        return adjustedProperties;
    }

    // Sets the default value of an input to val
    // If the input loses focus when it&#x27;s empty it will revert
    // to val.  Additionally, if hideOnClick is true then
    // if the value is val and the input gains focus it will be
    // set to the empty string
    function defaultVal(val, input, hideOnClick, ignore) {
        input.val(val);
        if (hideOnClick) {
            input.focus(function () {
                if (input.val() === val)
                    input.val(&#x27;&#x27;).change();
            });
        }
        input.blur(function () {
            if (input.val() === &#x27;&#x27;) {
                input.val(val).change();
                searchData(&#x27;&#x27;, &#x27;.artButton&#x27;, ignore);
            }
        });
    }

    // search the data of all objects matching selector
    function searchData(val, selector, ignore) {
        $.each($(selector), function (i, element) {
            var data = $(element).data();
            var show = false;
            $.each(data, function (k, v) {
                if ($.inArray(k, ignore) !== -1) return;
                //if (k === &#x27;visible&#x27; || k === &#x27;exhibits&#x27;) return;
                if (searchString(v, val)) {
                    show = true;
                }
            });
            if (data.visible === false) {
                show = false;
            }
            if (show) {
                $(element).show();
            } else {
                $(element).hide();
            }
        });
    }

    // Checks if a string &#x27;val&#x27; contains &#x27;str
    // If &#x27;val&#x27; is the default search text it will always return true
    // Case insensitive
    function searchString(str, val) {
        if (str) {
            return str.toLowerCase().indexOf(val.toLowerCase()) !== -1;
        }
        return true;
    }

    // save a video thumbnail using popcorn.capture
    function saveThumbnail(artwork) {

    }


    // Creates a queue that will run functions asynchronously.
    // Call createQueue() to get a queue, then with that object
    // call add() to add a job to the queue.  Jobs will be completed
    // when the browser has downtime.
    // Call clear() to remove anything currently in the queue.
    function createQueue() {
        return {
            _timer: null,
            _queue: [],
            // fn: the function to be called
            // 
            add: function (fn, context, time) {
                var setTimer = function (time, self) {
                    self._timer = setTimeout(function () {
                        time = self.add();
                        if (self._queue.length) {
                            setTimer(time, self);
                        }
                    }, time || 2);
                };

                if (fn) {
                    this._queue.push([fn, context, time]);
                    if (this._queue.length === 1) {
                        setTimer(time, this);
                    }
                    return;
                }

                var next = this._queue.shift();
                if (!next) {
                    return 0;
                }
                next[0].call(next[1] || window);
                return next[2];
            },
            clear: function () {
                clearTimeout(this._timer);
                this._queue = [];
            }
        };
    }

    function formatAddress(address) {
        address = address.replace(&#x27;http://&#x27;, &#x27;&#x27;);
        address = address.split(&#x27;:&#x27;)[0];
        return address;
    }

    function safeCall(fn) {
        var passedArgs = [];
        for (var i = 1; i &lt; arguments.length; i++) {
            passedArgs[i - 1] = arguments[i];
        }
        fn &amp;&amp; typeof fn === &quot;function&quot; &amp;&amp; fn.apply(null, passedArgs);
    }

    function safeCallHandler(fn) {
        var passedArgs = [];
        for (var i = 1; i &lt; arguments.length; i++) {
            passedArgs[i - 1] = arguments[i];
        }
        return function () {
            fn &amp;&amp; typeof fn === &quot;function&quot; &amp;&amp; fn.apply(null, passedArgs);
        }
    }

    function multiFnHandler() {
        var fns = arguments;
        return function () {
            var args = [];
            for (var j = 0; j &lt; arguments.length; j++) { // Need to copy arguments into a regular array for concat
                args[j] = arguments[j];
            }
            var passedArgs;
            if (fns &amp;&amp; fns.length) {
                for (var i = 0; i &lt; fns.length; i++) {
                    passedArgs = [fns[i]].concat(args);
                    safeCall.apply(null, passedArgs);
                }
            }
        }
    }

    function contains(object, val) {
        if (object &amp;&amp; object.indexOf) {
            return object.indexOf(val) !== -1;
        }
        return false;
    }

    /* 
     * This method parses the Metadata fields and then checks whether the required metadata
     * field matches up with the one currently being looked at. Once it has found a match, it
     * returns the appropriate node corresponding to the field.
     *
     * From the old settings view, works there so should work here
     * Made it so that it creates blank text node if there is none
     */
    function getFieldValueFromMetadata(xml, field) {
        var metadata = getMetaData(xml);
        for (var i = 0; i &lt; metadata.length; i++) {
            if (metadata[i].childNodes[0].textContent === field) {
                var out = metadata[i].childNodes[1].childNodes[0];
                if (out) return out;

                metadata[i].childNodes[1].appendChild(xml.createTextNode(&#x27;&#x27;));
                return metadata[i].childNodes[1].childNodes[0];
            }
        }
        return null;
    }

    function getMetaData(doq) {
        return doq.getElementsByTagName(&quot;Metadata&quot;)[0].childNodes[0].childNodes[0].childNodes[1].childNodes[0].childNodes;
    }

    //takes text with special characters and returns the html encode string
    function encodeText(string) {
        var element = document.createElement(&quot;div&quot;);
        element.innerText = element.textContent = string;
        string = element.innerHTML;
        return string;
    }

    function encodeXML(string) {
        if (string)
            return string.replace(/\n/g, &#x27;&lt;br&gt;&#x27;).
                replace(/&amp;/g, &#x27;&amp;amp;&#x27;).
                replace(/&lt;(.|\n)*?&gt;/g, &#x27;&#x27;).
                replace(/\&#x27;/g, &#x27;&amp;apos;&#x27;).
                replace(/\&quot;/g, &#x27;&amp;quot;&#x27;);
        else return &quot;&quot;;
    }

    function fitText(element, factor, options) {
        var loadedInterval = setInterval(function () {
            if (elementInDocument($(element))) {
                $(element).fitText(factor, options);
                clearInterval(loadedInterval);
            }
        });
    }

    /* Get an integer year from date metadata
     * @method parseDateToYear
     * @param {Object} date       object containing year, month, and day 
     * @return {Number} year      year (can have decimals to represent month, days)
     */
    function parseDateToYear(date){
        var yearString,
            neg = false,
            cent,
            year,
            month,
            monthDict,
            day,
            metadataDate,
            startDate,
            millisecondDifference,
            millisecondsPerDay = 1000 * 3600 * 24,
            dayInYear,
            totalDaysInYear,
            dayDecimal;

        if (date &amp;&amp; date.year){
            yearString = date.year;
            //Catches &#x27;ad&#x27;, &#x27;bc&#x27;, &#x27;bce&#x27; case, spacing, and order insensitive
            if (yearString.search(/bce?/i)&gt;=0){
                neg = true;
                yearString = yearString.replace(/bce?/gi,&#x27;&#x27;);
            }
            yearString = yearString.replace(/ad/gi,&#x27;&#x27;)
                                   .replace(/ce(?!n)/gi,&#x27;&#x27;)
                                   .replace(/\s/g,&#x27;&#x27;);
            //Catch &#x27;century&#x27;, &#x27;c&#x27;, and &#x27;c.&#x27; and return mid year of that century (17th c --&gt; 1650)
            if (yearString.search(/c.?/i)&gt;=0 || yearString.search(/century/i)&gt;=0){
                yearString.replace(/[a-z]\w/gi,&#x27;&#x27;)
                          .replace(/c.?/gi, &#x27;&#x27;)
                cent = parseInt(yearString) - 1 ;
                yearString = cent.toString() + &#x27;50&#x27;;
            }

            year = parseInt(yearString);
            if (date.month){
                month = date.month;
                monthDict = {
                    &quot;January&quot;: 1,
                    &quot;February:&quot;: 2,
                    &quot;March&quot;: 3,
                    &quot;April&quot;: 4,
                    &quot;May&quot;: 5,
                    &quot;June&quot;: 6,
                    &quot;July&quot;: 7,
                    &quot;August&quot;: 8,
                    &quot;September&quot;: 9,
                    &quot;October&quot;: 10,
                    &quot;November&quot;:11,
                    &quot;December&quot;: 12
                }
                if (date.day){
                    day = date.day;
                } else {
                    day = 1;
                }
                metadataDate = new Date(year, monthDict[month],day);
                startDate = new Date(year,0,0);
                millisecondDifference = metadataDate - startDate;
                dayInYear = Math.round(millisecondDifference/millisecondsPerDay);
                //check for leap year
                (new Date(year,2,0).getDate() === 29) ? totalDaysInYear = 366 : totalDaysInYear = 365;
                dayDecimal = dayInYear/totalDaysInYear;
                year = year + dayDecimal;
            }
            if (neg){
                year = -year;  
            }
            return year;
        }
    }

    // Replace SVG img with inline SVG
    function replaceSVGImg(svgImg) {
        var $img = $(svgImg);
        var imgURL = $img.attr(&#x27;src&#x27;);
        var imgID = $img.attr(&#x27;id&#x27;);
        var imgClass = $img.attr(&#x27;class&#x27;);
        var imgStyle = $img.attr(&#x27;style&#x27;);

        $.get(imgURL, function (data) {
            var $svg = $(data).find(&#x27;svg&#x27;);

            // Add replaced image&#x27;s ID to the new SVG
            if (typeof imgID !== &#x27;undefined&#x27;) {
                $svg = $svg.attr(&#x27;id&#x27;, imgID);
            }
            // Add replaced image&#x27;s classes to the new SVG
            if (typeof imgClass !== &#x27;undefined&#x27;) {
                $svg = $svg.attr(&#x27;class&#x27;, imgClass);
            }
            // Add replaced image&#x27;s classes to the new SVG
            if (typeof imgStyle !== &#x27;undefined&#x27;) {
                $svg = $svg.attr(&#x27;style&#x27;, imgStyle);
            }

            $svg = $svg.removeAttr(&#x27;xmlns:a&#x27;);

            $img.replaceWith($svg);
            return $img;
        });
    }

    // show spinning circle and change the background to tell users the new page is loading
    function showLoading(divToAppend, circleSize, top, left) {
        
        var progressCircCSS = {
            &quot;position&quot;: &#x27;absolute&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;10%&#x27;,
            &#x27;left&#x27;: &#x27;50%&#x27;,
            &#x27;top&#x27;: &#x27;50%&#x27;
        };
        if (top || left) {
            progressCircCSS.top = top;
            progressCircCSS.left = left;
        }
        var centerhor = &#x27;0px&#x27;;
        var centerver = &#x27;0px&#x27;;
        if (circleSize) {
            progressCircCSS.width = circleSize;
        }
        var colorString = $(divToAppend).css(&quot;background-color&quot;);
        var colorOnly = colorString.substring(colorString.indexOf(&quot;(&quot;) + 1, colorString.lastIndexOf(&quot;)&quot;)).split(/, \s*/);
        var bgColor = &quot;rgba(&quot; + colorOnly[0] + &quot;,&quot; + colorOnly[1] + &quot;,&quot; + colorOnly[2]  + &quot;,&quot; + &quot;0.5)&quot;;
        divToAppend.css({
            &#x27;background-color&#x27;: bgColor
        });

        var circle = showProgressCircle($(divToAppend), progressCircCSS, centerhor, centerver, false);
    }

    // hide specified div
    function hideLoading(divToHide) {
        var colorString = $(divToHide).css(&quot;background-color&quot;);
        var colorOnly = colorString.substring(colorString.indexOf(&quot;(&quot;) + 1, colorString.lastIndexOf(&quot;)&quot;)).split(/, \s*/);
        var bgColor = &quot;rgba(&quot; + colorOnly[0] + &quot;,&quot; + colorOnly[1] + &quot;,&quot; + colorOnly[2] + &quot;,&quot; + &quot;1)&quot;;
        divToHide.css({ &#x27;background-color&#x27;: bgColor });

        var circle = divToHide.find(&#x27;.progressCircle&#x27;);
        removeProgressCircle(circle);
    }

    //remove the progress circle when work is finished 
    function removeProgressCircle(circle) {
        circle.remove();
        circle = null;
    }

    // show circle; returns the progress circle so it can be removed later (note: center of element given to center circle within)
    function showProgressCircle(elAppendTo, cssObject, centerHor, centerVert, shouldCenter) {
        var progressCircle = $(document.createElement(&#x27;img&#x27;));
        progressCircle.addClass(&quot;progressCircle&quot;);
        elAppendTo.append(progressCircle);
        progressCircle.attr(&#x27;src&#x27;, tagPath+&quot;images/icons/progress-circle.gif&quot;);
        progressCircle.css(cssObject || { // css for entity loading circles
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;5%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;bottom&#x27;: &#x27;10%&#x27;,
            &#x27;width&#x27;: &#x27;10%&#x27;,
        });
        if (shouldCenter) {
            progressCircle.css({ top: centerVert - 0.5 * progressCircle.height(), left: centerHor - 0.5 * progressCircle.width() });
        }
        return progressCircle;
    }

    // Used in TourAuthoring layout
    function getFontSize(factor) {
        return factor * (window.innerWidth / 1920) + &#x27;%&#x27;; // Huh??? what is 1920? width of screen lol
    }

    //Takes d3 data and recursively applies it to all children. Only necessary if using D3
    function applyD3DataRec(element) {
        var nodes = element.childNodes;
        var i;
        for (i in nodes) {
            nodes[i].__data__ = element.__data__;
            applyD3DataRec(nodes[i]);
        }
    }

    //Creates a new namespace from a string (ex &quot;TAG.Layout.Catalog&quot;)
    function namespace(namespaceString) {
        var parts = namespaceString.split(&#x27;.&#x27;),
        parent = window,
        currentPart = &#x27;&#x27;;
         var k=0;
	if(parts[0] === &#x27;TAG&#x27;) {
	TAG = TAG || {};
	parent = TAG;
	k = 1;
	} else if (parts[0] === &#x27;Worktop&#x27;) {
	Worktop = Worktop || {};
	parent = Worktop;
	k = 1;
	}
 
	for (var i = k, length = parts.length; i &lt; length; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }

        return parent;
    }

    //Takes an object of options and an object of defaults, and combines them without overwriting.
    function setToDefaults(options, defaults) {
        return $.extend({}, defaults, options);
    }

    /*
    Gets the maximum font size in em that fits into the specified width and height.
    The output is a string with &#x27;em&#x27; at the end.

        text: The text to measure
        minFontSize: Minimum font size (in em, a number not a string).  The output will be no smaller than this value
        maxWidth: The maximum width the text should be.
        maxHeight: The maximum height the text should be.
        step: Optional.  The step to increment by when testing font size.
    */
    function getMaxFontSizeEM(text, minFontSize, maxWidth, maxHeight, step) {
        if (!text) {
            return;
        }
        var testDiv = $(document.createElement(&#x27;div&#x27;));
        var tagContainer = $(&#x27;#tagRoot&#x27;);
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;visibility&#x27;: &#x27;hidden&#x27;,
			&#x27;font-size&#x27;: minFontSize + &#x27;em&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
        });

        testDiv.text(text);
        tagContainer.append(testDiv);

        if (testDiv.width() &gt;= maxWidth || testDiv.height() &gt;= maxHeight) {
            return minFontSize + &#x27;em&#x27;;
			//currSize = minFontSize;
			//testDiv.css(&#x27;font-size&#x27;, currSize + &#x27;em&#x27;);
        }

        while (testDiv.width() &lt; maxWidth &amp;&amp; testDiv.height() &lt; maxHeight) {
            currSize += step;
            testDiv.css(&#x27;font-size&#x27;, currSize + &#x27;em&#x27;);
        }
        testDiv.remove();
        return currSize + &#x27;em&#x27;;
    }

    /**
     *  get max font size without em
     * @method getMaxFontSize
     * @param {String} text       TODO FINISH DOCUMENTATION
     */
    function getMaxFontSize(text, minFontSize, maxWidth, maxHeight, step) {
        var testDiv = $(document.createElement(&#x27;div&#x27;));
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;visibility&#x27;: &#x27;hidden&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;font-size&#x27;: minFontSize + &#x27;em&#x27;,
        });
        testDiv.text(text);
        $(&#x27;body&#x27;).append(testDiv);

        if (testDiv.width() &gt;= maxWidth || testDiv.height() &gt;= maxHeight) {
            return minFontSize;
        }

        while (testDiv.width() &lt; maxWidth &amp;&amp; testDiv.height() &lt; maxHeight) {
            currSize += step;
            testDiv.css(&#x27;font-size&#x27;, currSize + &#x27;em&#x27;);
        }
        testDiv.remove();
        return currSize;
    }
	
	/*
		Gets the maximum font size without em.
	*/
	function getMaxFontSize(text, minFontSize, maxWidth, maxHeight, step) {
        if (!text) {
            return;
        }
        var testDiv = $(document.createElement(&#x27;div&#x27;));
        var tagContainer = $(&#x27;#tagRoot&#x27;);
        step = step || 0.1;
        var currSize = minFontSize;

        testDiv.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;visibility&#x27;: &#x27;hidden&#x27;,
			&#x27;font-size&#x27;: minFontSize + &#x27;em&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
        });

        testDiv.text(text);
        tagContainer.append(testDiv);

        if (testDiv.width() &gt;= maxWidth || testDiv.height() &gt;= maxHeight) {
            return minFontSize + &#x27;em&#x27;;
			//currSize = minFontSize;
			//testDiv.css(&#x27;font-size&#x27;, currSize + &#x27;em&#x27;);
        }

        while (testDiv.width() &lt; maxWidth &amp;&amp; testDiv.height() &lt; maxHeight) {
            currSize += step;
            testDiv.css(&#x27;font-size&#x27;, currSize + &#x27;em&#x27;);
        }
        testDiv.remove();
        return currSize;
    }

    //Shouldn&#x27;t be public anymore, this is primarily used by makeManipulatable
    function getGestureRecognizer() {
        var gr = new Windows.UI.Input.GestureRecognizer();
        gr.gestureSettings = Windows.UI.Input.GestureSettings.manipulationRotate |
            Windows.UI.Input.GestureSettings.manipulationTranslateX |
            Windows.UI.Input.GestureSettings.manipulationTranslateY |
            Windows.UI.Input.GestureSettings.manipulationScale |
            Windows.UI.Input.GestureSettings.manipulationRotateInertia |
            Windows.UI.Input.GestureSettings.manipulationScaleInertia |
            Windows.UI.Input.GestureSettings.manipulationTranslateInertia |
            Windows.UI.Input.GestureSettings.hold |
            Windows.UI.Input.GestureSettings.holdWithMouse |
            Windows.UI.Input.GestureSettings.rightTap |
            Windows.UI.Input.GestureSettings.tap;
        return gr;
    }

    //Makes an xml request, and will actually get a modified document, because internet explorer (the
    //environment that metro apps run in) by default never retrieves a new xml document, even if the server&#x27;s
    //version is new. This fixes that.
    function makeXmlRequest(url) {

        if(!url) {
            return;
        }

        var request = new XMLHttpRequest();
        request.open(&quot;GET&quot;, url, false);
        request.send(null);
        if (false &amp;&amp; !request.getResponseHeader(&quot;Date&quot;)) { // TODO figure out why this causes network errors
            var cached = request;
            request = new XMLHttpRequest();
            var ifModifiedSince = cached.getResponseHeader(&quot;Last-Modified&quot;) || new Date(0); // January 1, 1970
            request.open(&quot;GET&quot;, url, false);
            request.setRequestHeader(&quot;If-Modified-Since&quot;, ifModifiedSince);
            request.send(&quot;&quot;);
            if (request.status === 304) {
                request = cached;
            }
        }
        return request;
    }

    // determine if element is in a doc
    function elementInDocument(element) {
        element = $(element)[0];
        while (element) {
            if (element === document) {
                return true;
            }
            element = element.parentNode;
        }
        return false;
    }

    //give it a jquery element and it will disable drag on the element, and drag events should propagate to parent element
    //still don&#x27;t know where to put this function yet
    function disableDrag(element) {
        element.attr(&quot;ondragstart&quot;, &quot;return false&quot;);
    }

    // dz - double-ended priority queue implementation using parallel min and max heap
    function createDoubleEndedPQ(minComparator, maxComparator) {
        return {
            // DEPQ built on a min-max heap pair
            _minComp: minComparator,
            _maxComp: maxComparator,
            
            _maxheap: new binaryHeap(maxComparator),
            _minheap: new binaryHeap(minComparator),
            
            // add
            //Input: Element to be added
            add: function (element) {
                this._maxheap.push(element);
                this._minheap.push(element); 
                return element;
            },

            //Output: Minimum element in minheap
            getMin: function () {
                return this._minheap.peek();
            },

            getMax: function() {
                return this._maxheap.peek();
            },

            removeMin: function () {
                return this._minheap.pop();
            },

            removeMax: function () {
                return this._maxheap.pop();
            },

            remove: function (node) {
                this._maxheap.remove(node);
                this._minheap.remove(node);
            },

            size: function() {
                return this._maxheap.size();
            },

            clear: function () {
                this._maxheap = new binaryHeap(this._maxComp);
                this._minheap = new binaryHeap(this._minComp);
            },

            find: function (node) {
                return this._maxheap.find(node)
            },
        }
    }
    that.createDoubleEndedPQ = createDoubleEndedPQ;

    //VERY important function. Will take an element and add multitouch/scale/etc events to it. And inertia.
    //Takes in a set of functions (onManipulate, onTapped, onScroll, onHolding)
    //onManipulate(result), result has pivot.x,.y ; translation.x,.y; rotation, scale
    //onScroll(delta,pivot) is the scroll wheel
    //onTapped
    //onHolding
    function makeManipulatable(element, functions, stopOutside, noAccel) {
        var hammer = new Hammer(element, {
            hold_threshold: 3,
            drag_min_distance: 9,
            drag_max_touches: 10,
            hold_timeout: 600,
            tap_max_distance: 15,
            doubletap_distance: 17,
            doubletap_interval: 400,
            swipe: false
        });

        var lastTouched = null,
            that = this,
            manipulating = false,
            isDown = false,
            $element = $(element);

        var lastPos = {},
            lastEvt,
            timer,
            currentAccelId = 0,
            lastScale = 1;

        // general event handler
        function manipulationHandler(evt) {
            var translation;
            if (evt.gesture) {
                // Update Dir, and set pivot rotation, and scale values
                getDir(evt, true);
                var pivot = { x: evt.gesture.center.pageX - $element.offset().left, y: evt.gesture.center.pageY - $element.offset().top };
                var rotation = evt.gesture.rotation; // In degrees
                if (!lastPos.x &amp;&amp; lastPos.x !== 0) {
                    translation = { x: evt.gesture.deltaX, y: evt.gesture.deltaY };
                } else {
                    translation = { x: evt.gesture.center.pageX - lastPos.x, y: evt.gesture.center.pageY - lastPos.y };
                }
                var scale = evt.gesture.scale - lastScale;
                // Previous values
                lastScale = evt.gesture.scale;
                lastPos.x = evt.gesture.center.pageX;
                lastPos.y = evt.gesture.center.pageY;
                lastEvt = evt;
                if (typeof functions.onManipulate === &quot;function&quot;) {
                    functions.onManipulate({ 
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: 1 + scale,
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent
                    }, evt);
                };
                //if ((evt.type === &quot;pinch&quot; || evt.type === &quot;pinchin&quot; || evt.type === &quot;pinchout&quot;) &amp;&amp; typeof functions.onScroll === &quot;function&quot;)
                //    functions.onScroll(1 + scale, pivot);
            } else {
                // Update Dir
                getDir(evt, true);
                var pivot = { x: evt.pageX - $element.offset().left, y: evt.pageY - $element.offset().top };
                // var rotation = evt.gesture.rotation; // In degrees // Don&#x27;t need rotation...
                if (false &amp;&amp; !lastPos.x &amp;&amp; lastPos.x !== 0) { // TODO need this?
                    translation = { x: evt.gesture.deltaX, y: evt.gesture.deltaY };
                } else {
                    translation = { x: evt.pageX - lastPos.x, y: evt.pageY - lastPos.y };
                    console.log(&#x27;translation.y = &#x27;+translation.y);
                }
                var scale = evt.gesture.scale - lastScale; /////////////////// HEREHEHEHEHEHRHERIEREIRHER ///
                lastScale = evt.gesture.scale;
                lastPos.x = evt.pageX;
                lastPos.y = evt.pageY;
                lastEvt = evt;

                if (typeof functions.onManipulate === &quot;function&quot;) {
                    functions.onManipulate({ 
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: 1 + scale,
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent
                    }, evt);
                };

                clearTimeout(timer);
                timer = setTimeout(function () {
                    var dir = getDir(evt);
                    if (evt.gesture.pointerType !== &quot;mouse&quot; &amp;&amp; !noAccel)
                        accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
                }, 5);
            }
        }


        function processPinch(evt) {
            var pivot = { x: evt.gesture.center.pageX - $element.offset().left, y: evt.gesture.center.pageY - $element.offset().top };
            var scale = evt.gesture.scale - lastScale;
            var rotation = evt.gesture.rotation; // In degrees
            var translation;
            if (!lastPos.x &amp;&amp; lastPos.x !== 0) {
                translation = { x: 0, y: 0};
            } else {
                translation = { x: evt.gesture.center.pageX - lastPos.x, y: evt.gesture.center.pageY - lastPos.y };
            }
            lastPos.x = evt.gesture.center.pageX;
            lastPos.y = evt.gesture.center.pageY;
            getDir(evt, true);
            if (scale !== lastScale &amp;&amp; typeof functions.onScroll === &quot;function&quot;)
                functions.onScroll(1 + scale, pivot);

            if (typeof functions.onManipulate === &quot;function&quot;)
                functions.onManipulate({                     
                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        target: evt.gesture.target,
                        touches: evt.gesture.touches,
                        pointerType: evt.gesture.pointerType,
                        center: evt.gesture.center,
                        deltaTime: evt.gesture.deltaTime,
                        deltaX: evt.gesture.deltaX,
                        deltaY: evt.gesture.deltaY,
                        velocityX: evt.gesture.velocityX,
                        velocityY: evt.gesture.velocityY,
                        angle: evt.gesture.angle,
                        direction: evt.gesture.direction,
                        distance: evt.gesture.distance,
                        eventType: evt.gesture.eventType,
                        srcEvent: evt.gesture.srcEvent,
                        startEvent: evt.gesture.startEvent,
                        scale: 1 
                    }, evt);
            lastScale = evt.gesture.scale;
        }

        // mousedown
        var dragStart;
        function processDown(evt) {
            lastScale = 1;
            isDown = true;
            dragStart = evt.gesture.center;
            lastEvt = null;
            lastTouched = evt.srcElement;
            currentAccelId++;
            resetDir();
            clearTimeout(timer);
            manipulationHandler(evt);
        }

        // mouse move
        function processMove(evt) {
            manipulationHandler(evt);
        }

        // requestAnimationFrame polyfill by Erik MÃ¶ller
        // fixes from Paul Irish and Tino Zijdel
        (function () {
            var lastTime = 0;
            var vendors = [&#x27;ms&#x27;, &#x27;moz&#x27;, &#x27;webkit&#x27;, &#x27;o&#x27;];
            for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x] + &#x27;RequestAnimationFrame&#x27;];
                window.cancelAnimationFrame = window[vendors[x] + &#x27;CancelAnimationFrame&#x27;] || window[vendors[x] + &#x27;CancelRequestAnimationFrame&#x27;];
            }

            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function (callback, element) {
                    var currTime = Date.now();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function () { callback(currTime + timeToCall); },
                      timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };

            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function (id) {
                    clearTimeout(id);
                };
        }());

        function accel(vx, vy, delay, id) {
            if (!lastEvt) return;
            if (currentAccelId !== id) return;
            if (Math.abs(vx) &lt;= 4 &amp;&amp; Math.abs(vy) &lt;= 4) {
                return;
            }
            var offset = $element.offset();
            delay = delay || 5;
            var pivot = { x: lastEvt.gesture.center.pageX - offset.left, y: lastEvt.gesture.center.pageY - offset.top };
            var rotation = 0; // In degrees
            var translation = { x: vx, y: vy };
            var scale = 1;
            if (typeof functions.onManipulate === &quot;function&quot;)
                functions.onManipulate({ 

                        pivot: pivot, 
                        translation: translation, 
                        rotation: rotation, 
                        scale: scale

                 }, lastEvt);

            timer = setTimeout(function () {
                accel(vx * 0.95, vy * 0.95, delay, id);
            }, delay);
            timer = window.requestAnimationFrame(accel(vx * .95, vy * .95, delay, id), $element);
        }

        // mouse release
        function processUp(evt) {
            //evt.stopPropagation();
            isDown = false;
            lastPos = {};
            var dir = getDir(evt);
            if (evt.gesture.pointerType === &quot;mouse&quot; &amp;&amp; !noAccel)
                accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
            if (typeof functions.onRelease === &quot;function&quot;)
                functions.onRelease(evt);

            //var dir = getDir(evt);
            //resetDir();
            //setTimeout(function () {
                //accel(30 * dir.vx, 30 * dir.vy, null, currentAccelId);
            //}, 1);
            //accel(30 * evt.gesture.velocityX * (evt.gesture.center.pageX &gt; dragStart.pageX ? 1 : -1),//(Math.abs(evt.gesture.angle) &lt; 90 ? 1 : -1),
            //    30 * evt.gesture.velocityY * (evt.gesture.center.pageY &gt; dragStart.pageY ? 1 : -1));//evt.gesture.angle / Math.abs(evt.gesture.angle));
        }

        var firstEvtX, firstEvtY, changeX, changeY, prevEvt;
        function resetDir() {
            firstEvtX = null;
            firstEvtY = null;
            changeX = 0;
            changeY = 0;
            prevEvt = null;
        }

        function getDir(evt, noReturn) {
            if (!firstEvtX) {
                firstEvtX = evt;
                //console.log(&quot;firstEvtX SETA&quot;);
                firstEvtX.currentDir = firstEvtX.gesture.deltaX / Math.abs(firstEvtX.gesture.deltaX) || 0;
                if (!prevEvt) {
                    prevEvt = evt;
                    return { vx: 0, vy: 0 };
                }
            } else {
                if (evt.gesture.deltaX &gt; prevEvt.gesture.deltaX &amp;&amp; firstEvtX.currentDir !== 1) {
                    firstEvtX = evt;
                    //console.log(&quot;firstEvtX SETB&quot;);
                    firstEvtX.currentDir = 1;
                } else if (evt.gesture.deltaX &lt; prevEvt.gesture.deltaX &amp;&amp; firstEvtX.currentDir !== -1) {
                    firstEvtX = evt;
                    //console.log(&quot;firstEvtX SETC&quot;);
                    firstEvtX.currentDir = -1;
                }
            }
            if (!firstEvtY) {
                firstEvtY = evt;
                //console.log(&quot;firstEvtY SETA&quot;);
                firstEvtY.currentDir = firstEvtY.gesture.deltaY / Math.abs(firstEvtY.gesture.deltaY) || 0;
            } else {
                if (evt.gesture.deltaY &gt; prevEvt.gesture.deltaY &amp;&amp; firstEvtY.currentDir !== 1) {
                    firstEvtY = evt;
                    //console.log(&quot;firstEvtY SETB&quot;);
                    firstEvtY.currentDir = 1;
                } else if (evt.gesture.deltaY &lt; prevEvt.gesture.deltaY &amp;&amp; firstEvtY.currentDir !== -1) {
                    firstEvtY = evt;
                    //console.log(&quot;firstEvtY SETC&quot;);
                    firstEvtY.currentDir = -1;
                }
            }
            prevEvt = evt;
            if (!noReturn) {
                return {
                    vx: ((evt.gesture.deltaX - firstEvtX.gesture.deltaX) / (evt.gesture.timeStamp - firstEvtX.gesture.timeStamp)) || 0,
                    vy: ((evt.gesture.deltaY - firstEvtY.gesture.deltaY) / (evt.gesture.timeStamp - firstEvtY.gesture.timeStamp)) || 0,
                };
            }
        }
        function processScrollFirefox(evt) {
                // console.log(&quot;capturing wheel events&quot;);
                var pivot = { x: evt.clientX - $element.offset().left, y: evt.clientY - $element.offset().top };
                console.log(evt.detail);
                var delta = -evt.detail;
                
                //delta = delta * 1.1;
                /*
                if (delta &lt; 0) { 
                    console.log(&quot;here; &quot; + delta);
                    delta = 1.0 / 1.1;
                } else { 
                    console.log(&quot;there; &quot; + delta);
                    delta = 1.1;
                }
                */
				if (delta &lt; 0) delta = 1.0 / 1.1;
            	else delta = 1.1;
				console.log(&quot;delta processed &quot; + delta);
                evt.cancelBubble = true;
                if (typeof functions.onScroll === &quot;function&quot;) { 
                    functions.onScroll(delta, pivot);
                }
         }
        // scroll wheel
        function processScroll(evt) {
            var pivot = { x: evt.x - $element.offset().left, y: evt.y - $element.offset().top };
            var delta = evt.wheelDelta;
            if (evt.wheelDelta &lt; 0) delta = 1.0 / 1.1;
            else delta = 1.1;
            evt.cancelBubble = true;
            if (typeof functions.onScroll === &quot;function&quot;) functions.onScroll(delta, pivot);
        }

        hammer.on(&#x27;touch&#x27;, processDown);
        hammer.on(&#x27;drag&#x27;, function(evt){
            processMove(evt);
        });
        hammer.on(&#x27;pinch&#x27;, processPinch);
        hammer.on(&#x27;release&#x27;, processUp);
        element.onmousewheel = processScroll;
        element.addEventListener(&quot;DOMMouseScroll&quot;, processScrollFirefox);

        // double tap
        var doubleTappedHandler, event;
        if (typeof functions.onDoubleTapped === &quot;function&quot;) {
            doubleTappedHandler = function (evt) {
                if (evt.gesture.srcEvent.button &gt; 0 || evt.gesture.srcEvent.buttons == 2) {
                    return;
                }
                event = {};
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onDoubleTapped(event);
            };
            hammer.on(&#x27;doubletap&#x27;, doubleTappedHandler);
        }

        // short tap, i.e. left-click
        var tappedHandler = null;
        if (typeof functions.onTapped === &quot;function&quot;) {
            tappedHandler = function (evt) {
                if (evt.gesture.srcEvent.button &gt; 0) {
                    evt.stopPropagation();
                    event = {};
                    event.gesture = evt.gesture;
                    event.position = {};
                    event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                    event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                    if (functions.onTappedRight) {
                        functions.onTappedRight(event);
                    }
                    return;
                }
                event = {};
                event.position = {};
                event.button = evt.button;
                event.gesture = evt.gesture;
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onTapped(event);
            };
            hammer.on(&#x27;tap&#x27;, tappedHandler);
            //gr.addEventListener(&#x27;tapped&#x27;, tappedHandler);
        }

        var releasedHandler = null;
        if (typeof functions.onRelease === &quot;function&quot;) {
            releasedHandler = function (evt) {
                event = {};
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $(element).offset().left;
                event.position.y = evt.gesture.center.pageY - $(element).offset().top;
                functions.onRelease(event);
            };
            hammer.on(&#x27;release&#x27;, releasedHandler);
        }

        //var debugLog = function(evt) {
        //    console.log(evt.type);
        //}

        //hammer.on(&#x27;release hold tap touch drag doubletap&#x27;, debugLog);

        // long-press, i.e. right-click
        var holdHandler = null;
        var rightClickHandler = null;
        var stopNextClick = false;
        if (typeof functions.onTappedRight === &quot;function&quot;) {
            holdHandler = function (evt) {
                evt.stopPropagation();
                stopNextClick = true;
                event = {};
                event.gesture = evt.gesture;
                event.position = {};
                event.position.x = evt.gesture.center.pageX - $element.offset().left;
                event.position.y = evt.gesture.center.pageY - $element.offset().top;
                functions.onTappedRight(event);
            };
            rightClickHandler = function (evt) {
                evt.stopPropagation();
                event = {};
                event.button = evt.button;
                event.gesture = evt.gesture;
                event.position = {};
                event.position.x = evt.pageX - $element.offset().left;
                event.position.y = evt.pageY - $element.offset().top;
                functions.onTappedRight(event);
            };
            element.addEventListener(&quot;MSPointerDown&quot;, function (evt) {
                console.log(evt);
                if (stopNextClick) {
                    console.log(&quot;STOPPING CLICK&quot;);
                    evt.stopPropagation();
                    setTimeout(function () {
                        stopNextClick = false;
                    }, 1);
                    return;
                }
            }, true);
            element.addEventListener(&quot;mouseup&quot;, function (evt) {
                console.log(&quot;CLICK&quot;);
                if (stopNextClick) {
                    console.log(&quot;STOPPING CLICK&quot;);
                    evt.stopPropagation();
                    setTimeout(function () {
                        stopNextClick = false;
                    }, 1);
                    return;
                }
                if (evt.button === 2) {
                    rightClickHandler(evt);
                }

            }, true);

            hammer.on(&#x27;hold&#x27;, holdHandler);
        }

        return {
            cancelAccel: function () {
                currentAccelId++;
                clearTimeout(timer);
            }
        };
        
        //return gr;
    }

    //VERY important function. Will take an element and add multitouch/scale/etc events to it. And inertia.
    //Takes in a set of functions (onManipulate, onTapped, onScroll, onHolding)
    //onManipulate(result), result has pivot.x,.y ; translation.x,.y; rotation, scale
    //onScroll(delta,pivot) is the scroll wheel
    //onTapped
    //onHolding
    function makeManipulatableWin(element, functions, stopOutside) {

        var lastTouched = null;
        var that = this;
        var gr = TAG.Util.getGestureRecognizer();
        var manipulating = false;

        // general event handler
        function manipulationHandlerWin(evt) {
            if (evt.delta) {
                var pivot = { x: evt.position.x, y: evt.position.y };
                var rotation = evt.delta.rotation / 180 * Math.PI;
                var translation = { x: evt.delta.translation.x, y: evt.delta.translation.y };
                var scale = evt.delta.scale;
                if (typeof functions.onManipulate === &quot;function&quot;) {
                    if (evt.gesture) {
                        functions.onManipulate({
                            pivot: pivot,
                            translation: translation,
                            rotation: rotation,
                            target: evt.gesture.target,
                            touches: evt.gesture.touches,
                            pointerType: evt.gesture.pointerType,
                            center: evt.gesture.center,
                            deltaTime: evt.gesture.deltaTime,
                            deltaX: evt.gesture.deltaX,
                            deltaY: evt.gesture.deltaY,
                            velocityX: evt.gesture.velocityX,
                            velocityY: evt.gesture.velocityY,
                            angle: evt.gesture.angle,
                            direction: evt.gesture.direction,
                            distance: evt.gesture.distance,
                            eventType: evt.gesture.eventType,
                            srcEvent: evt.gesture.srcEvent,
                            startEvent: evt.gesture.startEvent,
                            scale: scale
                        });
                    } else {
                        functions.onManipulate({
                            pivot: pivot,
                            translation: translation,
                            rotation: rotation,
                            scale: scale
                        });
                    }
                }
             }
        }

        function isManipulatingWin() { return manipulating; }

        // mousedown
        function processDownWin(evt) {
            lastTouched = evt.srcElement;
            var pp = evt.currentPoint;
            try {
                gr.processDownEvent(pp);
                element.msSetPointerCapture(evt.pointerId);

                evt.cancelBubble = true;
            }
            catch (err) {
                var message = err.message;
            }
        }

        // mouse move
        function processMoveWin(evt) {
            if (stopOutside) {
               if (evt.x &lt; 0 || evt.y &lt; 0 || evt.x &gt; $(element).width() || evt.y &gt; $(element).height()) {
                    return;
                }
            }
            var pps = evt.intermediatePoints;
            try {
                gr.processMoveEvents(pps);
            }
            catch (err) {
                var message = err.message;
            }
        }

        // mouse release
        function processUpWin(evt) {
            var pp = evt.currentPoint;
            try {
                gr.processUpEvent(pp);
            }
            catch (err) {
                var message = err.message;
            }
        }

        // scroll wheel
        function processScrollWin(evt) {
            var pivot = { x: evt.x, y: evt.y };
            var delta = evt.wheelDelta;
            if (evt.wheelDelta &lt; 0) delta = 1.0 / 1.1;
            else delta = 1.1;
            evt.cancelBubble = true;
            if (typeof functions.onScroll === &quot;function&quot;) functions.onScroll(delta, pivot);
        }

        element.addEventListener(&#x27;MSPointerDown&#x27;, processDownWin, false);
        element.addEventListener(&#x27;MSPointerMove&#x27;, processMoveWin, false);
        element.addEventListener(&#x27;MSPointerUp&#x27;, processUpWin, false);
        element.onmousewheel = processScrollWin;

        // start capturing manip
        function manipulationStartedHandlerWin(evt) {
            manipulating = true;
            manipulationHandlerWin(evt);
        }
        gr.addEventListener(&#x27;manipulationstarted&#x27;, manipulationStartedHandlerWin);

        // react to changes
        function manipulationDeltaHandlerWin(evt) {
            manipulationHandlerWin(evt);
        }
        gr.addEventListener(&#x27;manipulationupdated&#x27;, manipulationDeltaHandlerWin);

        // react to conclusion of manip
        function manipulationEndHandlerWin(evt) {
            manipulating = false;
            manipulationHandlerWin(evt);
        }
        gr.addEventListener(&#x27;manipulationcompleted&#x27;, manipulationEndHandlerWin);

        // short tap, i.e. left-click
        var tappedHandlerWin = null;
        if (typeof functions.onTapped === &quot;function&quot;) {
            tappedHandlerWin = function(evt) {
                var event = {};
                event.position = {};
                if (evt.position.x &lt; 50) {
                    event.position.x = $(lastTouched).offset().left - $(element).offset().left + evt.position.x;
                } else {
                    event.position.x = evt.position.x;
                }
                event.position.y = $(lastTouched).offset().top - $(element).offset().top + evt.position.y;
                functions.onTapped(event);
            };
            gr.addEventListener(&#x27;tapped&#x27;, tappedHandlerWin);
        }

        // long-press, i.e. right-click
        var rightTapHandlerWin = null;
        if (typeof functions.onTappedRight === &quot;function&quot;) {
            rightTapHandler = function (evt) {
                var event = {};
                event.position = {};
                event.position.x = evt.position.x;
                event.position.y = evt.position.y;
                functions.onTappedRight(event);
            };
            gr.addEventListener(&#x27;righttapped&#x27;, rightTapHandlerWin);
        }
        
        return gr;
    }

    function htmlEntityEncode(str) {
        return str ? $(&#x27;&lt;div /&gt;&#x27;).text(encodeURIComponent(str).html()) : &#x27;&#x27;;
    }

    function htmlEntityDecode(str) {
        try {
            return str ? decodeURIComponent($(&#x27;&lt;div /&gt;&#x27;).html(str).text()) : &#x27;&#x27;;
        } catch (e) {
            return str ? unescape($(&#x27;&lt;div /&gt;&#x27;).html(str).text()) : &#x27;&#x27;;
        }
    }

    /**
    function to check if the videos have been converted.
    Also, show the display in the track after conversion is done
    @param: an array of video tracks to convert.
    */
    function checkVideoConverted4Track(videos2Convert) {
        if (videos2Convert.length &gt; 0) {
            for (var i = 0; i &lt; videos2Convert.length; i++) {
                var track = videos2Convert[i];
                var media = track.getMedia();
                var videotag = $(document.createElement(&#x27;video&#x27;));
                videotag.attr(&#x27;preload&#x27;, &#x27;metadata&#x27;);
                var filename = media.slice(8, media.length);//get rid of /Images/ before the filename
                TAG.Worktop.Database.getConvertedCheck(
                    (function (i, track, media, videotag) {
                        return function (output) {
                            if (output !== &quot;False&quot;) {
                                console.log(&quot;converted/ or not being written now&quot;);
                                var mp4filepath = &quot;/Images/&quot; + output.substr(0, output.lastIndexOf(&#x27;.&#x27;)) + &quot;.mp4&quot;;
                                var mp4file = TAG.Worktop.Database.fixPath(mp4filepath);
                                videotag.attr(&#x27;src&#x27;, mp4file);
                                videotag.on(&#x27;loadedmetadata&#x27;, function () {
                                    //remove from the video array and add display with the right duration
                                    track.changeTrackColor(&#x27;white&#x27;);
                                    track.videoConverted(true);
                                    track.addDisplay(0, this.duration);
                                    videos2Convert.remove(track);
                                });

                            } else {
                                console.log(&quot;not converted: &quot;);
                            }
                        }
                    })(i, track, media, videotag), null, filename);
            }
        }
    }

    /*create video conversion loading message and circle for 
	  when imported videos are converting
	  O/P: the div containing the loading circle and message*/
    function createConversionLoading(msg, nocircle) {
        var container = $(document.createElement(&#x27;div&#x27;));
        container.attr(&#x27;id&#x27;, &#x27;leftLoading&#x27;);
        container.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;top&#x27;: &#x27;40%&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
        });

        var label = $(document.createElement(&#x27;label&#x27;));
        label.text(msg);
        label.css({
            &#x27;height&#x27;: &#x27;50%&#x27;,
            &#x27;width&#x27;: &#x27;50%&#x27;,
            &#x27;font-size&#x27;: &#x27;250%&#x27;
        });
        if (!nocircle) {
            var circle = $(document.createElement(&#x27;img&#x27;));
            circle.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/progress-circle.gif&#x27;);
            circle.css({
                &#x27;height&#x27;: &#x27;80px&#x27;,
                &#x27;width&#x27;: &#x27;auto&#x27;,
                &#x27;left&#x27;: &#x27;50%&#x27;
            });
            container.append(circle);
        }
        container.append(label);
        return container;
    }
    // sets up error handler for a video element
    // container is the div we&#x27;ll append error messages to
    function videoErrorHandler(videoElt, container, conversionFlag) {
        return function (err) {
            var msg = &quot;&quot;;
            switch (err.target.error.code) {
                case err.target.error.MEDIA_ERR_ABORTED:
                    msg = &quot;Video playback aborted. Please see FAQs on the TAG website.&quot;;
                    break;
                case err.target.error.MEDIA_ERR_NETWORK:
                    msg = &quot;Network error during video upload. Please see FAQs on the TAG website.&quot;;
                    break;
                case err.target.error.MEDIA_ERR_DECODE:
                    msg = &quot;Error decoding video. Please see FAQs on the TAG website.&quot;;
                    break;
                case err.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                    if (conversionFlag &amp;&amp; conversionFlag === &quot;False&quot;) {
                        //var loadingContainer = createConversionLoading();
                        msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                        //container.append(createConversionLoading(msg));
                        //} else if (!conversionFlag) {
                        //msg = &quot;The video format is not supported.&quot;;
                        //container.append(createConversionLoading(msg));
                    } else {
                        msg = &quot;Either the video format is not supported or a network or server error occurred. Please see FAQs on the TAG website.&quot;;
                    }
                    break;
                default:
                    msg = &quot;Error: please see FAQs on the TAG website.&quot;;
                    break;
            }
            console.log(&quot;video error: &quot; + msg);
            if (conversionFlag &amp;&amp; conversionFlag === &quot;False&quot;) {
                container.append(createConversionLoading(msg));
            } else if (!document.getElementById(&quot;leftLoading&quot;)) {
                //if (conversionFlag===&quot;True&quot;) { //&amp;&amp; conversionFlag === &quot;True&quot;
                var msgdiv = $(document.createElement(&#x27;div&#x27;));
                msgdiv.attr(&quot;id&quot;, &quot;videoErrorMsg&quot;);
                msgdiv.css({
                    &#x27;position&#x27;: &#x27;absolute&#x27;,
                    &#x27;width&#x27;: &#x27;80%&#x27;,
                    &#x27;left&#x27;: &#x27;10%&#x27;,
                    &#x27;top&#x27;: &#x27;50%&#x27;,
                    &#x27;color&#x27;: &#x27;white&#x27;,
                    &#x27;text-align&#x27;: &#x27;center&#x27;,
                    &#x27;font-size&#x27;: LADS.Util.getMaxFontSizeEM(msg, 2, container.width() * 0.8, container.height() * 0.2, 0.1)
                });
                msgdiv.text(msg);
                container.append(msgdiv);
            }
            videoElt.hide();

            videoElt[0].onerror = function (err) { };// get rid of the error handler afterwards
        }
    }
    /**
     * Used by web app code to slide in pages given their html files
     * @param path     the path to the html file within the html directory
     */
    function getHtmlAjax(path) {
        var ret;
        $.ajax({
            async: false,
            cache: false,
            url: path.match(/\//) ? path : tagPath+&quot;html/&quot;+path,
            success: function (data) {
                ret = data;
            },
            error: function (err) {
                console.log(&quot;url = &quot; + path);
                console.log(&quot;error: &quot;+err.statusText);
                ret = null;
            },
            dataType: &#x27;html&#x27;
        });
        return ret ? (IS_WINDOWS ? $(toStaticHTML(ret)) : $(ret)) :  &#x27;&#x27;;
    }

     /**
     * @param collectionId      the id of the collection whose local visibility we want to check or set
     * @param setValue          falsy if just want to return visibility status
     *                          {visible: true}  if we want to set collection to be locally visible
     *                          {visible: false} if we want to hide the collection locally
     */
    function localVisibility(collectionId, setValue) {
        localStorage.invisibleCollectionsTAG = localStorage.invisibleCollectionsTAG || &#x27;[]&#x27;;
        var tempList, index;
        try {
            tempList = JSON.parse(localStorage.invisibleCollectionsTAG);
        } catch (err) {
            localStorage.invisibleCollectionsTAG = &#x27;[]&#x27;;
            tempList = [];
        }
        index = tempList.indexOf(collectionId);
        if (setValue &amp;&amp; setValue.visible) {
            index &gt;= 0 &amp;&amp; tempList.splice(index, 1);
        } else if (setValue &amp;&amp; setValue.hasOwnProperty(&#x27;visible&#x27;)) {
            index === -1 &amp;&amp; tempList.push(collectionId);
        } else {
            return index &gt;= 0 ? false : true;
        }
        localStorage.invisibleCollectionsTAG = JSON.stringify(tempList);
    }

    /**
     * Take in a color and return a dimmed version of that color (divide rgb by k)
     * @param {String} inColor      input color as a hex string
     * @param {Number} k            dimming factor
     * @return {String}             formatted as &#x27;rbg(_,_,_)&#x27;
     */
    function dimColor(inColor, k) {
        var r,
            g,
            b;

        k = k || 3;

        inColor = inColor.replace(/\#/g, &#x27;&#x27;);
        inColor = inColor.substring(0, 6);

        r = Math.round(parseInt(inColor.substring(0, 2), 16) / k);
        g = Math.round(parseInt(inColor.substring(2, 4), 16) / k);
        b = Math.round(parseInt(inColor.substring(4, 6), 16) / k);

        return &#x27;rgb(&#x27; + r + &#x27;,&#x27; + g+ &#x27;,&#x27; + b + &#x27;)&#x27;;
    }

    /**
     * Take in a color (in &#x27;#abcdef&#x27; format) and an opacity (0-1) and return an rgba(..) string
     * @param {String} color       input color as a hex string
     * @param {String} opac        input opacity
     * @return {String}            &#x27;rgba(color.r, color.g, color.b, opac)&#x27;
     */
    function hexToRGBA(color, opac) {
        var r, g, b;

        color = color.replace(/\#/g, &#x27;&#x27;);
        color = color.substring(0, 6);

        r = parseInt(color.substring(0, 2), 16);
        g = parseInt(color.substring(2, 4), 16);
        b = parseInt(color.substring(4, 6), 16);

        return &#x27;rgba(&#x27; + r + &#x27;,&#x27; + g + &#x27;,&#x27; + b + &#x27;,&#x27; + opac + &#x27;)&#x27;;
    }

})();

/**
 * Utils for Animation, splitscreen, colors and the like
 */
TAG.Util.UI = (function () {
    &quot;use strict&quot;;

    var PICKER_SEARCH_TEXT = &#x27;Search by Name, Artist, or Year...&#x27;;
    var IGNORE_IN_SEARCH = [&#x27;visible&#x27;, &#x27;exhibits&#x27;, &#x27;selected&#x27;, &#x27;guid&#x27;, &#x27;url&#x27;, &#x27;comp&#x27;];
    var recentlyAssociated = []; // recently associated media
    var recentlyAssociatedGUIDs = []; // to more easily check if a media has been associated recently
    var tagContainerId = &#x27;tagRoot&#x27;; // TODO more general
    var globalKeyHandler = [];


    return {
        slidePageLeftSplit: slidePageLeftSplit,
        slidePageRightSplit: slidePageRightSplit,
        slidePageLeft: slidePageLeft,
        slidePageRight: slidePageRight,
        hexToR: hexToR,
        hexToG: hexToG,
        hexToB: hexToB,
        hexToRGB: hexToRGB,
        hexToRGBA: hexToRGBA,
        colorToHex: colorToHex,
        dimColor: dimColor,
        fitTextInDiv: fitTextInDiv,
        drawPushpins: drawPushpins,
        addPushpinToLoc: addPushpinToLoc,
        getLocationList: getLocationList,
        popUpMessage: popUpMessage,
        PopUpConfirmation: PopUpConfirmation,
        popupInputBox: popupInputBox,
        cgBackColor: cgBackColor,
        setUpBackButton: setUpBackButton,
        blockInteractionOverlay: blockInteractionOverlay,
        FeedbackBox: FeedbackBox,
        ChangeServerDialog: ChangeServerDialog,
        createAssociationPicker: createAssociationPicker,
        getRecentlyAssociated: getRecentlyAssociated,
        createCirc: createCirc,
        createLine: createVertLine,
        createKeyframe: createKeyframe,
        createDisplay: createDisplay,
        createTrack: createTrack,
        getStack: getStack,
        initKeyHandler: initKeyHandler,
        keyHandler: keyHandler,
        showPageLink: showPageLink
    };

    //initKeyHandler();

    function initKeyHandler() {
        window.focus();
        window.addEventListener(&#x27;keydown&#x27;, keyHandler);
    }

    /**The key handling event function
     * @method keyHandler
     * @param {Event} event     // the event triggered on key presses
     */
    function keyHandler(event) {
        if (globalKeyHandler &amp;&amp; globalKeyHandler[0] &amp;&amp; globalKeyHandler[0][event.which]) {
            globalKeyHandler[0][event.which]();
        }
      }

    function getStack() {
        return globalKeyHandler;
    }

    function createTrack(specs) {
        // TODO if necessary
    }

    function createDisplay(specs) {
        var inRect, mainRect, outRect, inHandle, outHandle;
        var x = specs.x,
            fadeIn = specs.fadeIn,
            fadeOut = specs.fadeOut,
            mainLength = specs.mainLength,
            fadeColor = specs.fadeColor || &#x27;#ff7700&#x27;,
            mainColor = specs.mainColor || &#x27;#81ad62&#x27;,
            height = specs.height || &#x27;100%&#x27;,
            container = specs.container;

        // fade in rectangle
        inRect = $(document.createElement(&#x27;div&#x27;));
        inRect.addClass(&#x27;inRect&#x27;);
        inRect.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: x + &quot;px&quot;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: fadeIn + &quot;px&quot;,
            &#x27;height&#x27;: height,
            &#x27;border-left&#x27;: &#x27;1px solid black&#x27;,
            &#x27;border-right&#x27;: &#x27;1px solid black&#x27;,
            &#x27;background&#x27;: &#x27;linear-gradient(to right,white, &#x27; + mainColor + &#x27;)&#x27; // DO FADE GRADIENT
        });

        // main rectangle
        mainRect = $(document.createElement(&#x27;div&#x27;));
        mainRect.addClass(&#x27;mainRect&#x27;);
        mainRect.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: (x+fadeIn) + &quot;px&quot;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: mainLength + &quot;px&quot;,
            &#x27;height&#x27;: height,
            &#x27;background-color&#x27;: mainColor
        });

        // fade out rectangle
        outRect = $(document.createElement(&#x27;div&#x27;));
        outRect.addClass(&#x27;outRect&#x27;);
        outRect.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: (x+fadeIn+mainLength) + &quot;px&quot;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: fadeOut + &quot;px&quot;,
            &#x27;height&#x27;: height,
            &#x27;border-left&#x27;: &#x27;1px solid black&#x27;,
            &#x27;border-right&#x27;: &#x27;1px solid black&#x27;,
            &#x27;background&#x27;: &#x27;linear-gradient(to right, &#x27;+ mainColor + &#x27;,white)&#x27; // DO FADE GRADIENT
        });

        // fade in handle
        inHandle = createCirc(x, 48, 15, 5, &#x27;#000000&#x27;, &#x27;#ffffff&#x27;);
        inHandle.addClass(&#x27;inHandle&#x27;);

        // fade out handle
        outHandle = createCirc(x + mainLength + fadeIn + fadeOut, 48, 15, 5, &#x27;#000000&#x27;, &#x27;#ffffff&#x27;);
        outHandle.addClass(&#x27;outHandle&#x27;);

        container &amp;&amp; container.append(mainRect).append(inRect).append(outRect).append(inHandle).append(outHandle);

        return { inRect: inRect, mainRect: mainRect, outRect: outRect, inHandle: inHandle, outHandle: outHandle };
    }

    function createKeyframe(specs) {
        var x=specs.x,
            y=specs.y || 48,
            container=specs.container;
        var line = createVertLine(x);
        line.addClass(&#x27;keyframeLine&#x27;);
        var circ = createCirc(x, y);
        circ.addClass(&#x27;keyframeCirc&#x27;);
        var innerCirc = createCirc(x, y, 17, 0, &#x27;#ff0000&#x27;, &#x27;#ffffff&#x27;);
        line.css(&#x27;z-index&#x27;, 2);
        circ.css(&#x27;z-index&#x27;, 3);
        innerCirc.css(&#x27;z-index&#x27;, 3);
        innerCirc.addClass(&#x27;keyframeInnerCirc&#x27;);
        container &amp;&amp; container.append(line);
        container &amp;&amp; container.append(circ);
        container &amp;&amp; container.append(innerCirc);
        return { line: line, circ: circ, innerCirc: innerCirc };
    }

    function createCirc(cx, cy, radius, strokeW, strokeColor, fillColor) {
        var circ = $(document.createElement(&#x27;div&#x27;));
        radius = radius || 21;
        strokeW = (strokeW === 0 || strokeW) ? strokeW : 5;
        strokeColor = strokeColor || &quot;#296b2f&quot;;
        fillColor = fillColor || &quot;#ffffff&quot;;
        circ.css({
            &#x27;border&#x27;: strokeW + &quot;px solid &quot; + strokeColor,
            &#x27;-webkit-border-radius&#x27;: (2 * radius) + &quot;px&quot;,
            &#x27;-moz-border-radius&#x27;:(2*radius)+&quot;px&quot;,
            &#x27;border-radius&#x27;: (2 * radius) + &quot;px&quot;,
            &#x27;width&#x27;: (2 * radius) + &quot;px&quot;,
            &#x27;height&#x27;: (2 * radius) + &quot;px&quot;,
            &#x27;background-color&#x27;: fillColor,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;:(cx-radius-strokeW)+&quot;px&quot;,
            &#x27;top&#x27;: (cy - radius - strokeW) + &quot;px&quot;,
        });
        return circ;
    }

    function createVertLine(x, width, color) {
        var line = $(document.createElement(&#x27;div&#x27;));
        width = width || 3;
        color = color || &quot;#296b2f&quot;;
        line.css({
            &#x27;width&#x27;: width + &quot;px&quot;,
            &#x27;height&#x27;: &quot;100%&quot;,
            &#x27;background-color&#x27;: color,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: (x-width/2) + &quot;px&quot;,
            &#x27;top&#x27;: &quot;0px&quot;
        });
        return line;
    }

    function ChangeServerDialog() {
        var serverDialogOverlay = $(document.createElement(&#x27;div&#x27;));
        var old_ip = localStorage.ip;
        var tagContainer = $(&#x27;#tagRoot&#x27;);
        serverDialogOverlay.attr(&#x27;id&#x27;, &#x27;serverDialogOverlay&#x27;);
        
        serverDialogOverlay.css({
            display: &#x27;block&#x27;,
            position: &#x27;absolute&#x27;,
            top: 0,
            left: 0,
            width: &#x27;100%&#x27;,
            height: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.6)&#x27;,
            &#x27;z-index&#x27;: 1000000000 + 5
        });

        // dialog box for server changes
        var serverDialog = $(document.createElement(&#x27;div&#x27;));
        serverDialog.attr(&#x27;id&#x27;, &#x27;serverDialog&#x27;);

        //

        var serverDialogSpecs = TAG.Util.constrainAndPosition($(tagContainer).width(), $(tagContainer).height(),
        {
            center_h: true,
            center_v: true,
            width: 0.5,
            height: 0.35,
            max_width: 560,
            max_height: 230
        });
        serverDialog.css({
            position: &#x27;absolute&#x27;,
            left: &#x27;30%&#x27;,//serverDialogSpecs.x + &#x27;px&#x27;,
            top: &#x27;30%&#x27;,//serverDialogSpecs.y + &#x27;px&#x27;,
            width: &#x27;40%&#x27;,   //serverDialogSpecs.width + &#x27;px&#x27;,
            height: &#x27;40%&#x27;,   //serverDialogSpecs.height + &#x27;px&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;
        });

        serverDialogOverlay.append(serverDialog);
        var serverDialogTitle = $(document.createElement(&#x27;div&#x27;));
        serverDialogTitle.attr(&#x27;id&#x27;, &#x27;dialogTitle&#x27;);
        serverDialogTitle.css({
            color: &#x27;white&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;height&#x27;: &#x27;15%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;top&#x27;: &#x27;10%&#x27;,
            &#x27;font-size&#x27;: &#x27;1.35em&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;
        });
        serverDialogTitle.text(&quot;TAG Server Address:&quot;);
        serverDialog.append(serverDialogTitle);

        var serverDialogInput = $(document.createElement(&#x27;input&#x27;));
        serverDialogInput.attr(&#x27;id&#x27;, &#x27;serverDialogInput&#x27;);
        serverDialogInput.css({
            display: &#x27;block&#x27;,
            margin: &#x27;auto&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
            &#x27;width&#x27;: &#x27;60%&#x27;,
	        &#x27;height&#x27;:&#x27;10%&#x27;,
            &#x27;position&#x27;:&#x27;relative&#x27;,
            &#x27;top&#x27;:&#x27;15%&#x27;,
	        &#x27;font-size&#x27;:&#x27;100%&#x27;
        });
        serverDialogInput.val(localStorage.ip);
        serverDialogInput.focus(function () {
            serverDialogInput.select();
        });
        serverDialog.append(serverDialogInput);
        serverDialogInput.on(&#x27;keydown&#x27;, function(evt) {
            if(evt.which === 13) {
                saveClick();
            }
        });

        /* TODO merging
        TAG.Telemetry.register(serverDialogInput, &#x27;keydown&#x27;, &#x27;change_server&#x27;, function(tobj, evt) {
            if(evt.which !== 13) {
                return true;
            }
            tobj.custom_3 = localStorage.ip;
            tobj.custom_4 = serverDialogInput.val();
        });
        */

        var serverDialogContact = $(document.createElement(&#x27;div&#x27;));
        serverDialogContact.css({ &#x27;margin-top&#x27;: &#x27;10%&#x27; , &#x27;color&#x27;:&#x27;white&#x27;,&#x27;text-align&#x27;: &#x27;center&#x27;  });
        serverDialogContact.html(
            &quot;Contact us for server setup at:&lt;br /&gt;&lt;a href=&#x27;mailto:brown.touchartgallery@outlook.com&#x27;&gt;brown.touchartgallery@outlook.com&lt;/a&gt;.&quot;
        );
        serverDialog.append(serverDialogContact);

        var serverButtonRow = $(document.createElement(&#x27;div&#x27;));
        serverButtonRow.css({
            &#x27;margin-top&#x27;: &#x27;5%&#x27;,
        });
        serverDialog.append(serverButtonRow);
        var serverSaveButton = $(document.createElement(&#x27;button&#x27;));
        serverSaveButton.css({
            &#x27;padding&#x27;: &#x27;1%&#x27;, &#x27;border&#x27;: &#x27;1px solid white&#x27;, &#x27;width&#x27;: &#x27;14%&#x27;,&#x27;height&#x27;:&#x27;3%&#x27; ,&#x27;position&#x27;: &#x27;relative&#x27;,&#x27;margin-top&#x27;: &#x27;1%&#x27;, &#x27;float&#x27;: &quot;left&quot;, &#x27;margin-left&#x27;:&#x27;7%&#x27; ,&#x27;font-size&#x27;:&#x27;90%&#x27;,&#x27;bottom&#x27;:&#x27;1%&#x27;
        });
        serverSaveButton.text(&#x27;Save&#x27;);
        var serverErrorMessage = $(document.createElement(&#x27;div&#x27;));
        serverErrorMessage.attr(&#x27;id&#x27;, &#x27;serverErrorMessage&#x27;);
        serverErrorMessage.css({
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
	        &#x27;height&#x27;:&#x27;10%&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
        });

        serverButtonRow.append(serverErrorMessage);
        serverErrorMessage.hide();


        var serverCancelButton = $(document.createElement(&#x27;button&#x27;));
        serverCancelButton.css({
            &#x27;padding&#x27;: &#x27;1%&#x27;, &#x27;border&#x27;: &#x27;1px solid white&#x27;, &#x27;width&#x27;: &#x27;14%&#x27;,&#x27;height&#x27;:&#x27;3%&#x27;, &#x27;position&#x27;: &#x27;relative&#x27;, &#x27;margin-top&#x27;: &#x27;1%&#x27;, &#x27;float&#x27;: &quot;right&quot;, &#x27;margin-right&#x27;: &#x27;7%&#x27;,&#x27;font-size&#x27;:&#x27;90%&#x27;,&#x27;bottom&#x27;:&#x27;1%&#x27;
        });
        serverCancelButton.text(&#x27;Cancel&#x27;);
        serverCancelButton.attr(&#x27;type&#x27;, &#x27;button&#x27;);
        serverButtonRow.append(serverCancelButton);
        serverButtonRow.append(serverSaveButton);
        serverCancelButton.click(function () {
            $(&#x27;#serverDialogOverlay&#x27;).remove();
        });

        function saveClick() {
            var address = serverDialogInput.val();
            switch(address) {
                case &#x27;tagunicorn&#x27;:
                    var unicorn = $(document.createElement(&#x27;img&#x27;));
                    unicorn.attr(&#x27;src&#x27;, tagPath+&#x27;images/unicorn.jpg&#x27;);
                    unicorn.css({
                        width: &#x27;100%&#x27;,
                        height: &#x27;100%&#x27;,
                        &#x27;z-index&#x27;: 2147483647, // we really want this unicorn to show up
                        display: &#x27;none&#x27;,
                        position: &#x27;absolute&#x27;,
                    });
                    tagContainer.append(unicorn);
                    unicorn.fadeIn(500);
                    setTimeout(function () {
                        $(&#x27;img&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/unicorn.jpg&#x27;);
                        $(&#x27;.background&#x27;).css(&#x27;background-image&#x27;, &#x27;url(&#x27;+tagPath+&#x27;&quot;images/unicorn.jpg&quot;)&#x27;);
                        unicorn.fadeOut(500, function () { unicorn.remove(); });
                    }, 5000);
                    return;
                case &#x27;tagtest&#x27;:
                    address = &#x27;tagtestserver.cloudapp.net&#x27;;
                    break;
                case &#x27;tagdemo&#x27;:
                    address = &#x27;tagdemo.cloudapp.net&#x27;;
                    break;
                case &#x27;taglive&#x27;:
                    address = &#x27;browntagserver.com&#x27;;
                    break;
                case &#x27;taglocal&#x27;:
                    address = &#x27;10.116.71.58&#x27;;
                    break;
                case &#x27;sam&#x27;:
                case &#x27;seattleartmuseum&#x27;:
                    address = &#x27;tag.seattleartmuseum.org&#x27;
                    break;
                default:
                    break;
            }
            serverCancelButton.hide();
            serverSaveButton.hide();
            serverErrorMessage.html(&#x27;Connecting...&#x27;);
            serverErrorMessage.show();
            TAG.Worktop.Database.changeServer(address, false, function () {
                TAG.Layout.StartPage(null, function (page) {
                    TAG.Util.UI.slidePageRight(page);
                });
            }, function () {
                serverCancelButton.show();
                serverSaveButton.show();
                serverErrorMessage.html(&#x27;Could not connect to the specified address. Please try again.&#x27;);
                serverErrorMessage.css({ &#x27;margin-top&#x27;: &#x27;-3%&#x27;});
                serverErrorMessage.show();
                serverDialogTitle.css({ &#x27;margin-bottom&#x27;: &#x27;-3%&#x27;});
                serverDialog.css({
                    width: &#x27;40%&#x27;,   //serverDialogSpecs.width + &#x27;px&#x27;,
                    height: &#x27;45%&#x27;,   //serverDialogSpecs.height + &#x27;px&#x27;,
                });
                serverDialogContact.css({ &#x27;margin-top&#x27;: &#x27;13%&#x27; , &#x27;color&#x27;:&#x27;white&#x27;,&#x27;text-align&#x27;: &#x27;center&#x27;  });        
            });
        }

        serverSaveButton.on(&#x27;click&#x27;, saveClick);

        /* TODO merging
        TAG.Telemetry.register(serverSaveButton, &#x27;click&#x27;, &#x27;change_server&#x27;, function(tobj, evt) {
            tobj.custom_3 = localStorage.ip;
            tobj.custom_4 = serverDialogInput.val();
        });
        */

        var serverCircle = $(document.createElement(&#x27;img&#x27;));
        serverCircle.css({
            &#x27;width&#x27;: &#x27;20px&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;display&#x27;: &#x27;none&#x27;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;2.5%&#x27;,
            &#x27;float&#x27;: &#x27;right&#x27;
        });
        serverCircle.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/progress-circle.gif&#x27;);

        var serverPasswordErrorMessage = $(document.createElement(&#x27;div&#x27;));
        serverPasswordErrorMessage.attr(&#x27;id&#x27;, &#x27;serverPasswordErrorMessage&#x27;);
        serverPasswordErrorMessage.css({
            color: &#x27;white&#x27;,
            &#x27;font-size&#x27;: &#x27;1.25em&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;10px&#x27;,
        });
        serverPasswordErrorMessage.html(&#x27;Invalid authoring password entered. Please try again.&#x27;);
        serverPasswordErrorMessage.hide();

        tagContainer.append(serverDialogOverlay);
        serverDialogInput.focus();
    }


    function FeedbackBox(sourceType, sourceID) {
        var dialogOverlay = $(document.createElement(&#x27;div&#x27;));
        var tagContainer = $(&#x27;#tagRoot&#x27;);
        $(dialogOverlay).attr(&#x27;id&#x27;, &#x27;dialogOverlay&#x27;);

        $(dialogOverlay).css({
            display: &#x27;none&#x27;,
            position: &#x27;absolute&#x27;,
            top: 0,
            left: 0,
            width: &#x27;100%&#x27;,
            height: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.6)&#x27;,
            &#x27;z-index&#x27;: 10000000,
        });

        var feedbackBox = $(document.createElement(&#x27;div&#x27;));
        $(feedbackBox).addClass(&#x27;feedbackBox&#x27;);
        var feedbackBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),

        {
            center_h: true,
            center_v: true,
            width: 0.5,
            height: 0.35,
            max_width: 560,
            max_height: 210,
        });
		var leftPos = ($(&#x27;#tagRoot&#x27;).width() - feedbackBoxSpecs.width) * 0.5;
        $(feedbackBox).css({
            position: &#x27;absolute&#x27;,
            left: &#x27;20%&#x27;, //leftPos + &#x27;px&#x27;,
            top: &#x27;25%&#x27;, // feedbackBoxSpecs.y + &#x27;px&#x27;,
            width: &#x27;62%&#x27;, // feedbackBoxSpecs.width + &#x27;px&#x27;,
            height: &#x27;45%&#x27;, // feedbackBoxSpecs.height + &#x27;px&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,

        });

        $(dialogOverlay).append(feedbackBox);
		$(dialogOverlay).click(cancelFeedback);
		$(feedbackBox).click(function(event){
			event.stopPropagation();
		});
		
        var feedbackLabel = $(document.createElement(&#x27;label&#x27;));
        $(feedbackLabel).addClass(&#x27;feedbackLabel&#x27;);
        $(feedbackLabel).text(&#x27;Send Feedback&#x27;);
        $(feedbackLabel).css({
            &#x27;left&#x27;: &#x27;9%&#x27;,
            &#x27;top&#x27;: &#x27;12.5%&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;height&#x27;: &#x27;15%&#x27;,
            &#x27;text-align&#x27;: &#x27;left&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;font-size&#x27;: &#x27;100%&#x27;
        });

        var commentBox = $(document.createElement(&#x27;textarea&#x27;));
        $(commentBox).addClass(&#x27;commentBox&#x27;);
        $(commentBox).css({
            &#x27;border-color&#x27;: &#x27;gray&#x27;,
            &#x27;color&#x27;: &#x27;gray&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;min-width&#x27;: 0,
            &#x27;left&#x27;: &#x27;9%&#x27;,
            &#x27;top&#x27;: &#x27;12%&#x27;,
            &#x27;width&#x27;: &#x27;77%&#x27;,
            &#x27;height&#x27;: &#x27;30%&#x27;


        });

        $(commentBox).attr(&#x27;placeholder&#x27;, &#x27;Questions or Comments&#x27;);

        /*******buttons********/

        var buttonRow = $(document.createElement(&#x27;div&#x27;));
        $(buttonRow).css({
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;bottom&#x27;: &#x27;-74%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });
        var submitButton = $(document.createElement(&#x27;button&#x27;));
        $(submitButton).css({
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-left&#x27;: &#x27;-2%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
        });
        $(submitButton).text(&#x27;Send &#x27;);
        $(submitButton).on(&#x27;click&#x27;, submitFeedback);

        function submitFeedback() {
            var type = (typeof sourceType === &#x27;function&#x27;) ? sourceType() : sourceType;
            var id = (typeof sourceID === &#x27;function&#x27;) ? sourceID() : sourceID;
            TAG.Worktop.Database.createFeedback($(commentBox).val(), type, id);
            $(dialogOverlay).css({ &#x27;display&#x27;: &#x27;none&#x27; });
            $(commentBox).val(&#x27;&#x27;);
            var popup = TAG.Util.UI.popUpMessage(null, &quot;Your feedback has been submitted, thank you for your feedback.&quot;, null, null, null, true);
            tagContainer.append(popup);
            $(popup).css(&#x27;z-index&#x27;, 1000000);
            $(popup).show();
        }
        var cancelButton = $(document.createElement(&#x27;button&#x27;));
        $(cancelButton).css({
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
            &#x27;margin-right&#x27;: &#x27;-2%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
        });
        $(cancelButton).text(&#x27;Cancel&#x27;);
        
        $(cancelButton).click(cancelFeedback);
        function cancelFeedback() {
            $(commentBox).val(&#x27;&#x27;);
            $(dialogOverlay).css({ &#x27;display&#x27;: &#x27;none&#x27; });

        }
        $(feedbackBox).append(buttonRow);
        $(buttonRow).append(submitButton);
        $(buttonRow).append(cancelButton);

        $(feedbackBox).append(commentBox);
        $(feedbackBox).append(feedbackLabel);
        return dialogOverlay;
    }

    // overlay that &quot;absorbs&quot; interactions with elements below it, used to isolate popup forms etc.
    function blockInteractionOverlay(opac) {

        opac = opac ? Math.max(Math.min(parseFloat(opac), 1), 0) : 0.6;
        var overlay = document.createElement(&#x27;div&#x27;);
        $(overlay).attr(&#x27;id&#x27;, &#x27;blockInteractionOverlay&#x27;);

        $(overlay).css({

            display: &#x27;none&#x27;,
            position: &#x27;absolute&#x27;,
            top: 0,
            left: 0,
            width: &#x27;100%&#x27;,
            height: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,&#x27;+opac+&#x27;)&#x27;,
            &#x27;z-index&#x27;: &#x27;10000000&#x27;
        });
        
        return overlay;
    }

    // unused - this is not tested, use at your own risk - consider removing?
    //function PopUpWarningBox(message) {
    //    var overlay = BlockInteractionOverlay();
    //    var WarningBox = document.createElement(&#x27;div&#x27;);
    //    $(WarningBox).css({
    //        &#x27;height&#x27;: &#x27;30%&#x27;,
    //        &#x27;width&#x27;: &#x27;45%&#x27;,
    //        &#x27;position&#x27;: &#x27;fixed&#x27;,
    //        &#x27;top&#x27;: &#x27;50%&#x27;,
    //        &#x27;left&#x27;: &#x27;50%&#x27;,
    //        &#x27;margin-top&#x27;: &#x27;-15%&#x27;,
    //        &#x27;margin-left&#x27;: &#x27;-22.5%&#x27;,
    //        &#x27;background-color&#x27;: &#x27;black&#x27;,
    //        &#x27;z-index&#x27;: &#x27;100&#x27;,
    //        &#x27;border&#x27;: &#x27;3px double white&#x27;,
    //    });

    //    var messageLabel = document.createElement(&#x27;div&#x27;);
    //    $(messageLabel).css({ &#x27;top&#x27;: &#x27;5%&#x27;, &#x27;height&#x27;: &#x27;20%&#x27;, &#x27;width&#x27;: &#x27;90%&#x27;, &#x27;color&#x27;: &#x27;white&#x27;, &#x27;margin&#x27;: &#x27;5%&#x27;, &#x27;font-size&#x27;: &#x27;200%&#x27; });
    //    $(messageLabel).text(message);

    //    var optionButtonDiv = document.createElement(&#x27;div&#x27;);
    //    $(optionButtonDiv).css({ &#x27;height&#x27;: &#x27;10%&#x27;, &#x27;width&#x27;: &#x27;25%&#x27;, &#x27;left&#x27;: &#x27;70%&#x27;, &#x27;position&#x27;: &#x27;relative&#x27;, &#x27;top&#x27;: &#x27;35%&#x27; });
    //    var okButton = document.createElement(&#x27;button&#x27;);
    //    $(okButton).css({ &#x27;font-size&#x27;: &#x27;140%&#x27;, &#x27;margin-left&#x27;: &#x27;2%&#x27; });
    //    $(okButton).text(&quot;OK&quot;);
    //    okButton.onclick = function () {
    //        $(overlay).fadeOut(500, function () { $(overlay).remove(); });
    //    }
    //    $(optionButtonDiv).append(okButton);

    //    $(confirmBox).append(messageLabel);
    //    $(confirmBox).append(optionButtonDiv);

    //    $(overlay).append(confirmBox)
    //    return overlay;
    //}

    // generate a popup message with specified text and button
    function popUpMessage(clickAction, message, buttonText, noFade, useHTML, onDialogClick) {
        var overlay = blockInteractionOverlay();
        var confirmBox = document.createElement(&#x27;div&#x27;);
        var confirmBoxSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height(),
           {
               center_h: true,
               center_v: true,
               width: 0.5,
               height: 0.35,
               max_width: 560,
               max_height: 200,
           });
		var leftPos = ($(&#x27;#tagRoot&#x27;).width() - confirmBoxSpecs.width) * 0.5;
        var currentKeyHandler = globalKeyHandler[0];

        $(confirmBox).css({
            //&#x27;height&#x27;: &#x27;30%&#x27;,
            //&#x27;width&#x27;: &#x27;45%&#x27;,
            //&#x27;position&#x27;: &#x27;absolute&#x27;,
            //&#x27;top&#x27;: &#x27;50%&#x27;,
            //&#x27;left&#x27;: &#x27;50%&#x27;,
            //&#x27;margin-top&#x27;: &#x27;-15%&#x27;,
            //&#x27;margin-left&#x27;: &#x27;-22.5%&#x27;,
            //&#x27;background-color&#x27;: &#x27;black&#x27;,
            //&#x27;z-index&#x27;: &#x27;100&#x27;,
            //&#x27;border&#x27;: &#x27;3px double white&#x27;,

            position: &#x27;absolute&#x27;,
            left: leftPos + &#x27;px&#x27;,
            top: confirmBoxSpecs.y + &#x27;px&#x27;,
            width: confirmBoxSpecs.width + &#x27;px&#x27;,
            height: confirmBoxSpecs.height + &#x27;px&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,

        });
		if(onDialogClick){
			$(overlay).click(removeAll);
			$(confirmBox).click(function(event){
				event.stopPropagation();
			});
		}

        var messageLabel = document.createElement(&#x27;div&#x27;);
        $(messageLabel).css({
            //&#x27;top&#x27;: &#x27;5%&#x27;,
            //&#x27;height&#x27;: &#x27;20%&#x27;,
            //&#x27;width&#x27;: &#x27;90%&#x27;,
            //&#x27;color&#x27;: &#x27;white&#x27;,
            //&#x27;margin&#x27;: &#x27;5%&#x27;,
            //&#x27;font-size&#x27;: &#x27;200%&#x27;

            color: &#x27;white&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;height&#x27;: &#x27;15%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;top&#x27;: &#x27;12.5%&#x27;,
            &#x27;font-size&#x27;: &#x27;1.25em&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;word-wrap&#x27;: &#x27;break-word&#x27;,

        });
        if (useHTML) {
            $(messageLabel).html(message);
        } else {
            $(messageLabel).text(message);
        }
        var optionButtonDiv = document.createElement(&#x27;div&#x27;);
        $(optionButtonDiv).addClass(&#x27;optionButtonDiv&#x27;);
        $(optionButtonDiv).css({
            &#x27;height&#x27;: &#x27;10%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;bottom&#x27;: &#x27;12%&#x27;,
            &#x27;right&#x27;: &#x27;2%&#x27;,
        });

        var confirmButton = document.createElement(&#x27;button&#x27;);
        $(confirmButton).css({
            //&#x27;font-size&#x27;: &#x27;140%&#x27;,
            //&#x27;margin-left&#x27;: &#x27;2%&#x27;,
            //&#x27;float&#x27;: &#x27;right&#x27;,
            //&#x27;margin-right&#x27;:&#x27;2%&#x27;

            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            //&#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;-3%&#x27;,
        });
        buttonText = (!buttonText || buttonText === &quot;&quot;) ? &quot;OK&quot; : buttonText;
        $(confirmButton).text(buttonText);
        confirmButton.onclick = function () {
            if (clickAction) {
                clickAction();
            }
            removeAll();
        };

        function onEnter() {
            if(clickAction) {
                clickAction();
            }
            removeAll();
            
        }

        globalKeyHandler[0] = { 13: onEnter, };

        function removeAll() {
            if (noFade) {
                $(overlay).hide();
                $(overlay).remove();
            } else {
                $(overlay).fadeOut(500, function () { $(overlay).remove(); });
            }
            globalKeyHandler[0] = currentKeyHandler;
        }

        $(optionButtonDiv).append(confirmButton);

        $(confirmBox).append(messageLabel);
        $(confirmBox).append(optionButtonDiv);

        $(overlay).append(confirmBox);
        return overlay;
    }

    
    // popup message to ask for user confirmation of an action e.g. deleting a tour
    function PopUpConfirmation(confirmAction, message, confirmButtonText, noFade, cancelAction, container, onkeydown) {
        var overlay = blockInteractionOverlay();
        container = container || window;
        var confirmBox = document.createElement(&#x27;div&#x27;);
        var popUpHandler = {
            13: doOnEnter,
        }
        var currKeyHandler = globalKeyHandler[0];
        globalKeyHandler[0] = popUpHandler;
        
        
        var confirmBoxSpecs = TAG.Util.constrainAndPosition($(container).width(), $(container).height(),
            {
                center_h: true,
                center_v: true,
                width: 0.5,
                height: 0.25,
                max_width: 560,
                max_height: 200,
            });

        $(confirmBox).css({
            position: &#x27;absolute&#x27;,
            left: confirmBoxSpecs.x + &#x27;px&#x27;,
            top: confirmBoxSpecs.y + &#x27;px&#x27;,
            width: confirmBoxSpecs.width + &#x27;px&#x27;,
            height: confirmBoxSpecs.height + &#x27;px&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;
        });

        var messageLabel = document.createElement(&#x27;div&#x27;);
        $(messageLabel).css({
            color: &#x27;white&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;height&#x27;: &#x27;15%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;top&#x27;: &#x27;12.5%&#x27;,
            &#x27;font-size&#x27;: &#x27;1.25em&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;word-wrap&#x27;: &#x27;break-word&#x27;
        });
        $(messageLabel).text(message);
        var optionButtonDiv = document.createElement(&#x27;div&#x27;);
        $(optionButtonDiv).addClass(&#x27;optionButtonDiv&#x27;);
        $(optionButtonDiv).css({
            &#x27;height&#x27;: &#x27;20%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;bottom&#x27;: &#x27;10%&#x27;,
            &#x27;right&#x27;: &#x27;5%&#x27;
        });

        var confirmButton = document.createElement(&#x27;button&#x27;);
        $(confirmButton).css({
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;left&quot;,
            &#x27;margin-left&#x27;: &#x27;12%&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;

        });
        confirmButtonText = (!confirmButtonText || confirmButtonText === &quot;&quot;) ? &quot;Confirm&quot; : confirmButtonText;
        $(confirmButton).text(confirmButtonText);
        
        confirmButton.onclick = function () {
            removeAll();
            confirmAction();
        };

        confirmButton.onkeydown = function (event) {
            switch (event.which) {
                case 13: // enter key
                    removeAll();
                    confirmAction();
            }
        }

        var cancelButton = document.createElement(&#x27;button&#x27;);
        $(cancelButton).css({
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;
        });
        $(cancelButton).text(&#x27;Cancel&#x27;);
        cancelButton.onclick = function () {
            removeAll();
            cancelAction &amp;&amp; cancelAction();
        }

        
        
        function doOnEnter() {
            removeAll();
            confirmAction();
        }

        function removeAll() {
            if (noFade) {
                $(overlay).hide();
                $(overlay).remove();
            } else {
                $(overlay).fadeOut(500, function () { $(overlay).remove(); });
            }
            globalKeyHandler[0] = currKeyHandler;
        }

        $(optionButtonDiv).append(cancelButton);
        $(optionButtonDiv).append(confirmButton);

        $(confirmBox).append(messageLabel);
        $(confirmBox).append(optionButtonDiv);

        $(overlay).append(confirmBox);
        return overlay;
    }

    /**
     * Create an input box popup
     * @method popupInputBox
     * @param {Object} options             some input options (callback function for confirm button, etc)
     *            {Function} cancelAction    action to take on clicking &quot;cancel&quot;
     *            {Function} confirmAction   action to take on clicking &quot;confirm&quot;
     *            {jQuery obj} container     container used for styling the popup box
     *            {String} message           message to show at top of popup
     *            {String} placeholder       placeholder text inside input field
     *            {String} confirmText       custom text for the &quot;confirm&quot; button
     * @return {jQuery obj}                overly of popup box
     */
    function popupInputBox(options) {
        var overlay = $(blockInteractionOverlay()),
            cancelAction = function () {
                options.cancelAction &amp;&amp; options.cancelAction();
                removeAll();
            },
            confirmAction = function () {
                options.confirmAction &amp;&amp; options.confirmAction(inputField.val()); // TODO iframe sanitize input here?
                removeAll();
            },
            popupHandler = {
                13: confirmAction
            },
            container = options.container || window,
            currKeyHandler = globalKeyHandler[0],
            popupBox = $(document.createElement(&#x27;div&#x27;)),
            popupBoxSpecs = TAG.Util.constrainAndPosition($(container).width(), $(container).height(), {
                center_h: true,
                center_v: true,
                width: 0.5,
                height: 0.35,
                max_width: 560,
                max_height: 200,
            }),
            messageLabel = $(document.createElement(&#x27;div&#x27;)),
            optionButtonDiv = $(document.createElement(&#x27;div&#x27;)),
            inputField = $(document.createElement(&#x27;input&#x27;)),
            message = options.message || &#x27;&#x27;,
            confirmButton = $(document.createElement(&#x27;button&#x27;)),
            cancelButton = $(document.createElement(&#x27;button&#x27;)),
            confirmButtonText = options.confirmText || &#x27;&#x27;;

        globalKeyHandler[0] = popupHandler; // TODO KEYHANDLER should we be prepending rather than overwriting first element? same with popupconfirmation above

        popupBox.css({
            position: &#x27;absolute&#x27;,
            left: popupBoxSpecs.x + &#x27;px&#x27;,
            top: popupBoxSpecs.y + &#x27;px&#x27;,
            width: popupBoxSpecs.width + &#x27;px&#x27;,
            height: popupBoxSpecs.height + &#x27;px&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;
        });

        messageLabel.css({
            color: &#x27;white&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;height&#x27;: &#x27;30%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;top&#x27;: &#x27;12.5%&#x27;,
            &#x27;font-size&#x27;: &#x27;0.6em&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;word-wrap&#x27;: &#x27;break-word&#x27;
        });

        messageLabel.text(message);

        inputField.css({
            width: &#x27;60%&#x27;,
            left: &#x27;20%&#x27;,
            position: &#x27;relative&#x27;
        });
        inputField.attr({
            type: &#x27;text&#x27;,
            placeholder: options.placeholder || &#x27;Paste URL here...&#x27;
        });

        optionButtonDiv.addClass(&#x27;optionButtonDiv&#x27;);
        optionButtonDiv.css({
            &#x27;height&#x27;: &#x27;20%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;bottom&#x27;: &#x27;10%&#x27;,
            &#x27;right&#x27;: &#x27;5%&#x27;
        });

        confirmButton.css({
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;left&quot;,
            &#x27;margin-left&#x27;: &#x27;12%&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;

        });
        confirmButtonText = !confirmButtonText ? &quot;Confirm&quot; : confirmButtonText;
        confirmButton.text(confirmButtonText);

        confirmButton.on(&#x27;click&#x27;, confirmAction);

        confirmButton.on(&#x27;keydown&#x27;, function (event) { // TODO KEYHANDLER do we need a separate keydown handler for this? should be handled in global key handling
            switch (event.which) {
                case 13: // enter key
                    confirmAction();
            }
        });

        cancelButton.css({
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;-1%&#x27;
        });
        cancelButton.text(&#x27;Cancel&#x27;);
        cancelButton.on(&#x27;click&#x27;, cancelAction);

        function removeAll() {
            overlay.fadeOut(500, function () {
                overlay.remove();
            });
            globalKeyHandler[0] = currKeyHandler;
        }

        optionButtonDiv.append(cancelButton);
        optionButtonDiv.append(confirmButton);

        popupBox.append(messageLabel);
        popupBox.append(inputField);
        popupBox.append(optionButtonDiv);

        overlay.append(popupBox);
        return overlay;
    }

    /**
     * Following functions transition between pages while in splitscreen mode
     */
    /**
     * Use _Split fn&#x27;s for transitions that need to preserve splitscreen
     * Note: pages passed in to this function should have a top-level root node
     * (true of exhibition, catalog and artmode)
     */
    // used for setting button colors
    function cgBackColor(buttonType, buttonToChange, isMouseLeave) {
        switch (buttonType) {
            case &quot;backButton&quot;:
                if (!isMouseLeave) {
                    $(buttonToChange).css({ &#x27;background-color&#x27;: &#x27;gray&#x27;, &#x27;border-radius&#x27;: &#x27;999px&#x27; });
                }
                else {
                    $(buttonToChange).css({ &#x27;background-color&#x27;: &#x27;transparent&#x27;, &#x27;border-radius&#x27;: &#x27;999px&#x27; });
                }
                break;
            case &quot;labelButton&quot;:
                $(buttonToChange).css({ &#x27;background-color&#x27;: &#x27;white&#x27;, &#x27;color&#x27;: &#x27;black&#x27; });
                break;
            case &quot;forwardButton&quot;:
                $(buttonToChange).css({ &#x27;background-color&#x27;: &#x27;gray&#x27; });
                break;
        }
    }

    /**
     * Set up handlers for back button
     * @method setUpBackButton
     * @param {jQuery Obj} elt         jQuery object for back button element
     * @param {Function} clickHandler  click handler for button
     */
    function setUpBackButton(elt, clickHandler) {
        elt.on(&#x27;mouseleave&#x27;, function () {
            cgBackColor(&quot;backButton&quot;, elt, true);
        });
        elt.on(&#x27;mousedown&#x27;, function () {
            cgBackColor(&quot;backButton&quot;, elt, false);
        });
        elt.on(&#x27;click&#x27;, clickHandler);
    }

    // slide towards left (splitscreen)
    function slidePageLeftSplit(oldpage, newpage, callback) {
        var outgoingDone = false,
            incomingDone = false,
            metaContainer = oldpage.parent(),
            outgoing = makeFullPage(),
            incoming = makeFullPage();
        
        var elements = metaContainer.children();
        elements.remove();

        elements.appendTo($(outgoing));
        $(outgoing).css({ left: &quot;0%&quot;, float: &quot;left&quot; });

        $(incoming).append(newpage);
        $(incoming).css({ left: &quot;120%&quot;, display: &quot;inline&quot; });

        metaContainer.append(outgoing);
        metaContainer.append(incoming);

        $(outgoing).animate({ left: &quot;-120%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: &quot;0%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(incoming).detach();
            metaContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone &amp;&amp; incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // slide towards right (splitscreen)
    function slidePageRightSplit(oldpage, newpage, callback) {
        var outgoingDone = false,
            incomingDone = false,
            metaContainer = oldpage.parent(),
            outgoing = makeFullPage(),
            incoming = makeFullPage(),
            elements = metaContainer.children();

        elements.detach();

        elements.appendTo($(outgoing));
        $(outgoing).css({ left: &quot;0%&quot;, float: &quot;left&quot; });

        $(incoming).append(newpage);
        $(incoming).css({ left: &quot;-120%&quot;, display: &quot;inline&quot; });

        metaContainer.append(outgoing);
        metaContainer.append(incoming);

        $(outgoing).animate({ left: &quot;120%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: &quot;0%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(incoming).detach();
            metaContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone &amp;&amp; incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    /**
     * Use for any page transition that does not need to preserve splitscreen
     */
    // towards left
    function slidePageLeft(newpage, callback) {
        
        var outgoingDone = false;
        var incomingDone = false;
        var tagContainer = $(&#x27;#tagRoot&#x27;);

        var elements = tagContainer.children();
        elements.remove();

        var outgoing = makeFullPage();
        elements.appendTo($(outgoing));
        $(outgoing).css({ left: &quot;0%&quot;, float: &quot;left&quot; });

        var incoming = makeFullPage();
        $(incoming).append(newpage);
        $(incoming).css({ left: &quot;120%&quot;, display: &quot;inline&quot; });

        tagContainer.append(outgoing);
        tagContainer.append(incoming);

        $(outgoing).animate({ left: &quot;-120%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: &quot;0%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(incoming).detach();
            tagContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone &amp;&amp; incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // towards right
    function slidePageRight(newpage, callback) {
        var outgoingDone = false;
        var incomingDone = false;
        var tagContainer = $(&#x27;#tagRoot&#x27;);

        var elements = tagContainer.children();
        elements.remove();

        var outgoing = makeFullPage();
        elements.appendTo($(outgoing));
        $(outgoing).css({ left: &quot;0%&quot;, float: &quot;left&quot; });

        var incoming = makeFullPage();
        $(incoming).append(newpage);
        $(incoming).css({ left: &quot;-120%&quot;, display: &quot;inline&quot; });

        tagContainer.append(outgoing);
        tagContainer.append(incoming);

        $(outgoing).animate({ left: &quot;120%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(outgoing).remove();
            outgoingDone = true;
            makeCallback();
        });
        $(incoming).animate({ left: &quot;0%&quot; }, 1000, &#x27;easeOutQuad&#x27;, function () {
            $(incoming).detach();
            tagContainer.append(newpage);
            incomingDone = true;
            makeCallback();
        });

        function makeCallback() {
            if (outgoingDone &amp;&amp; incomingDone) {
                if (callback)
                    callback();
            }
        }
    }

    // cleanup: currently unused, leave or delete up to reviewer
    /*function makeTriangle(width, height, color) {
        var toReturn = document.createElement(&#x27;div&#x27;);
        $(toReturn).css({
            width: &quot;0px&quot;, height: &quot;0px&quot;, &quot;border-top&quot;: (height / 2) + &quot;px solid transparent&quot;,
            &quot;border-bottom&quot;: (height / 2) + &quot;px solid transparent&quot;, &quot;border-left&quot;: width + &quot;px solid &quot; + color
        });
        return toReturn;
    }*/

    // make a full-page div
    function makeFullPage() {
        var newPage = document.createElement(&quot;div&quot;);
        $(newPage).css({ height: &quot;100%&quot;, width: &quot;100%&quot;, position: &quot;absolute&quot; });
        return newPage;
    }

    function hexToRGB(h) { return &#x27;rgba(&#x27; + hexToR(h) + &#x27;,&#x27; + hexToG(h) + &#x27;,&#x27; + hexToB(h) + &#x27;,&#x27;; } // return rgba value of hex color leaving space for alpha
    function hexToR(h) { return parseInt((cutHex(h)).substring(0, 2), 16); }
    function hexToG(h) { return parseInt((cutHex(h)).substring(2, 4), 16); }
    function hexToB(h) { return parseInt((cutHex(h)).substring(4, 6), 16); }
    function cutHex(h) { return (h.charAt(0) === &quot;#&quot;) ? h.substring(1, 7) : h; }

    /**
     * Take in a color (in &#x27;#abcdef&#x27; format) and an opacity (0-1) and return an rgba(..) string
     * @method hexToRGBA
     * @param {String} color       input color as a hex string
     * @param {String} opac        input opacity
     * @return {String}            &#x27;rgba(color.r, color.g, color.b, opac)&#x27;
     */
    function hexToRGBA(color, opac) {
        var r, g, b;

        color = color.replace(/\#/g, &#x27;&#x27;);
        color = color.substring(0, 6);

        r = parseInt(color.substring(0, 2), 16);
        g = parseInt(color.substring(2, 4), 16);
        b = parseInt(color.substring(4, 6), 16);

        return &#x27;rgba(&#x27; + r + &#x27;,&#x27; + g + &#x27;,&#x27; + b + &#x27;,&#x27; + opac + &#x27;)&#x27;;
    }

    //Takes a RGB or RGBA color value as input and outputs the Hex color representation, without the &#x27;#&#x27; symbol in front
    function colorToHex(rgb) {
        var digits = rgb.match(/(rgb|rgba)\((\d+),\s*(\d+),\s*(\d+)\,*\s*((\d+\.\d+)|\d+)*\)$/);
        function hex(x) {
            var str = (&quot;0&quot; + parseInt(x, 10).toString(16)).toUpperCase();  
            return str.slice(-2);
        }
        if (digits !== null &amp;&amp; digits !== undefined) { // string.match() returns null if regexp fails
            return hex(digits[2]) + hex(digits[3]) + hex(digits[4]);
        }
        else if (rgb === &quot;transparent&quot;) {
            return &quot;000000&quot;; // Prevent this from breaking due to bad server state (jastern 3/7/2013)
        }
        else {
            return &quot;000000&quot;;
        }
    }

    /**
     * Take in a color and return a dimmed version of that color (divide rgb by k)
     * @param {String} inColor      input color as a hex string
     * @param {Number} k            dimming factor
     * @return {String}             formatted as &#x27;rbg(_,_,_)&#x27;
     */
    function dimColor(inColor, k) {
        var r,
            g,
            b;

        k = k || 3;

        inColor = inColor.replace(/\#/g, &#x27;&#x27;);
        inColor = inColor.substring(0, 6);

        r = Math.round(parseInt(inColor.substring(0, 2), 16) / k);
        g = Math.round(parseInt(inColor.substring(2, 4), 16) / k);
        b = Math.round(parseInt(inColor.substring(4, 6), 16) / k); 

        return &#x27;rgb(&#x27; + r + &#x27;,&#x27; + g+ &#x27;,&#x27; + b + &#x27;)&#x27;;
    }

    //function called to fit the text (that is wrapped in a span) within a div element.
    //created for fitting text in museumInfo
    function fitTextInDiv(element, max, min) {
        var fontSize = parseInt(element.css(&#x27;font-size&#x27;), 10);
        if (parseInt(element.parent()[0].scrollHeight, 10) &gt; element.parent().height()) {
            while (parseInt(element.parent()[0].scrollHeight, 10) &gt; element.parent().height() &amp;&amp; fontSize &gt; min) {
                fontSize--;
                element.css(&#x27;font-size&#x27;, fontSize + &#x27;px&#x27;);
            }
        } else if (parseInt(element.height(), 10) &lt; (element.parent().height())) {
            while (parseInt(element.height(), 10) &lt; (element.parent().height()) &amp;&amp; fontSize &lt; max) {
                fontSize++;
                element.css(&#x27;font-size&#x27;, fontSize + &#x27;px&#x27;);
                if (parseInt(element.parent()[0].scrollHeight, 10) &gt; element.parent().height()) {
                    fontSize--;
                    element.css(&#x27;font-size&#x27;, fontSize);
                    break;
                }
            }
        }
    }


    //Creates Microsoft.Maps.Pushpin objects from the locObjects within the locationList object, and displays the pushpins on the map
    function drawPushpins(locationList, map) {
        map.entities.clear();
        for (var i = 0; i &lt; locationList.length; i++) {
            var locationItem = locationList[i];
            var location;
            if (locationItem.resource.latitude) { // if latitude exists then it&#x27;s a custom pushpin
                location = locationItem.resource;
            } else {
                var lat = locationItem.resource.point.coordinates[0];
                var long = locationItem.resource.point.coordinates[1];
                location = new Microsoft.Maps.Location(lat, long);
            }
            var pushpinOptions = {
                text: String(i + 1),
                icon: tagPath+&#x27;images/icons/locationPin.png&#x27;,
                width: 20,
                height: 30
            };
            var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);

            //Add some info about the location in the pin
            //if (locationItem.date) {
            //    pushpin.date = locationItem.date;
            //} else {
            //    pushpin.date = &#x27;Date Unspecified&#x27;;
            //}

            pushpin.location = locationItem.address;
            pushpin.description = &#x27;&#x27;;
            if (locationItem.info) {
                pushpin.description = locationItem.info;
            }
            map.entities.push(pushpin);
        }

    }

    function addCustomPushpin(locs, currentLocationIndex) {
        var pushpinOptions = {
            text: String(currentLocationIndex),
            icon: tagPath+&#x27;images/icons/locationPin.png&#x27;,
            width: 20,
            height: 30
        };
        var pushpin = new Microsoft.Maps.Pushpin(locs.resource, pushpinOptions);
        pushpin.location = locs.address;
        pushpin.description = &#x27;&#x27;;
        if (locs.info) {
            pushpin.description = locs.info;
        }
        locs.pushpin = pushpin;
    }

    //function takes a locObject and creates the pushpins that correspond to them 
    function addPushpinToLoc(locs, currentLocationIndex) {
        //set pushpin for location
        if (locs.resource.latitude) {
            addCustomPushpin(locs, currentLocationIndex);
            return;
        }
        var lat = locs.resource.point.coordinates[0];
        var long = locs.resource.point.coordinates[1];
        var location = new Microsoft.Maps.Location(lat, long);
        var pushpinOptions = {
            text: String(currentLocationIndex),
            icon: tagPath+&#x27;images/icons/locationPin.png&#x27;,
            width: 20,
            height: 30
        };
        var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);

        //Add some info about the location in the pin
        //if (locs.date &amp;&amp; !isNaN(locs.date.year)) {
        //    pushpin.date = locs.date;
        //} else {
        //    pushpin.date = &#x27;Date Unspecified&#x27;;
        //}

        pushpin.location = locs.address;
        pushpin.description = &#x27;&#x27;;
        if (locs.info) {
            pushpin.description = locs.info;
        }
        //assign pushpin to location
        locs.pushpin = pushpin;
    }

    //gets JSON encoded location list from artwork XML and displays the information
    function getLocationList(metadata) { //TODO DW - update/review this
        var locationList;
        //parsing the location field in the artwork metadata to obtain the pushpin information
        var data = metadata.RichLocationHistory || metadata.Location;
        try {
            locationList = JSON.parse(data);
        } catch (e) {
            console.log(&#x27;artwork location metadata cannot be parsed.&#x27;);
            locationList = [];
            return locationList;
        }

        if (locationList.locations) {
            // load dates and modernize old date objects
            for (var i = 0; i &lt; locationList.locations.length; i++) {
                var locationItem = locationList.locations[i];
                if (locationItem.date) {
                    // convert old dates to new dates
                    if (locationItem.date.getFullYear) {
                        var y = date.getUTCFullYear();
                        var m = date.getUTCMonth();
                        var d = date.getUTCDay();
                        locationItem.date = {
                            year: y,
                            month: m,
                            day: d,
                        }
                    }
                    //no longer needed
                    //locationItem.pushpin.date = locationItem.date;
                }
            }
            return locationList.locations;
        } else {
            // load dates and modernize old date objects
            for (var i = 0; i &lt; locationList.length; i++) {
                var locationItem = locationList[i];
                if (locationItem.date) {
                    // convert old dates to new dates
                    if (locationItem.date.getFullYear) {
                        var y = date.getUTCFullYear();
                        var m = date.getUTCMonth();
                        var d = date.getUTCDay();
                        locationItem.date = {
                            year: y,
                            month: m,
                            day: d,
                        }
                    }
                    locationItem.pushpin.date = locationItem.date;
                }
            }
            return locationList;
        }
    }

    var selectCSS = {
        &#x27;color&#x27;: &#x27;#aaaaaa&#x27;,
        &#x27;display&#x27;: &#x27;inline-block&#x27;,
        &#x27;margin-left&#x27;: &#x27;20px&#x27;
    };

    /**
     * Creates a picker (e.g. click add/remove media in the artwork editor) to manage
     *   associations between different TAG components (exhib, artworks, assoc media)
     * @param root           object: jquery object for the root of the DOM (we&#x27;ll append an overlay to this)
     * @param title          string: the title to appear at the top of the picker
     * @param target         object: a comp property (object whose associations we&#x27;re managing) and a type property
     *                               (&#x27;exhib&#x27;, &#x27;artwork&#x27;, &#x27;media&#x27;) telling us what kind of component it is
     * @param type           string: &quot;exhib&quot; (exhib-artwork), &quot;artwork&quot; (artwork-media) : type of the association
     * @param tabs           array: list of tab objects. Each has a name property (string, title of tab), a getObjs
     *                              property (a function to be called to get each entity listed in the tab), and a
     *                              args property (which will be extra arguments sent to getObjs)
     * @param filter         object: a getObjs property to get components that are already associated with target
     *                               (e.g. getAssocMediaTo if type=&#x27;artwork&#x27;) and an args property (extra args to getObjs)
     * @param callback       function: function to be called when import is clicked or a component is double clicked
     */
    function createAssociationPicker(root, title, target, type, tabs, filter, callback) {
        var pickerOverlay,
            picker,
            pickerHeader,
            tabBanner,
            tab,
            i,
            searchTab,
            pickerSearchBar,
            selectAllLabel,
            deselectAllLabel,
            mainContainer,
            addedComps = [], // components we will be associating to target
            addedCompsObjs = [], // keep track of the component objects (to be added to the recently associated list)
            removedComps = [], // components whose associations with target we will be removing
            origComps = [], // components that are already associated with target
            tabCache = [], // cached results from the server
            loadQueue = TAG.Util.createQueue(),

            currentKeyHandler = globalKeyHandler[0];
            globalKeyHandler[0] = { 13: onEnter };

        for (i = 0; i &lt; tabs.length; i++) {
            tabCache.push({ cached: false, comps: [] });
        }

        var filterArgs = (filter.args || []).concat([function (comps) { // this has async stuff, make sure it gets called by the time it needs to be
            for (i = 0; i &lt; comps.length; i++) {
                origComps.push(comps[i].Identifier);
            }
        }, error, cacheError]);
        filter.getObjs.apply(null, filterArgs);

        // overlay
        pickerOverlay = $(blockInteractionOverlay());
        pickerOverlay.addClass(&#x27;pickerOverlay&#x27;);
        pickerOverlay.css(&#x27;z-index&#x27;, 10000000);
        pickerOverlay.appendTo($(root));
        pickerOverlay.fadeIn();

        // picker div
        picker = $(document.createElement(&#x27;div&#x27;));
        picker.addClass(&quot;picker&quot;);
        picker.css({
            position: &#x27;absolute&#x27;,
            width: &#x27;70%&#x27;,
            height: &#x27;60%&#x27;,
            padding: &#x27;1%&#x27;,
            &#x27;padding-left&#x27;: &#x27;2%&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
            &#x27;border&#x27;: &#x27;3px double white&#x27;,
            top: &#x27;19%&#x27;,
            left: &#x27;19%&#x27;,
        });
        pickerOverlay.append(picker);

        // heading
        pickerHeader = $(document.createElement(&#x27;div&#x27;));
        pickerHeader.addClass(&#x27;pickerHeading&#x27;);
        pickerHeader.text(title);
        pickerHeader.css({
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;font-size&#x27;: &#x27;150%&#x27;,
            &#x27;height&#x27;: &#x27;8%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;10px&#x27;
        });
        picker.append(pickerHeader);

        // tab container
        if( tabs.length &gt;= 2) {
            tabBanner = $(document.createElement(&#x27;div&#x27;));
            tabBanner.css({
                &#x27;width&#x27;: &#x27;100%&#x27;,
                &#x27;height&#x27;: &#x27;8%&#x27;,
                &#x27;left&#x27;: &#x27;5%&#x27;
            });
            tabBanner.attr(&quot;id&quot;, &quot;tabBanner&quot;);
            picker.append(tabBanner);

            // tabs
            for (i = 0; i &lt; tabs.length; i++) {
                tab = $(document.createElement(&#x27;div&#x27;));
                tab.addClass(&#x27;tab&#x27;);
                tab.attr(&#x27;id&#x27;, &#x27;tab&#x27; + i);
                tab.css({
                    &#x27;display&#x27;: &#x27;inline-block&#x27;,
                    &#x27;min-width&#x27;: &#x27;20%&#x27;,
                    &#x27;width&#x27;: &#x27;auto&#x27;,
                    &#x27;padding-left&#x27;: &#x27;2%&#x27;,
                    &#x27;padding-right&#x27;: &#x27;2%&#x27;,
                    &#x27;padding-top&#x27;: &#x27;1%&#x27;,
                    &#x27;height&#x27;: &#x27;85%&#x27;,
                    &#x27;color&#x27;: &#x27;white&#x27;,
                    &#x27;border-top&#x27;: &#x27;1px solid &#x27; + ((i === 0) ? &#x27;white&#x27; : &#x27;black&#x27;),
                    &#x27;border-right&#x27;: &#x27;1px solid &#x27; + ((i === 0) ? &#x27;white&#x27; : &#x27;black&#x27;),
                    &#x27;border-left&#x27;: &#x27;1px solid &#x27; + ((i === 0) ? &#x27;white&#x27; : &#x27;black&#x27;), // repeated computation
                    &#x27;border-bottom&#x27;: &#x27;1px solid &#x27; + ((i === 0) ? &#x27;black&#x27; : &#x27;white&#x27;),
                    &#x27;text-align&#x27;: &#x27;center&#x27;,

                });
                tab.text(tabs[i].name);
                tab.on(&#x27;click&#x27;, tabHelper(i));
                tabBanner.append(tab);
            }
            tab = $(document.createElement(&#x27;div&#x27;));
            tab.attr(&quot;id&quot;, &quot;extraSpaceAwwwwwYeahhhh&quot;);
            tab.css({
                &#x27;display&#x27;: &#x27;inline-block&#x27;,
                &#x27;color&#x27;: &#x27;black&#x27;,
                &#x27;width&#x27;: (90 - 20 * tabs.length) + &#x27;%&#x27;,
                &#x27;height&#x27;: &#x27;100%&#x27;,
                &#x27;border-bottom&#x27;: &#x27;1px solid white&#x27;,
                &#x27;border-left&#x27;: &#x27;1px solid black&#x27;
            });
            tab.text(&#x27;_&#x27;); // suuuuuuuuper hacky; vertical positioning wasn&#x27;t right... TODO
            //tabBanner.append(tab);
        }

        searchTab = $(document.createElement(&#x27;div&#x27;));
        searchTab.attr(&quot;id&quot;,&quot;searchTab&quot;);
        searchTab.css({
            &#x27;height&#x27;: &#x27;8%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;margin-top&#x27;: &#x27;2%&#x27;,
            &#x27;top&#x27;: &#x27;13%&#x27;
        })

        picker.append(searchTab);

        // search bar
        pickerSearchBar = $(document.createElement(&#x27;input&#x27;));
        pickerSearchBar.attr(&#x27;type&#x27;, &#x27;text&#x27;);
        pickerSearchBar.css({
            &#x27;margin-left&#x27;: &#x27;1%&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;,
            &#x27;height&#x27;: &#x27;55%&#x27;,
        });
        pickerSearchBar.on(&#x27;keyup&#x27;, function (event) {
            event.stopPropagation();
        });
        // TAG.Util.defaultVal(&quot;Search by Name...&quot;, pickerSearchBar, true, IGNORE_IN_SEARCH); // TODO more specific search (e.g. include year for artworks)
        pickerSearchBar.attr(&quot;placeholder&quot;, &quot;Search&quot;);
        pickerSearchBar.keyup(function () {
            TAG.Util.searchData(pickerSearchBar.val(), &#x27;.compHolder&#x27;, IGNORE_IN_SEARCH);
        });
        pickerSearchBar.change(function () {
            if (pickerSearchBar.val() !== &#x27;&#x27;) {
                TAG.Util.searchData(pickerSearchBar.val(), &#x27;.compHolder&#x27;, IGNORE_IN_SEARCH);
            }
        });
        searchTab.append(pickerSearchBar);

        // select all label
        selectAllLabel = $(document.createElement(&#x27;div&#x27;));
        selectAllLabel.attr(&quot;id&quot;, &quot;selectAllLabel&quot;);
        selectAllLabel.css({
            &#x27;color&#x27;: &#x27;#aaaaaa&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;margin-left&#x27;: &#x27;5%&#x27;
        });
        selectAllLabel.text(&#x27;Select All&#x27;);
        selectAllLabel.on(&#x27;click&#x27;, function () {
            var holder, guid, index;
            $.each($(&#x27;.compHolder&#x27;), function (ind, holderElt) {
                holder = $(holderElt);
                if (!holder.data(&quot;selected&quot;) &amp;&amp; holder.css(&quot;display&quot;) !== &quot;none&quot;) {
                    holder.css(&#x27;background&#x27;, &#x27;#999&#x27;);
                    holder.data(&quot;selected&quot;, true);
                    guid = holder.data(&quot;guid&quot;);
                    index = origComps.indexOf(guid);
                    if (index &gt;= 0) {
                        removedComps.remove(guid);
                    } else {
                        addedComps.push(guid);
                        addedCompsObjs.push(holder.data(&#x27;comp&#x27;));
                    }
                }
            });
        }); // TODO
        searchTab.append(selectAllLabel);

        // deselect all label
        deselectAllLabel = $(document.createElement(&#x27;div&#x27;));
        deselectAllLabel.attr(&quot;id&quot;, &quot;deselectAllLabel&quot;);
        deselectAllLabel.css({
            &#x27;color&#x27;: &#x27;#aaaaaa&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;margin-left&#x27;: &#x27;5%&#x27;
        });
        deselectAllLabel.text(&#x27;Deselect All&#x27;);
        deselectAllLabel.on(&#x27;click&#x27;, function () {
            var holder, guid, index, addedIndex;
            $.each($(&#x27;.compHolder&#x27;), function (ind, holderElt) {
                holder = $(holderElt);
                if (holder.data(&quot;selected&quot;) &amp;&amp; holder.css(&quot;display&quot;) !== &quot;none&quot;) {
                    holder.css(&#x27;background&#x27;, &#x27;#222&#x27;);
                    holder.data(&quot;selected&quot;, false);
                    guid = holder.data(&quot;guid&quot;);
                    index = origComps.indexOf(guid);
                    if (index &gt;= 0) {
                        removedComps.push(guid)
                    } else {
                        addedIndex = addedComps.indexOf(guid);
                        addedComps.splice(addedIndex, 1);
                        addedCompsObjs.splice(addedIndex, 1);
                    }
                }
            });
        }); // TODO
        searchTab.append(deselectAllLabel);

        // main thumbnail container
        mainContainer = $(document.createElement(&#x27;div&#x27;));
        mainContainer.attr(&quot;id&quot;, &quot;mainThumbnailContainer&quot;);
        mainContainer.css({
            &#x27;overflow-y&#x27;: &#x27;scroll&#x27;,
            &#x27;margin-top&#x27;: &#x27;10px&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            //&#x27;height&#x27;: &#x27;75%&#x27; // should actually figure out how tall this should be based on other elements TODO
        });
        picker.append(mainContainer);
        mainContainer.css({height: (picker.height() - mainContainer.offset().top + picker.offset().top - 30) + &quot;px&quot;});

        // cancel and save buttons
        var optionButtonDiv = $(document.createElement(&#x27;div&#x27;));
        optionButtonDiv.addClass(&#x27;optionButtonDiv&#x27;);
        optionButtonDiv.css({
            &#x27;height&#x27;: &#x27;5%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;
        });

        var progressCSS = {
            &#x27;left&#x27;: &#x27;5%&#x27;,
            &#x27;top&#x27;: &#x27;15px&#x27;,
            &#x27;width&#x27;: &#x27;40px&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;z-index&#x27;: 50
        };

        var progressCirc;

        var confirmButton = $(document.createElement(&#x27;button&#x27;));
        confirmButton.css({
            &#x27;margin&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;padding-left&#x27;: &#x27;1%&#x27;,
            &#x27;padding-right&#x27;: &#x27;1%&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
        });
        confirmButton.text(&quot;Save Changes&quot;);
        confirmButton.on(&#x27;click&#x27;, function () {
            progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
            finalizeAssociations();
            globalKeyHandler[0] = currentKeyHandler;
        });

        /**Saves changes for pressing enter key
         * @method onEnter
         */
        function onEnter() {
            progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
            finalizeAssociations();
            globalKeyHandler[0] = currentKeyHandler;
        }

        var cancelButton = $(document.createElement(&#x27;button&#x27;));
        cancelButton.css({
            &#x27;margin&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;padding-left&#x27;: &#x27;1%&#x27;,
            &#x27;padding-right&#x27;: &#x27;1%&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;float&#x27;: &quot;right&quot;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;
        });
        cancelButton.text(&#x27;Cancel&#x27;);
        cancelButton.on(&#x27;click&#x27;, function () {
            pickerOverlay.fadeOut(function () { 
                pickerOverlay.empty(); 
                pickerOverlay.remove(); 
            }); //Josh L -- fix so the div actually fades out
            globalKeyHandler[0] = currentKeyHandler;
        });

        optionButtonDiv.append(cancelButton);
        optionButtonDiv.append(confirmButton);

        picker.append(optionButtonDiv);

        tabHelper(0)(); // load first tab

        // helper functions

        // click handler for tabs
        function tabHelper(j) {
            return function () {
                loadQueue.clear();
                progressCirc = TAG.Util.showProgressCircle(optionButtonDiv, progressCSS);
                pickerSearchBar.attr(&quot;value&quot;, &quot;&quot;);
                mainContainer.empty();
                $(&quot;.tab&quot;).css({
                    &#x27;border-top&#x27;: &#x27;1px solid black&#x27;,
                    &#x27;border-right&#x27;: &#x27;1px solid black&#x27;,
                    &#x27;border-left&#x27;: &#x27;1px solid black&#x27;,
                    &#x27;border-bottom&#x27;: &#x27;1px solid white&#x27;
                });
                $(&quot;#tab&quot; + j).css({
                    &#x27;border-top&#x27;: &#x27;1px solid white&#x27;,
                    &#x27;border-right&#x27;: &#x27;1px solid white&#x27;,
                    &#x27;border-left&#x27;: &#x27;1px solid white&#x27;,
                    &#x27;border-bottom&#x27;: &#x27;1px solid black&#x27;
                });
                if (!tabCache[j].cached) {
                    var tabArgs = (tabs[j].args || []).concat([function (comps) {
                        tabCache[j].cached = true;
                        tabCache[j].comps = comps;
                        success(comps);
                    }, error, cacheError]);
                    tabs[j].getObjs.apply(null, tabArgs);
                } else {
                    success(tabCache[j].comps); // used cached results if possible
                }

            }
        }

        function success(comps) {
            var newComps = [];
            for (var i = 0; i &lt; comps.length; i++) {
                if (!(type === &#x27;artwork&#x27; &amp;&amp; comps[i].Metadata.Type === &#x27;VideoArtwork&#x27;)) {
                    newComps.push(comps[i]);
                }
            }
            drawComps(newComps, compSingleDoubleClick);
            TAG.Util.removeProgressCircle(progressCirc);
        }

        function error() {
            console.log(&quot;ERROR IN TABHELPER&quot;);
        }

        function cacheError() {
            error();
        }

        /** 
         * Creates the media panel
         * @param compArray   the list of media to appear in the panel
         * @param applyClick  function to add handlers to each holder element
         */
        function drawComps(compArray, applyClick) {
            if (compArray) {
                addedComps.length = 0;
                addedCompsObjs.length = 0;
                removedComps.length = 0;
                compArray.sort(function (a, b) {
                    return (a.Name.toLowerCase() &lt; b.Name.toLowerCase()) ? -1 : 1;
                });
                for (var i = 0; i &lt; compArray.length; i++) {
                    loadQueue.add(drawComp(compArray[i], applyClick));
                }
            }
        }

        function drawComp(comp, applyClick) {
            return function () {
                var compHolder = $(document.createElement(&#x27;div&#x27;));
                compHolder.addClass(&quot;compHolder&quot;);
                compHolder.attr(&#x27;id&#x27;, comp.Identifier); // unique identifier for this media
                compHolder.data({
                    &#x27;type&#x27;: comp.Metadata.ContentType,
                    &#x27;guid&#x27;: comp.Identifier,
                    &#x27;name&#x27;: comp.Name,
                    &#x27;duration&#x27;: comp.Metadata.Duration,
                    &#x27;comp&#x27;: comp,
                    &#x27;year&#x27;: comp.Metadata.Year,
                    &#x27;artist&#x27;: comp.Metadata.Artist
                });
                var isSelected = (origComps.indexOf(comp.Identifier) &gt;= 0);//selectedArtworksUrls[compArray[i].Metadata.Source] ? true : false;
                if (isSelected) {
                    console.log(&quot;is selected&quot;);
                }
                compHolder.data(&#x27;selected&#x27;, isSelected);
                compHolder.css({
                    float: &#x27;left&#x27;,
                    background: isSelected ? &#x27;#999&#x27; : &#x27;#222&#x27;,
                    width: &#x27;15%&#x27;,
                    height: &#x27;35%&#x27;,
                    padding: &#x27;1%&#x27;,
                    //&#x27;padding-bottom&#x27;: &#x27;0%&#x27;,
                    margin: &#x27;1%&#x27;,
                    &#x27;text-align&#x27;: &#x27;center&#x27;,
                    border: &#x27;1px solid white&#x27;,
                    color: &#x27;white&#x27;
                });
                mainContainer.append(compHolder);

                // create the thumbnail to show in the media holder
                var imgHolderDiv = $(document.createElement(&#x27;div&#x27;));
                imgHolderDiv.addClass(&#x27;compHolderDiv&#x27;);
                imgHolderDiv.css({
                    &quot;position&quot;: &#x27;relative&#x27;,
                    &quot;height&quot;: &quot;75%&quot;,
                    &quot;margin&quot;: &quot;2%&quot;,
                    &quot;width&quot;:&quot;96%&quot;
                });
                compHolder.append(imgHolderDiv);

                var compHolderImage = $(document.createElement(&#x27;img&#x27;)); // change to img for image
                compHolderImage.addClass(&#x27;compHolderImage&#x27;);

                var typeIndicatorImage = $(document.createElement(&#x27;img&#x27;)); // to hold a tour or video icon
                typeIndicatorImage.addClass(&#x27;typeIndicatorImage&#x27;);

                var FIXPATH = TAG.Worktop.Database.fixPath;
                var shouldAppendTII = false;

                if (comp.Metadata.ContentType === &#x27;Audio&#x27;) {
                    compHolderImage.attr(&#x27;src&#x27;, tagPath+&#x27;images/audio_icon.svg&#x27;);
                } else if (comp.Metadata.ContentType === &#x27;Video&#x27; || comp.Type === &#x27;Video&#x27; || comp.Metadata.Type === &#x27;VideoArtwork&#x27;) {
                    compHolderImage.attr(&#x27;src&#x27;, (comp.Metadata.Thumbnail &amp;&amp; !comp.Metadata.Thumbnail.match(/.mp4/)) ? FIXPATH(comp.Metadata.Thumbnail) : &#x27;images/video_icon.svg&#x27;);
                    shouldAppendTII = true;
                    typeIndicatorImage.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/catalog_video_icon.svg&#x27;);
                } else if (comp.Metadata.ContentType === &#x27;Image&#x27; || comp.Type === &#x27;Image&#x27;) {
                    compHolderImage.attr(&#x27;src&#x27;, comp.Metadata.Thumbnail ? FIXPATH(comp.Metadata.Thumbnail) : tagPath+&#x27;images/image_icon.svg&#x27;);
                } else if (comp.Metadata.ContentType === &#x27;iframe&#x27;) {
                    compHolderImage.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/audio_icon.svg&#x27;); // TODO iframe fix this with new icon
                } else if (comp.Type === &#x27;Empty&#x27;) { // tours....don&#x27;t know why the type is &#x27;Empty&#x27;
                    compHolderImage.attr(&#x27;src&#x27;, comp.Metadata.Thumbnail ? FIXPATH(comp.Metadata.Thumbnail) : tagPath + &#x27;images/icons/catalog_tour_icon.svg&#x27;);
                    shouldAppendTII = true;
                    typeIndicatorImage.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/catalog_tour_icon.svg&#x27;);
                } else {//text associated media without any media...
                    compHolderImage.attr(&#x27;src&#x27;, tagPath + &#x27;images/text_icon.svg&#x27;);
                }

                // if (compHolderImage.height() / compHolderImage.width() &gt; 1) {
                //     compHolderImage.css({
                //         &#x27;width&#x27;: &#x27;auto&#x27;,
                //         &#x27;height&#x27;: &#x27;100%&#x27;,
                //     });
                // } else {
                //     compHolderImage.css({
                //         &#x27;height&#x27;: &#x27;auto&#x27;,
                //         &#x27;width&#x27;: &#x27;100%&#x27;,
                //     });
                // }

                compHolderImage.css({
                    &#x27;max-height&#x27;: &#x27;100%&#x27;,
                    &#x27;position&#x27;: &#x27;absolute&#x27;,
                    // &#x27;left&#x27;: &#x27;0&#x27;,
                    // &#x27;right&#x27;: &#x27;0&#x27;,
                    // &#x27;top&#x27;: &#x27;0&#x27;,
                    &#x27;bottom&#x27;: &#x27;0&#x27;,
                    &#x27;margin&#x27;: &#x27;auto&#x27;,
                    &#x27;max-width&#x27;: &#x27;100%&#x27;,
                    width: &#x27;auto&#x27;,
                    height: &#x27;auto&#x27;
                });
                // compHolderImage.removeAttr(&#x27;width&#x27;);
                // compHolderImage.removeAttr(&#x27;height&#x27;);
                imgHolderDiv.append(compHolderImage);

                if (shouldAppendTII) {
                    typeIndicatorImage.css({
                        &#x27;position&#x27;: &#x27;absolute&#x27;,
                        &#x27;width&#x27;: &#x27;20%&#x27;,
                        &#x27;height&#x27;: &#x27;auto&#x27;,
                        &#x27;left&#x27;: &#x27;75%&#x27;,
                        &#x27;bottom&#x27;: &#x27;5%&#x27;,
                        &#x27;z-index&#x27;: 2
                    });
                    typeIndicatorImage.removeAttr(&#x27;width&#x27;);
                    typeIndicatorImage.removeAttr(&#x27;height&#x27;);
                    imgHolderDiv.append(typeIndicatorImage);
                }

                // create the text to show in the media holder
                var compHolderText = $(document.createElement(&#x27;div&#x27;));
                compHolderText.addClass(&#x27;compHolderText&#x27;);
                //trims off long names
                var name = comp.Name;
                //if (comp.Name.length &gt; 24) { // we should do this in a more flexible way.... TODO JL
                //    name = comp.Name.slice(0, 24) + &quot;...&quot;;
                //} else {
                //    name = comp.Name;
                //}

                compHolderText.text(name);
                compHolderText.css({
                    &#x27;padding-left&#x27;: &#x27;3%&#x27;,
                    &#x27;font-size&#x27;: &#x27;70%&#x27;,
                    //&#x27;margin&#x27; :&#x27;0% 2% 0% 2%&#x27;,
                    &#x27;overflow&#x27;: &#x27;hidden&#x27;,
                    //&#x27;overflow-y&#x27;: &#x27;visible&#x27;,
                    &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;,
                    &#x27;white-space&#x27;: &#x27;nowrap&#x27;,
                    &#x27;height&#x27;: &#x27;22%&#x27;
                });
                compHolder.append(compHolderText);
                applyClick(compHolder); // binds handlers
            }
        }

        //single clicking on associated media selects it, to be imported
        function compSingleClick(e, compHolder) {
            var guid = compHolder.data(&#x27;guid&#x27;),
                index = origComps.indexOf(guid),
                addedIndex;
                
            if (compHolder.data(&quot;selected&quot;)) {
                compHolder.data(&quot;selected&quot;, false);
                compHolder.css(&#x27;background&#x27;, &#x27;#222&#x27;);
                if(index &gt;= 0) {
                    removedComps.push(guid)
                } else {
                    addedIndex = addedComps.indexOf(guid);
                    addedComps.splice(addedIndex, 1);
                    addedCompsObjs.splice(addedIndex, 1);
                }
            }
            else {
                compHolder.data(&quot;selected&quot;, true);
                compHolder.css(&#x27;background&#x27;, &#x27;#999&#x27;);
                if (index &gt;= 0) {
                    removedComps.remove(guid);
                } else {
                    addedComps.push(guid);
                    addedCompsObjs.push(compHolder.data(&#x27;comp&#x27;));
                }
            }
            //console.log(&quot;added length = &quot; + addedComps.length);
            //console.log(&quot;remove length = &quot; + removedComps.length);
            //console.log(&quot;orig length = &quot; + origComps.length + &quot;\n&quot;);
        }

        // double clicking on associated media will import all selected media
        function compDoubleClick(evt, compHolder) {
            var guid = compHolder.data(&#x27;guid&#x27;),
                index = origComps.indexOf(guid);
            compHolder.css(&#x27;background&#x27;, &#x27;#999&#x27;);
            if (compHolder.data(&#x27;selected&#x27;) !== true) {
                if (index &gt;= 0) {
                    removedComps.remove(guid)
                } else {
                    addedComps.push(guid);
                    addedCompsObjs.push(compHolder.data(&#x27;comp&#x27;));
                }
                compHolder.data(&quot;selected&quot;, true);
            }
            finalizeAssociations();
        }

        //this handles discriminating between the double and single clicks for importing media
        //cleans up bugs where both click events were firing and media would import twice
        function compSingleDoubleClick(compHolder) {
            compHolder.click(function (evt) {
                var that = this;
                setTimeout(function () {
                    var dblclick = parseInt($(that).data(&#x27;double&#x27;), 10);
                    if (dblclick &gt; 0) {
                        $(that).data(&#x27;double&#x27;, dblclick - 1);
                    } else {
                        compSingleClick.call(that, evt, compHolder);
                    }
                }, 300);
            });
            //.dblclick(function (evt) {
            //    $(this).data(&#x27;double&#x27;, 2);
            //    compDoubleClick.call(this, evt, compHolder);
            //});
        }

        // adds media as an associated media of each artwork in artworks
        function finalizeAssociations() {
            var options = {};

            // only update recentlyAssociated if the target is an artwork and we&#x27;re managing an artwork-media assoc
            if (type === &#x27;artwork&#x27; &amp;&amp; target.type === &#x27;artwork&#x27;) {
                for (var i = 0; i &lt; addedComps.length; i++) {
                    if (recentlyAssociatedGUIDs.indexOf(addedComps[i]) &lt; 0) {
                        recentlyAssociatedGUIDs.push(addedComps[i]);
                        recentlyAssociated.push(addedCompsObjs[i]);
                    }
                }
            }

            if (addedComps.length) {
                options.AddIDs = addedComps.join(&quot;,&quot;);
            }
            if (removedComps.length) {
                options.RemoveIDs = removedComps.join(&quot;,&quot;);
            }
            if (addedComps.length || removedComps.length) {
                if (type === &#x27;artwork&#x27; &amp;&amp; target.type === &#x27;artwork&#x27;) {
                    TAG.Worktop.Database.changeArtwork(target.comp.Identifier, options, function () { // SUCCESS HANDLER
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        // AUTH ERROR HANDLER
                        console.log(err.message);
                    }, function (err) {
                        // CONFLICT HANDLER
                        console.log(err.message);
                    }, function (err) {
                        // GENERAL ERROR HANDLER
                        console.log(err.message);
                    });
                } else if (type === &#x27;artwork&#x27; &amp;&amp; target.type === &#x27;media&#x27;) {
                    TAG.Worktop.Database.changeHotspot(target.comp.Identifier, options, function () { // TODO (Add/RemoveIDs for changeHotspot)
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    });
                } else if (type === &#x27;exhib&#x27; &amp;&amp; target.type === &#x27;exhib&#x27;) {
                    TAG.Worktop.Database.changeExhibition(target.comp.Identifier, options, function() {
                        callback();
                        pickerOverlay.fadeOut();
                        pickerOverlay.empty();
                        pickerOverlay.remove();
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    }, function (err) {
                        console.log(err.message);
                    });
                }
            } else {
                callback();
                pickerOverlay.fadeOut();
                pickerOverlay.empty();
                pickerOverlay.remove();
            }
        }
    }

    function getRecentlyAssociated(callback) {
        callback(recentlyAssociated);
    }


    //var containerCSS = { // css for an entire container
    //    &#x27;width&#x27;: &#x27;20%&#x27;,
    //    &#x27;float&#x27;: &#x27;left&#x27;,
    //    &#x27;text-align&#x27;: &#x27;center&#x27;
    //};

    //var thumbnailCSS = { // css for the thumbnail in a container
    //    &#x27;position&#x27;: &#x27;absolute&#x27;,
    //    &#x27;width&#x27;: &#x27;90%&#x27;, // height will be set dynamically to be square
    //    &#x27;left&#x27;: &#x27;5%&#x27;,
    //    &#x27;top&#x27;: &#x27;5%&#x27;
    //};

    //var metadataCSS = { // css for title/artist/year metadata div
    //    &#x27;position&#x27;: &#x27;absolute&#x27;,
    //    &#x27;width&#x27;: &#x27;90%&#x27;,
    //    &#x27;left&#x27;: &#x27;5%&#x27;,
    //    &#x27;top&#x27;: &#x27;2%&#x27;,
    //    &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;,
    //    &#x27;overflow&#x27;: &#x27;hidden&#x27;,
    //    &#x27;white-space&#x27;: &#x27;nowrap&#x27;
    //};

    //var progressCircCSS = { // css for entity loading circles
    //    &#x27;position&#x27;: &#x27;absolute&#x27;,
    //    &#x27;left&#x27;: &#x27;5%&#x27;,
    //    &#x27;z-index&#x27;: &#x27;50&#x27;,
    //    &#x27;height&#x27;: &#x27;auto&#x27;,
    //    &#x27;top&#x27;: &#x27;18%&#x27;,
    //    &#x27;width&#x27;: &#x27;10%&#x27;,
    //};

    //function setHeight($elt) {
    //    var w = $elt.width();
    //    $elt.css(&quot;height&quot;, w + &quot;px&quot;);
    //}

    ///**
    // * Creates a container for an entity, to be called by createAssociationPicker
    // * @param comp           object: component object from the server
    // * @param type           string: &#x27;exhib&#x27;, &#x27;artwork&#x27;, &#x27;media&#x27;
    // * @param onclick        handler: click handler for the container
    // * @param selected       boolean: is the container already selected
    // * @return               object: returns the container as a jquery object
    // */
    //function createHolderButton(comp, type, onclick, selected) {
    //    var container = $(document.createElement(&#x27;div&#x27;));
    //    container.addClass(&#x27;pickerButton&#x27;);
    //    container.css(containerCSS);
    //    var thumbnail = $(document.createElement(&#x27;img&#x27;));
    //    var metadataDiv = $(document.createElement(&#x27;div&#x27;));

    //    switch (type) {
    //        case &#x27;exhib&#x27;:
    //            break;
    //        case &#x27;artwork&#x27;:
    //            container.data({
    //                name: comp.Name,
    //                artist: comp.Metadata.Artist,
    //                year: comp.Metadata.Year,
    //                selected: selected
    //            });
    //            thumbnail.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail));
    //            metadataDiv.html(comp.Name + &#x27;&lt;br /&gt;&#x27; + comp.Metadata.Artist + &quot; (&quot; + comp.Metadata.Year + &quot;)&quot;);
    //            break;
    //        case &#x27;media&#x27;:
    //            container.data({
    //                name: comp.title,
    //                selected: selected
    //            });
    //            thumbnail.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(comp.source));
    //            metadataDiv.html(comp.title);
    //            break;
    //        default:
    //            break;
    //    }

    //    container.on(&#x27;mousedown&#x27;, function () {
    //        container.css({
    //            &#x27;background&#x27;: &#x27;white&#x27;,
    //        });
    //    });
    //    container.on(&#x27;mouseup&#x27;, function () {
    //        container.css({
    //            &#x27;background&#x27;: &#x27;transparent&#x27;,
    //        });
    //    });
    //    container.on(&#x27;mouseleave&#x27;, function () {
    //        container.css({
    //            &#x27;background&#x27;: &#x27;transparent&#x27;,
    //        });
    //    });
    //    container.on(&#x27;click&#x27;, function (evt) {
    //        evt.stopPropagation();
    //        container.data(&quot;selected&quot;, !container.data(&quot;selected&quot;));
    //    });

    //    thumbnail.css(thumbnailCSS);
    //    setHeight(thumbnail);
    //    container.append(thumbnail);

    //    var circle = TAG.Util.showProgressCircle(container, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
    //    image.load(function () {
    //        TAG.Util.removeProgressCircle(circle);
    //    });

    //    metadataDiv.css(metadataCSS);
    //    container.append(metadataDiv);

    //    return container;
    //}

    /**
     * Creates a dialog that displays a link to the current page (for use in web app only).
     * @method showPageLink
     * @param {String} baseurl         
     * @param {Object} params          URL params to include
     */
    function showPageLink(baseurl, params) {
        var overlay      = $(document.createElement(&#x27;div&#x27;)),
            container    = $(document.createElement(&#x27;div&#x27;)),
            linkLabel    = $(document.createElement(&#x27;label&#x27;)),
            linkInput    = $(document.createElement(&#x27;input&#x27;)),
            buttonRow    = $(document.createElement(&#x27;div&#x27;)),
            cancelButton = $(document.createElement(&#x27;button&#x27;)),
            tagContainer = $(&#x27;#tagRoot&#x27;),
            text         = baseurl.split(/#/)[0] + &#x27;#&#x27;,
            paramNum     = 0,
            key;

        params = params || {};

        overlay.attr(&#x27;id&#x27;, &#x27;linkDialogOverlay&#x27;);
        overlay.css({
            display: &#x27;none&#x27;,
            position: &#x27;absolute&#x27;,
            top: 0,
            left: 0,
            width: &#x27;100%&#x27;,
            height: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.6)&#x27;,
            &#x27;z-index&#x27;: 10000000,
        });

        container.addClass(&#x27;linkDialogContainer&#x27;);
        container.css({
            position: &#x27;absolute&#x27;,
            left: &#x27;20%&#x27;,
            top: &#x27;25%&#x27;,
            width: &#x27;62%&#x27;,
            border: &#x27;3px double white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
        });

        overlay.append(container);
        overlay.on(&#x27;click&#x27;, closeLinkOverlay);
        container.on(&#x27;click&#x27;, function(evt){
            evt.stopPropagation();
        });

        linkInput.addClass(&#x27;linkDialogInput&#x27;);
        linkInput.css({
            &#x27;border-color&#x27;: &#x27;gray&#x27;,
            &#x27;color&#x27;: &#x27;gray&#x27;,
            &#x27;font-size&#x27;: &#x27;1.3em&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;margin-top&#x27;: &#x27;20px&#x27;,
            &#x27;min-width&#x27;: 0,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;
        });

        for(key in params) {
            if(params.hasOwnProperty(key) &amp;&amp; (params[key] || params[key] === false)) {
                text += ((paramNum++) &gt; 0 ? &#x27;&amp;&#x27; : &#x27;&#x27;) + key + &#x27;=&#x27; + params[key];
            }
        }
        if(!params.tagserver) {
            text += ((paramNum++) &gt; 0 ? &#x27;&amp;&#x27; : &#x27;&#x27;) + &#x27;tagserver=&#x27; + localStorage.ip;
        }

        linkInput.attr({
            &#x27;value&#x27;:       text,
            &#x27;placeholder&#x27;: &#x27;No page link available&#x27;
        });

        buttonRow.css({
            &#x27;margin&#x27;: &#x27;20px 0px 20px 0px&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;width&#x27;: &#x27;80%&#x27;,
            &#x27;left&#x27;: &#x27;10%&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        });

        cancelButton.css({
            &#x27;padding&#x27;: &#x27;1%&#x27;,
            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;-2%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
        });
        cancelButton.text(&#x27;Close&#x27;);
        cancelButton.on(&#x27;click&#x27;, closeLinkOverlay);

        function closeLinkOverlay() {
            overlay.fadeOut(500, function() {
                overlay.remove();
            });
        }

        container.append(linkInput);
        
        container.append(buttonRow);
        buttonRow.append(cancelButton);

        return overlay;
    }

})();

/**
 * Some common functionality between the rich location editing and
 * viewing interfaces
 * @method LADS.Util.RLH
 * @param {Object} input           a couple input options
 *         {Doq}         artwork        artwork doq
 *         {jQuery obj}  root           root of current page
 *         {Boolean}     authoring      whether we&#x27;re in authoring mode
 */
TAG.Util.RLH = function (input) {
    var artwork = input.artwork, // artwork doq
        root = input.root,       // root of current page
        bingMapHelper,       // helper object for Bing map
        customMapHelper,     // helper object for custom maps
        richLocationData,    // object containing rich location data (e.g., 
        currentIndex,        // current map being shown
        mapGuids = [],       // list of map guids, including bing map, the first one is bing Map and null
        mapDoqs = {},        // dictionary of map doqs, not including bing map, keyed by map guid
        defaultMapShown,     // whether bing map is shown
        locations,           // list of locations
        mapHolders = {},     // dictionary of map holder divs, keyed by mapguid
        annotImgs = {},      // object of annotated images corresponding to custom map deepzoom images (keyed by map guid)
        map,                 // bing map
        disabledOverlay,     // overlay on default (bing) map holder if it&#x27;s disabled
        formIsEnabled,       // form is currently being displayed
        isEditForm,          // edit location form is open (as opposed to add location form)
        importingMap,        // used to show the correct map after importing 

        locationPanelDiv,    // outer container for whole location history UI
        locationPanel,       // holds content of location history UI

        topRegion,           // contains map name and dots
        metadataContainer,   // map name container div
        nameInput,           // input element for map name
        additionalInfoInput, // input element for additional map info (e.g., date)
        //mapDescriptionInput, // input element for a short map description
        saveMapButton,       // button for saving metadata changes to a map

        mapRegion,           // contains map, arrows
        leftArrowContainer,  // contains left arrow
        leftArrowButton,     // shows previous map if any
        mapContainer,        // map container div (contains all map holders)
        rightArrowContainer, // contains right arrow
        rightArrowButton,    // shows next map if any

        buttonsRegion,       // contains buttons
        addLocationButton,   // button for adding new location
        sortLocationsByTitleButton, // sorts the locations by title
        sortLocationsByDateButton, // sorts the locations by date
        dotsContainer,       // dots container div
        deleteButton,        // delete/hide/show map button
        importMapButton,     // import map button

        locationsRegion;     // contains location list

    if (!artwork || !root) {
        console.log(&quot;need to provide input.artwork and input.root&quot;);
        return;
    }

    return {
        init: init
    };

    /**
     * Initializes rich location history editing (called only once). Grabs
     * artwork.Metadata.RichLocationHistory (or converts old artwork.Metadata.Location
     * object to new format), builds UI, and shows the first map.
     * @method init
     */
    function init() {
        // get data and initialize maps and locations
        richLocationData = artwork.Metadata.RichLocationHistory ? JSON.parse(artwork.Metadata.RichLocationHistory) : locationToRichLocation(artwork.Metadata.Location);
        locations = richLocationData.locations || [];
        defaultMapShown = richLocationData.defaultMapShown;
        currentIndex = 0;
        bingMapHelper = BingMapHelper();
        customMapHelper = CustomMapHelper();
        importingMap = false;
        isEditForm = false;

        // initialize UI (most of this should be done in JADE/STYL in web app)
        locationPanelDiv = $(document.createElement(&#x27;div&#x27;))
                        .attr(&#x27;id&#x27;, &#x27;locationHistoryOuterContainer&#x27;)
                        .css({
                            position: &#x27;absolute&#x27;,
                            top: &#x27;12%&#x27;,
                            left: input.authoring?&#x27;20%&#x27;:&#x27;22%&#x27;,
                            width: &#x27;70%&#x27;,
                            height: &#x27;80%&#x27;,
                            display: &#x27;none&#x27;,
                            &#x27;z-index&#x27;: &#x27;51&#x27;
                        })
                        .appendTo(root);

        locationPanel = $(document.createElement(&#x27;div&#x27;))
                        .attr(&#x27;id&#x27;, &#x27;locationHistoryContainer&#x27;)
                        .css({
                            display:&#x27;inline-block&#x27;,
                            position: &#x27;relative&#x27;,
                            width: &#x27;100%&#x27;,
                            height: &#x27;100%&#x27;,
                            top: &#x27;0%&#x27;,
                            left: &#x27;0%&#x27;,
                            &#x27;z-indez&#x27;: 99,
                            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.75)&#x27;
                        })
                        .appendTo(locationPanelDiv);

        topRegion = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryTopRegion&#x27;)
                    .css({
                        position: &#x27;relative&#x27;,
                        width: &#x27;100%&#x27;,
                        height: &#x27;7%&#x27;,
                        &#x27;font-size&#x27;: &#x27;.5em&#x27;
                    })
                    .appendTo(locationPanel);

        metadataContainer = $(document.createElement(&#x27;div&#x27;))
                        .attr(&#x27;id&#x27;, &#x27;locationHistoryMetadataContainer&#x27;)
                        .css({
                            position: &#x27;absolute&#x27;,
                            &#x27;width&#x27;: &#x27;80%&#x27;,
                            &#x27;height&#x27;: &#x27;90%&#x27;,
                            &#x27;top&#x27;: &#x27;5%&#x27;,
                            &#x27;left&#x27;: &#x27;10%&#x27;
                        })
                        .appendTo(topRegion);

        if (input.authoring) {
            nameInput = $(document.createElement(&#x27;input&#x27;))
                    .attr({
                        id: &#x27;locationHistoryNameInput&#x27;,
                        placeholder: &#x27;Map name&#x27;
                    })
                    .css({
                        position: &#x27;relative&#x27;,
                        width: &#x27;35%&#x27;,
                        height: &#x27;52%&#x27;,
                        top: &#x27;8px&#x27;
                    })
                    .appendTo(metadataContainer);

            additionalInfoInput = $(document.createElement(&#x27;input&#x27;))
                        .attr({
                            id: &#x27;locationHistoryAdditionalInfoInput&#x27;,
                            placeholder: &#x27;Date&#x27;
                        })
                        .css({
                            position: &#x27;relative&#x27;,
                            &#x27;margin-left&#x27;: &#x27;10px&#x27;,
                            width: &#x27;20%&#x27;,
                            height: &#x27;52%&#x27;,
                            top: &#x27;8px&#x27;
                        })
                        .appendTo(metadataContainer);

            saveMapButton = $(document.createElement(&#x27;button&#x27;))
                            .attr({
                                id: &#x27;locationHistorySaveMapButton&#x27;,
                                type: &#x27;button&#x27;
                            })
                            .css({
                                position: &#x27;relative&#x27;,
                                &#x27;margin-left&#x27;: &#x27;10px&#x27;,
                                top: &#x27;8px&#x27;
                            })
                            .text(&#x27;Save&#x27;)
                            .appendTo(metadataContainer);
            saveMapButton.on(&#x27;click&#x27;, saveCurrentMapMetadata);
        } else {
            nameInput = $(document.createElement(&#x27;div&#x27;))
                    .attr({
                        id: &#x27;locationHistoryNameHolder&#x27;
                    })
                    .css({
                        &#x27;font-size&#x27;: &#x27;2.5em&#x27;,
                        position: &#x27;absolute&#x27;,
                        top: &#x27;15%&#x27;,
                        height: &#x27;90%&#x27;
                    })
                    .appendTo(metadataContainer);

            additionalInfoInput = $(document.createElement(&#x27;div&#x27;))
                        .attr({
                            id: &#x27;locationHistoryAdditionalInfoHolder&#x27;
                        })
                        .css({
                            &#x27;font-size&#x27;: &#x27;2.5em&#x27;,
                            position: &#x27;absolute&#x27;,
                            top: &#x27;0%&#x27;,
                            right: &#x27;0%&#x27;,
                            height: &#x27;90%&#x27;
                        })
                        .appendTo(metadataContainer);
        }

        mapRegion = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryMapRegion&#x27;)
                    .css({
                        position: &#x27;relative&#x27;,
                        width: &#x27;100%&#x27;,
                        height: &#x27;50%&#x27;
                    })
                    .appendTo(locationPanel);

        leftArrowContainer = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryLeftArrowContainer&#x27;)
                    .css({
                        position: &#x27;absolute&#x27;,
                        width: &#x27;10%&#x27;,
                        height: &#x27;100%&#x27;
                    })
                    .appendTo(mapRegion);

        leftArrowButton = $(document.createElement(&#x27;img&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryLeftArrowButton&#x27;)
                    .attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/Left.png&#x27;)
                    .css({
                        position: &#x27;absolute&#x27;,
                        width: &#x27;13px&#x27;,
                        height: &#x27;auto&#x27;,
                        right: &#x27;10%&#x27;,
                        top: &#x27;50%&#x27;,
                        cursor: &#x27;pointer&#x27;
                    })
                    .appendTo(leftArrowContainer)

        mapContainer = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryMapContainer&#x27;)
                    .css({
                        top:&#x27;2%&#x27;,
                        position: &#x27;absolute&#x27;,
                        width: &#x27;80%&#x27;,
                        height: &#x27;100%&#x27;,
                        left: &#x27;10%&#x27;
                    })
                    .appendTo(mapRegion);

        rightArrowContainer = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryRightArrowContainer&#x27;)
                    .css({
                        position: &#x27;absolute&#x27;,
                        width: &#x27;10%&#x27;,
                        height: &#x27;100%&#x27;,
                        left: &#x27;90%&#x27;
                    })
                    .appendTo(mapRegion);

        rightArrowButton = $(document.createElement(&#x27;img&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryRightArrowButton&#x27;)
                    .attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/Right.png&#x27;)
                    .css({
                        position: &#x27;absolute&#x27;,
                        width: &#x27;13px&#x27;,
                        height: &#x27;auto&#x27;,
                        left: &#x27;10%&#x27;,
                        top: &#x27;50%&#x27;,
                        cursor: &#x27;pointer&#x27;
                    })
                    .appendTo(rightArrowContainer)

        disabledOverlay = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;defaultMapDisabledOverlay&#x27;)
                    .css({
                        &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.85)&#x27;,
                        &#x27;color&#x27;: &#x27;white&#x27;,
                        &#x27;font-size&#x27;: &#x27;20px&#x27;,
                        &#x27;height&#x27;: &#x27;100%&#x27;,
                        &#x27;position&#x27;: &#x27;absolute&#x27;,
                        &#x27;text-align&#x27;: &#x27;center&#x27;,
                        &#x27;top&#x27;: &#x27;0%&#x27;,
                        &#x27;width&#x27;: &#x27;100%&#x27;
                    })
                    .text(&#x27;Bing map is disabled.&#x27;);

        buttonsRegion = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryButtonsRegion&#x27;)
                    .css({
                        position: &#x27;relative&#x27;,
                        left: &#x27;10%&#x27;,
                        width: &#x27;80%&#x27;,
                        top: &#x27;3%&#x27;,
                        height: &#x27;6%&#x27;,
                        &#x27;margin-bottom&#x27;: &#x27;1%&#x27;
                    })
                    .appendTo(locationPanel);
        if (input.authoring) {
            addLocationButton = $(document.createElement(&#x27;button&#x27;))
                        .attr({
                            &#x27;id&#x27;: &#x27;locationHistoryAddLocationButton&#x27;,
                            &#x27;type&#x27;: &#x27;button&#x27;
                        })
                        .css({
                            position: &#x27;relative&#x27;,
                            float: &#x27;left&#x27;
                        })
                        .appendTo(buttonsRegion)
                        .text(&#x27;Add Location&#x27;);
            sortLocationsByTitleButton = $(document.createElement(&#x27;button&#x27;))
                        .attr({
                            &#x27;id&#x27;: &#x27;locationHistorySortLocationsButton&#x27;,
                            &#x27;type&#x27;: &#x27;button&#x27;
                        })
                        .css({
                            position: &#x27;relative&#x27;,
                            &#x27;margin-left&#x27;: &#x27;10px&#x27;,
                            float: &#x27;left&#x27;
                        })
                        .appendTo(buttonsRegion)
                        .text(&#x27;Sort By Title&#x27;);
            sortLocationsByDateButton = $(document.createElement(&#x27;button&#x27;))
                        .attr({
                            &#x27;id&#x27;: &#x27;locationHistorySortLocationsButton&#x27;,
                            &#x27;type&#x27;: &#x27;button&#x27;
                        })
                        .css({
                            position: &#x27;relative&#x27;,
                            &#x27;margin-left&#x27;: &#x27;10px&#x27;,
                            float: &#x27;left&#x27;
                        })
                        .appendTo(buttonsRegion)
                        .text(&#x27;Sort By Date&#x27;);

            importMapButton = $(document.createElement(&#x27;button&#x27;))
                    .attr({
                        &#x27;id&#x27;: &#x27;locationHistoryImportMapButton&#x27;,
                        &#x27;type&#x27;: &#x27;button&#x27;
                    })
                    .css({
                        position: &#x27;relative&#x27;,
                        float: &#x27;right&#x27;
                    })
                    .appendTo(buttonsRegion)
                    .text(&#x27;Import Map&#x27;);

            deleteButton = $(document.createElement(&#x27;button&#x27;))
                        .attr({
                            &#x27;id&#x27;: &#x27;locationHistoryDeleteButton&#x27;,
                            &#x27;type&#x27;: &#x27;button&#x27;
                        })
                        .css({
                            position: &#x27;relative&#x27;,
                            &#x27;margin-right&#x27;: &#x27;10px&#x27;,
                            float: &#x27;right&#x27;
                        })
                        .appendTo(buttonsRegion);

            dotsContainer = $(document.createElement(&#x27;div&#x27;))
                            .attr(&#x27;id&#x27;, &#x27;locationHistoryDotsContainer&#x27;)
                            .css({
                                &#x27;margin-left&#x27;: &#x27;auto&#x27;,
                                &#x27;margin-right&#x27;: &#x27;auto&#x27;,
                                &#x27;width&#x27;: &#x27;30%&#x27;,
                                &#x27;height&#x27;: &#x27;50%&#x27;,
                                &#x27;top&#x27;: &#x27;0%&#x27;,
                                &#x27;text-align&#x27;: &#x27;center&#x27;
                            })
                            .appendTo(buttonsRegion);

            importMapButton.on(&#x27;click&#x27;, importMap);
            deleteButton.on(&#x27;click&#x27;, function (evt) {
                var mapName = function () {
                    if (mapGuids[currentIndex]) {
                        if (mapDoqs[mapGuids[currentIndex]].Name.length &gt; 20) {
                            return &quot;&#x27;&quot; + mapDoqs[mapGuids[currentIndex]].Name.substring(0, 20) + &#x27;...&#x27; + &quot;&#x27;&quot;;
                        } else {
                            return &quot;&#x27;&quot; + mapDoqs[mapGuids[currentIndex]].Name + &quot;&#x27;&quot;;
                        }
                    } else {
                        return &#x27;Custom Map&#x27;;
                    }
                }();
                if (!(currentIndex === 0)) { //if it&#x27;s not the bing map being displayed, confirm the deletion
                    var overlay = LADS.Util.UI.PopUpConfirmation(function () {
                        deleteMap();
                    }, &quot;Are you sure you want to delete &quot; + mapName + &quot; and all locations associated with it?&quot;, &quot;Yes&quot;);
                    root.append(overlay);
                    $(overlay).show();
                    evt.stopPropagation();
                } else {
                    deleteMap(); //hides bing map
                };
            });
            addLocationButton.on(&#x27;click&#x27;, addLocation);
            sortLocationsByTitleButton.on(&#x27;click&#x27;, sortLocationsByTitle);
            sortLocationsByDateButton.on(&#x27;click&#x27;, sortLocationsByDate);
        } else {
            dotsContainer = $(document.createElement(&#x27;div&#x27;))
                            .attr(&#x27;id&#x27;, &#x27;locationHistoryDotsContainer&#x27;)
                            .css({
                                position: &#x27;absolute&#x27;,
                                &#x27;width&#x27;: &#x27;40%&#x27;,
                                &#x27;height&#x27;: &#x27;50%&#x27;,
                                &#x27;top&#x27;: &#x27;0%&#x27;,
                                &#x27;left&#x27;: &#x27;30%&#x27;,
                                &#x27;text-align&#x27;: &#x27;center&#x27;
                            })
                            .appendTo(buttonsRegion);
        }

        locationsRegion = $(document.createElement(&#x27;div&#x27;))
                    .attr(&#x27;id&#x27;, &#x27;locationHistoryLocationsRegion&#x27;)
                    .css({
                        top:&#x27;1%&#x27;,
                        position: &#x27;relative&#x27;,
                        width: &#x27;80%&#x27;,
                        left: &#x27;10%&#x27;,
                        height: &#x27;32%&#x27;,
                        color: &#x27;white&#x27;,
                        &#x27;font-size&#x27;: &#x27;11&#x27;,
                        &#x27;font-weight&#x27;: &#x27;300&#x27;,
                        &#x27;overflow-y&#x27;: &#x27;auto&#x27;,
                        &#x27;overflow-x&#x27;: &#x27;hidden&#x27;
                    })
                    .appendTo(locationPanel)
                    .text(&quot;No locations to display...&quot;);

        // set up click handlers, etc
        leftArrowButton.on(&#x27;click&#x27;, function () {
            if (currentIndex - 1 &gt;= 0) {
                showMap(mapGuids[--currentIndex]);
            } else {
                currentIndex = mapGuids.length - 1;
                showMap(mapGuids[currentIndex]);
            }
        });

        rightArrowButton.on(&#x27;click&#x27;, function () {
            if (currentIndex + 1 &lt; mapGuids.length) {
                showMap(mapGuids[++currentIndex]);
            } else {
                currentIndex = 0;
                showMap(mapGuids[0]);
            }
        });

        // load in the first map in the list
        getMaps();

        return locationPanelDiv;
    }

    /**
    *Hides the Map Name field, Additional Input (date) field, and save button in the metadata container
    *Called when the Bing Map is being displayed, displays the name &#x27;Bing Map&#x27;
    *@method hideMetadataEditingFields
    */
    function hideMetadataEditingFields() {
        nameInput.css({ visibility: &#x27;hidden&#x27; });
        additionalInfoInput.css({ visibility: &#x27;hidden&#x27; });
        saveMapButton &amp;&amp; saveMapButton.css({ visibility: &#x27;hidden&#x27; });
        $(document.createElement(&#x27;div&#x27;))
            .attr({
                id: &#x27;bingMapNameHolder&#x27;
            })
            .css({
                &#x27;font-size&#x27;: &#x27;40px&#x27;,
                &#x27;vertical-align&#x27;:&#x27;middle&#x27;,
                position: &#x27;absolute&#x27;,
                top: &#x27;15%&#x27;,
                height: &#x27;90%&#x27;,
                &#x27;z-index&#x27;: &#x27;50&#x27;,
                color: &#x27;white&#x27;
            })
            .text(&#x27;Bing Map&#x27;)
            .appendTo(metadataContainer);
    }

    /**
    *Shows the Map Name field, Additional Input (date) field, and save button in the metadata container
    *Reverses the above function, called when any map besides the bing map is displayed
    *@method showMetadataEditingFields
    */
    function showMetadataEditingFields() {
        $(&#x27;#bingMapNameHolder&#x27;).remove();
        nameInput.css({ visibility: &#x27;visible&#x27; });
        additionalInfoInput.css({ visibility: &#x27;visible&#x27; });
        saveMapButton &amp;&amp; saveMapButton.css({ visibility: &#x27;visible&#x27; });
    }

    /**
     * Get all the maps for the artwork
     * @method getMaps
     * @param {Function} callback      function to call when maps have been obtained and loaded
     */
    function getMaps(callback) {
        callback = callback || function () {
            if (!importingMap) { //don&#x27;t display the first map if an import has just occured
                try {
                    showMap(mapGuids[currentIndex]);
                } catch (e) {
                    showMap(mapGuids[0]);
                }
            } else { //display the last one instead
                importingMap = false;
                showMap(mapGuids[mapGuids.length - 1]);
            }
        };
        mapGuids = (defaultMapShown || input.authoring) ? [null] : [];
        LADS.Worktop.Database.getMaps(artwork.Identifier, function (mps) {
            var mapslength = mps.length;
            if (mapslength &gt; 0) {
                for (var i = 0; i &lt; mapslength; i++) {
                    mapDoqs[mps[i].Identifier] = mps[i];
                    mapGuids.push(mps[i].Identifier);
                }
            }
            loadMaps(callback);
            createDots();
        }, function () {
            loadMaps(callback);
            createDots();
        }, function () {
            loadMaps(callback);
            createDots();
        });
    }

    /**
     * Loads all maps by creating holders for them within the mapContainer div.
     * @method loadMaps
     * @param {Function} callback      function to call when loading is complete
     */
    function loadMaps(callback) {
        var i,
            holder,
            m,
            img,
            progress = { // allows init functions to keep track of how many maps have loaded (call callback after all have loaded)
                total: mapGuids.length,
                done: 0
            },
            helper,
            loadCallback;

        mapHolders = {};
        mapContainer.empty(); // TODO this is inefficient, just here for rapid prototyping

        loadCallback = function () {
            callback &amp;&amp; callback();
            createLocationList();
        };

        for (i = 0; i &lt; mapGuids.length; i++) {
            holder = $(document.createElement(&#x27;div&#x27;))
                        .addClass(&#x27;locationHistoryMapHolder&#x27;)
                        .css({
                            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.8)&#x27;,
                            &#x27;border&#x27;: &#x27;1px solid white&#x27;,
                            position: &#x27;absolute&#x27;,
                            width: &#x27;100%&#x27;,
                            height: &#x27;100%&#x27;,
                            left: &#x27;0%&#x27;,
                            top: &#x27;0%&#x27;,
                            &#x27;text-align&#x27;: &#x27;center&#x27;,
                            display: &#x27;none&#x27;
                        })
                        .appendTo(mapContainer);
            mapHolders[mapGuids[i]] = holder;
            helper = mapGuids[i] ? customMapHelper : bingMapHelper;
            helper.init({
                container: holder,
                mapdoq: mapDoqs[mapGuids[i]],
                progress: progress,
                loadCallback: loadCallback
            });
        }
    }

    /**
     * Saves any metadata changes to the current map
     * @method saveCurrentMapMetadata
     */
    function saveCurrentMapMetadata() {
        var progressCSS = {
            &#x27;left&#x27;: &#x27;65%&#x27;,
            &#x27;top&#x27;: &#x27;10px&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;height&#x27;: &#x27;50%&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;z-index&#x27;: 50,
            &#x27;display&#x27;: &#x27;inline-block&#x27;
        };
        var progCirc = LADS.Util.showProgressCircle(topRegion, progressCSS);

        var index = currentIndex;
        if (mapGuids[index]) {
            LADS.Worktop.Database.changeMap(mapDoqs[mapGuids[index]], {
                Name: nameInput.val() || &#x27;Custom Map&#x27;,
                AdditionalInfo: additionalInfoInput.val(),
                //Description: mapDescriptionInput.val()
            }, function () {
                var mapName = function () {
                    if (nameInput.val()) {
                        if (nameInput.val().length &gt; 20) {
                            return &quot;&#x27;&quot; + nameInput.val().substring(0, 20) + &#x27;...&#x27; + &quot;&#x27;&quot;;
                        } else {
                            return &quot;&#x27;&quot; + nameInput.val() + &quot;&#x27;&quot;;
                        }
                    } else {
                        return &quot;&#x27;Custom Map&#x27;&quot;;
                    }
                }();
                deleteButton &amp;&amp; deleteButton.text(&#x27;Delete &#x27; + mapName);
                LADS.Util.removeProgressCircle(progCirc);
                LADS.Worktop.Database.getDoq(mapDoqs[mapGuids[index]].Identifier, function (newMap) {
                    mapDoqs[mapGuids[index]] = newMap;
                });
            }, LADS.Util.UI.errorContactingServerPopup, function () {
                LADS.Util.removeProgressCircle(progCirc);
                LADS.Worktop.Database.getDoq(mapDoqs[mapGuids[index]].Identifier, function (newMap) {
                    mapDoqs[mapGuids[index]] = newMap;
                });
            });
        }
    }

    /**
     * Helper function to iterate through location list and call a
     * helper function for each.
     * @method iterateThroughLocations
     * @param {Function} toCall       helper method to call for each map; by
     *                                default, called with two params (loc and mapdoq)
     */
    function iterateThroughLocations(toCall) {
        var i,
            helper;

        for (i = 0; i &lt; locations.length; i++) {
            if (!locations[i].map &amp;&amp; !defaultMapShown &amp;&amp; !input.authoring) {
                continue;
            }
            helper = locations[i].map ? customMapHelper : bingMapHelper;
            if (!locations[i].map || mapDoqs[locations[i].map]) { // make sure the custom map exists
                helper[toCall](locations[i], mapDoqs[locations[i].map]);
            }
        }
    }

    /**
     * Create list of locations in the bottom panel
     * @method createLocationList
     */
    function createLocationList() {
        locationsRegion.empty();
        iterateThroughLocations(&quot;createLocationItem&quot;);
    }

    /**
     * Shows the specified map holder, sets currentIndex, and deals with dot colors
     * @method showMap
     * @param {String} guid        key into mapHolders
     */
    function showMap(guid) {
        var i;

        showMetadataEditingFields(); //by default; hideMetadataEditingFields() is called later for bing map
        currentIndex = mapGuids.indexOf(guid);

        // style map dots
        $(&#x27;.locationHistoryMapDot&#x27;).css(&#x27;background-color&#x27;, &#x27;black&#x27;); //resets all dots to the unselected state
        $(&#x27;#dot-&#x27; + guid).css(&#x27;background-color&#x27;, &#x27;white&#x27;); //selects the correct dot

        // show the correct map holder
        $(&#x27;.locationHistoryMapHolder&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;);
        mapHolders[guid].css(&#x27;display&#x27;, &#x27;block&#x27;);

        // add correct content to name and additional info fields
        if (input.authoring &amp;&amp; mapDoqs[guid]) {
            nameInput.attr(&#x27;value&#x27;, mapDoqs[guid].Name || &#x27;&#x27;);
            additionalInfoInput.attr(&#x27;value&#x27;, mapDoqs[guid].Metadata.AdditionalInfo || &#x27;&#x27;);
        } else {
            nameInput.text(mapDoqs[guid] ? (mapDoqs[guid].Name || &#x27;Custom Map&#x27;) : &#x27;Bing Map&#x27;);
            additionalInfoInput.text(mapDoqs[guid] ? (mapDoqs[guid].Metadata.AdditionalInfo || &#x27;&#x27;) : &#x27;&#x27;);
        }

        // deal with additional Bing map styling
        if (!guid) {
            hideMetadataEditingFields(); //hide fields for the bing map
            if (!defaultMapShown) {
                mapHolders[null].append(disabledOverlay);
                deleteButton &amp;&amp; deleteButton.text(&#x27;Show Bing Map&#x27;);
            } else {
                deleteButton &amp;&amp; deleteButton.text(&#x27;Hide Bing Map&#x27;);
            }
        } else {
            var mapName = function () {
                if (mapDoqs[guid].Name) {
                    if (mapDoqs[guid].Name.length &gt; 20) {
                        return &quot;&#x27;&quot; + mapDoqs[guid].Name.substring(0, 20) + &#x27;...&#x27; + &quot;&#x27;&quot;;
                    } else {
                        return &quot;&#x27;&quot; + mapDoqs[guid].Name + &quot;&#x27;&quot;;
                    }
                } else {
                    return &#x27;Custom Map&#x27;;
                }
            }();
            deleteButton &amp;&amp; deleteButton.text(&#x27;Delete &#x27; + mapName);
        }
    }

    /**
     * Shows a message in the bottom region indicating that saving/loading is
     * underway.
     * @method showLoadingMessage
     * @param {String} message            an optional custom message
     */
    function showLoadingMessage(message) {
        var messageDiv = $(document.createElement(&#x27;div&#x27;));

        messageDiv.css({
            color: &#x27;white&#x27;,
            &#x27;font-size&#x27;: &#x27;20px&#x27;,
            position: &#x27;relative&#x27;,
            &#x27;text-align&#x27;: &#x27;center&#x27;,
            width: &#x27;100%&#x27;
        });
        messageDiv.text(message || &#x27;Loading...&#x27;);
        var progressCSS = {
            &#x27;left&#x27;: &#x27;5%&#x27;,
            &#x27;top&#x27;: &#x27;15px&#x27;,
            &#x27;width&#x27;: &#x27;40px&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;z-index&#x27;: 50
        };
        var progCirc = LADS.Util.showProgressCircle(messageDiv, progressCSS);

        locationsRegion.empty();
        locationsRegion.append(messageDiv);
    }

    /**
     * Creates map dots (below the map)
     * @method createDots
     */
    function createDots() {
        var i,
            dot;
        dotsContainer.empty();
        for (i = 0; i &lt; mapGuids.length; i++) {
            dot = $(document.createElement(&#x27;div&#x27;))
                    .addClass(&#x27;locationHistoryMapDot&#x27;)
                    .attr(&#x27;id&#x27;, &#x27;dot-&#x27; + mapGuids[i])
                    .css({
                        display: &#x27;inline-block&#x27;,
                        cursor: &#x27;pointer&#x27;,
                        &#x27;background-color&#x27;: &#x27;white&#x27;,
                        &#x27;border&#x27;: &#x27;3px solid white&#x27;,
                        &#x27;border-radius&#x27;: &#x27;20px&#x27;,
                        &#x27;border-color&#x27;: &#x27;white&#x27;,
                        width: &#x27;8px&#x27;,
                        height: &#x27;8px&#x27;,
                        &#x27;margin-left&#x27;: &#x27;5px&#x27;,
                    })
                    .appendTo(dotsContainer);
            dot.on(&#x27;click&#x27;, dotClickHelper(i));
        }
    }

    /**
     * Click handler helper for map dots (just calls showMap)
     * @method dotClickHelper
     * @param {Number} i             the index of the dot clicked
     * @return {Function}            a click handler for a map dot
     */
    function dotClickHelper(i) {
        return function () {
            currentIndex = i;
            showMap(mapGuids[i]);
        }
    }

    /**
     * Click function for addLocation Button. create a pin on the map and create
     * a location editing form.  Only one form can be displayed at a time.
     * @method addLocation
     */
    function addLocation() {
        if (!formIsEnabled) {
            formIsEnabled = true;
            var mapguid = mapGuids[currentIndex],
                helper = mapguid ? customMapHelper : bingMapHelper,
                editingFormElements = helper.createLocationEditor();

            locationsRegion.append(editingFormElements.container);
            locationsRegion.scrollTop(0);
            locationsRegion.scrollTop(editingFormElements.container.position().top+20);
        }
    }

    /**
     * Function to remove the add location form when the cancel button is clicked.
     * @method removeLocationForm
     */
    function removeLocationForm() {
        formIsEnabled = false;
        $(&#x27;.locationEditingContainer&#x27;).remove();
    }

    /**
     * Function to sort the locations in the list by title when the sort button is clicked.
     * @method sortLocations
     */
    function sortLocationsByTitle() {
        if (!formIsEnabled) {

            //sort
            locations.sort(function (a, b) {
                return (a.title.toLowerCase() &lt; b.title.toLowerCase()) ? -1 : 1;
            });

            //re-creates list (for now)
            createLocationList();

            //save
            LADS.Worktop.Database.changeArtwork(artwork.Identifier, { RichLocationHistory: generateRichLocationData() }, success, error, error, error);
            function success() { }
            function error() { console.log(&#x27;An error occured while saving.&#x27;); }
        }
    }

    /**
     * Function to sort the locations in the list by title when the sort button is clicked.
     * @method sortLocations
     */
    function sortLocationsByDate() {
        if (!formIsEnabled) {

            //sort
            locations.sort(function (a, b) {
                return (a.date &lt; b.date) ? -1 : 1;
            });

            //re-creates list (for now)
            createLocationList();

            //save
            LADS.Worktop.Database.changeArtwork(artwork.Identifier, { RichLocationHistory: generateRichLocationData() }, success, error, error, error);
            function success() { }
            function error() { console.log(&#x27;An error occured while saving.&#x27;); }

        }
    }

    /**
     * For backwards compatibility, translates an artwork.Location property to an
     * artwork.RichLocationHistory property
     * @method locationToRichLocation
     * @param {String} locationData           old location data to transform
     * @return {Object}                       properly formatted rich location data
     */
    function locationToRichLocation(locationData) {
        var parsedData = (typeof (locationData) === &quot;string&quot;) ? JSON.parse(locationData) : locationData,
            locs = [],
            loc,
            i;

        for (i = 0; i &lt; parsedData.length; i++) {
            loc = parsedData[i];
            locs.push({
                map: null,
                latitude: (loc.resource &amp;&amp; loc.resource.point &amp;&amp; loc.resource.point.coordinates &amp;&amp; loc.resource.point.coordinates[0]) ? loc.resource.point.coordinates[0] : 0,
                longitude: (loc.resource &amp;&amp; loc.resource.point &amp;&amp; loc.resource.point.coordinates &amp;&amp; loc.resource.point.coordinates[1]) ? loc.resource.point.coordinates[1] : 0,
                title: loc.address || &#x27;&#x27;,
                date: (loc.date === &quot;string&quot;) ? loc.date : &#x27;&#x27;, // TODO maybe do some parsing here
                description: loc.info || &#x27;&#x27;
            });
        }

        return {
            defaultMapShown: true,
            locations: locs
        };
    }

    /**
     * Some helper functions for the Bing map. The idea is to have BingMapHelper
     * and CustomMapHelper implement the same interface, so manipulating location data can
     * be generic
     * @method BingMapHelper
     */
    function BingMapHelper() {
        var pushpin,
            credentials = &quot;AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj&quot;; // bing maps credentials

        /**
         * Makes the map, creates pushpin, etc
         * @method init
         * @method {Object} input        some input options
         *             container:        container of the bing map
         *             progress:         an object allowing us to keep track of how many of all maps have loaded 
         *             loadCallback:     callback function to call if this is the last map to load
         */
        function init(input) {

            // load bing map
            Microsoft.Maps.loadModule(&#x27;Microsoft.Maps.Map&#x27;, {
                callback: initMap
            });

            /**
             * Callback function to initiailize bing map
             * @method initMap
             */
            function initMap() {
                var mapOptions = {
                    credentials: credentials,
                    mapTypeID: Microsoft.Maps.MapTypeId.road,
                    showScalebar: true,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    showDashboard: false,
                    showMapTypeSelector: false,
                    zoom: 2,
                    center: new Microsoft.Maps.Location(20, 0)
                };

                map = new Microsoft.Maps.Map(input.container[0], mapOptions);

                map.setView({
                    mapTypeId: Microsoft.Maps.MapTypeId.road
                });

                if (++input.progress.done &gt;= input.progress.total) {
                    input.loadCallback &amp;&amp; input.loadCallback();
                }
            }
        }

        /**
         * Draws a pushpin using the input location. Note that this is a location object
         * from artwork.Metdata.RichLocationHistory.locations.
         * @method drawPushpin
         * @param {Object} options       some input options
         *          {Object} location      location data for pushpin
         *          {Doq} mapdoq           the doq representing our map (not used here)
         *          {Boolean} editing      whether this pushpin should be manipulatable
         * @return {Microsoft.Maps.Pushpin}     the pushpin object
         */
        function drawPushpin(options) {
            var location = options.location,
                editing = options.editing,
                loc = new Microsoft.Maps.Location(location.latitude, location.longitude),
                pushpin;

            pushpin = new Microsoft.Maps.Pushpin(loc, {
                draggable: !!editing,
                icon: tagPath+&#x27;images/icons/locationPin.svg&#x27;, //green icon is the default
                width: 20,
                height: 30
            });

            //ability to select a pushpin
            Microsoft.Maps.Events.addHandler(pushpin, &#x27;click&#x27;, selectPushpin);
            function selectPushpin() {
                if (!formIsEnabled) { //don&#x27;t do anything if another form is already open
                    if (location.descContainer.css(&#x27;display&#x27;) === &#x27;block&#x27;) { //if previously selected - deselect
                        deselect(location, pushpin, false);
                    } else {
                        select(location, pushpin, false);
                        //scroll to the correct location in the list
                        locationsRegion.scrollTop(0);
                        locationsRegion.scrollTop(pushpin.container.position().top);
                    }
                }
            }

            map.entities.push(pushpin);

            return pushpin;
        }

        /**
         * Removes the given pushpin from the map
         * @method removePushpin
         * @param {Object} options           some input options
         *          {Microsoft.Maps.Pushpin}   pushpin    the pushpin to remove
         */
        function removePushpin(options) {
            map.entities.remove(options.pushpin);
        }

        /**
         * Creates location editing interface (used for adding new and editing existing
         * locations)
         * @method createLocationEditor
         * @param {Object} options       some input options
         *          {Object} location       location data to be edited (null for new location)
         *          {Number} index          index of location in location list
         *          {Function} cancelClick  cancel button click handler
         * @return {jQuery obj}          editing container div, which can be appended to list
         */
        function createLocationEditor(options) {
            options = options || {};

            var editingFormElements = commonCreateLocationEditor({
                location: options.location,
                custom: false,
                mapguid: null,
                index: options.index,
                cancelClick: options.cancelClick
            });

            // set up search button click handler
            editingFormElements.searchButton.on(&#x27;click&#x27;, function () {
                editingFormElements.resultsDiv.css({ &#x27;margin-bottom&#x27;: &#x27;2%&#x27; }); //set this margin only when the results div will be displayed
                editingFormElements.resultsDiv.empty();
                editingFormElements.resultsDiv.text(&#x27;Searching...&#x27;); // TODO better loading UI

                searchBingLocation(editingFormElements.titleInput.val(), function (result) { // success handler
                    var i;

                    // error checking
                    if (!result || !result.resourceSets || !result.resourceSets[0] || !result.resourceSets[0].resources || !result.resourceSets[0].resources.length) {
                        editingFormElements.resultsDiv.text(&#x27;No results found.&#x27;); // TODO could look better
                        return;
                    }

                    editingFormElements.resultsDiv.empty();

                    for (i = 0; i &lt; result.resourceSets[0].resources.length; i++) {
                        editingFormElements.resultsDiv.append(createSearchResultDiv(result.resourceSets[0].resources[i]));
                    }

                    //Select the first result
                    $(&#x27;.bingSearchResultContainer:eq(0)&#x27;).click();

                }, function () { // error handler
                    editingFormElements.resultsDiv.text(&#x27;Error contacting Bing Maps. Please try again.&#x27;);
                });
            });

            /**
             * Creates a bing map search result div. Called by the callback to searchBingLocation.
             * @method createSearchResultDiv
             * @param {Object} result                this is an object derived from the results of a bing map search
             */
            function createSearchResultDiv(result) {
                var container = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;bingSearchResultContainer&#x27;);

                container.css({
                    position: &#x27;relative&#x27;,
                    width: &#x27;100%&#x27;,
                    &#x27;padding-left&#x27;: &#x27;10px&#x27;,
                    &#x27;font-size&#x27;:&#x27;20px&#x27;
                });

                container.text(result.address.formattedAddress);

                container.on(&#x27;click&#x27;, function () {

                    $(&#x27;.bingSearchResultContainer&#x27;).css(&#x27;background-color&#x27;, &#x27;rgba(0,0,0,0)&#x27;);
                    container.css(&#x27;background-color&#x27;, &#x27;rgba(255,255,255,0.2)&#x27;);

                    // error checking
                    if (!result.point || !result.point.coordinates || !result.point.coordinates.length) {
                        return;
                    }

                    editingFormElements.titleInput.attr(&#x27;value&#x27;, result.address.formattedAddress);

                    // reset pushpin location
                    editingFormElements.pushpin.setLocation({
                        latitude: result.point.coordinates[0],
                        longitude: result.point.coordinates[1]
                    });

                    // error checking
                    if (!result.bbox || !result.bbox.length) {
                        return;
                    }

                    // pan/zoom to specified point
                    map.setView({
                        bounds: Microsoft.Maps.LocationRect.fromLocations(
                                new Microsoft.Maps.Location(result.bbox[0], result.bbox[1]),
                                new Microsoft.Maps.Location(result.bbox[2], result.bbox[3])
                            )
                    });
                });

                return container;
            }

            /**
             * Searches the input string on a bing map.
             * @method searchBingLocation
             * @param {String} locString          input string to search
             * @param {Function} success          function to call when results have been found
             * @param {Function} error            error callback
             */
            function searchBingLocation(locString, success, error) {
                var requestURL = &quot;http://dev.virtualearth.net/REST/v1/Locations?query=&quot; + encodeURI(locString) + &quot;&amp;output=json&amp;key=&quot; + credentials;

                $.ajax({
                    url: requestURL,
                    success: success,
                    error: error
                });
            }

            return editingFormElements
        }

        /**
         * Creates a location item in the bottom panel (locationsRegion)
         * @method  
         * @param {Object} location      location data for item
         */
        function createLocationItem(location) {
            commonCreateLocationItem({
                location: location,
                custom: false
            });
        }

        return {
            init: init,
            drawPushpin: drawPushpin,
            removePushpin: removePushpin,
            createLocationEditor: createLocationEditor,
            createLocationItem: createLocationItem
        };
    };

    /**
     * Some helper functions for custom maps. The idea is to have BingMapHelper
     * and CustomMapHelper implement the same interface, so manipulating location data can
     * be generic
     * @method CustomMapHelper
     */
    function CustomMapHelper() {

        /**
         * Initialize a custom map
         * @method init
         * @param {Object} input        some input options
         *             container:        container of the bing map
         *             progress:         an object allowing us to keep track of how many of all maps have loaded
         *             loadCallback:     callback function to call if this is the last map to load
         *             mapdoq:           the doq of the custom map
         */
        function init(input) {
            annotImgs = {};
            var annotImg = new TAG.AnnotatedImage({
                root        :   input.container,
                doq         :   input.mapdoq,
                callback    :   function(){
                    annotImg.openArtwork(input.mapdoq);
                    annotImgs[input.mapdoq.Identifier] = annotImg;
                    annotImg.initZoom();
                    
                    if (++input.progress.done &gt;= input.progress.total) {
                            input.loadCallback &amp;&amp; input.loadCallback();
                    }
                },
                noMedia     :   true
            });
        }

        /**
         * Draw a pushpin on the given map
         * @method drawPushpin
         * @param {Object} options       some input options
         *          {Object} location      location data for pushpin
         *          {Doq} mapdoq           the doq representing our map
         *          {Boolean} editing      whether this pushpin should be manipulatable
         * @return {jQuery obj}          the pushpin element
         */
        function drawPushpin(options) {
            var location = options.location,
                mapdoq = options.mapdoq,
                editing = options.editing,
                annotImg = annotImgs[mapdoq.Identifier],
                pushpin = $(document.createElement(&#x27;img&#x27;)),
                lastPivot;
            if (!annotImg) {
                return;
            }

            pushpin.attr({
                src: tagPath+&#x27;images/icons/locationPin.svg&#x27;
            });

            pushpin.css({
                width: &#x27;20px&#x27;,
                height: &#x27;30px&#x27;,
                &#x27;z-index&#x27;: &#x27;1&#x27;
            });

            pushpin.addClass(&#x27;locationPushpin&#x27;);

            if (editing) {
                pushpin.attr({
                    src: tagPath+&#x27;images/icons/locationPin2.svg&#x27;
                });
            }

            pushpin.on(&#x27;click&#x27;, function () {
                if (!editing) {
                    if (!formIsEnabled) { //don&#x27;t do anything if another form is already open
                        if (location.descContainer.css(&#x27;display&#x27;) === &#x27;block&#x27;) { //if previously selected - deselect
                            deselect(location, pushpin, true);
                        } else { //if not previously selected - select
                            select(location, pushpin, true);
                            //scroll to the correct location in the list
                            locationsRegion.scrollTop(0);
                            locationsRegion.scrollTop(pushpin.container.position().top);
                        }
                    }
                }
            });

            //all pins start off in an overlay
            annotImg.addOverlay(pushpin[0], new Seadragon.Point(location.x, location.y), Seadragon.OverlayPlacement.BOTTOM);

            var isOverlay = true,
                x,
                y,
                t,
                l,
                w = parseFloat(pushpin.css(&#x27;width&#x27;)),
                h = parseFloat(pushpin.css(&#x27;height&#x27;));

            TAG.Util.makeManipulatable(pushpin[0], {
                onManipulate: function (res) {
                    if (editing) {
                        if (isOverlay) {
                            annotImg.pauseManip(); //prevents the image from moving when the pin is being manipulated
                            isOverlay = false;
                            t = pushpin.css(&#x27;top&#x27;);
                            l = pushpin.css(&#x27;left&#x27;);
                            annotImg.removeOverlay(pushpin[0]); //seems like this changes the CSS of the pushpin?
                            pushpin.appendTo(mapHolders[mapdoq.Identifier]);
                            pushpin.css({
                                top: t,
                                left: l,
                                position: &#x27;absolute&#x27;
                            });
                        }

                        //if pushpin is within bounds of viewport
                        if (annotImg.isInViewportBounds(pushpin)) {
                            t = parseFloat(pushpin.css(&#x27;top&#x27;)),
                            l = parseFloat(pushpin.css(&#x27;left&#x27;));

                            pushpin.css(&quot;top&quot;, (t + res.translation.y) + &quot;px&quot;);
                            pushpin.css(&quot;left&quot;, (l + res.translation.x) + &quot;px&quot;);

                            //update the overlay coordinates here - b/c need the translation
                            x = l + res.translation.x + (0.5 * w);
                            y = t + res.translation.y + (h);

                            lastPivot = res.pivot;

                        }
                        //otherwise the location of the pushpin is not updated with manipulation
                    }
                },
                onRelease: function (evt) {
                    if (editing &amp;&amp; !isOverlay) {
                        //add the overlay back once mouse is released
                        isOverlay = true;

                        //if pushpin is not within bounds of image, it snaps back to the edge on release
                        if (!annotImg.isInImageBounds(pushpin)) {
                            var coord = annotImg.returnElementToBounds(pushpin);
                            pushpin.css(&quot;top&quot;, (coord.y - h) + &quot;px&quot;);
                            pushpin.css(&quot;left&quot;, (coord.x - 0.5 * w) + &quot;px&quot;);
                            annotImg.addOverlay(pushpin[0], annotImg.pointFromPixel(new Seadragon.Point(coord.x, coord.y)), Seadragon.OverlayPlacement.BOTTOM);
                        } else {
                            annotImg.addOverlay(pushpin[0], annotImg.pointFromPixel(new Seadragon.Point(x, y)), Seadragon.OverlayPlacement.BOTTOM);
                        }
                        annotImg.restartManip(); //allow manipulation of the DZ image after the pin is put down
                    }
                },
                onScroll: function (delta, pivot) { //allow scrolling of the map while dragging a pin (or when the mouse is on top of a pin)
                    annotImg.scroll(delta, { //use the location of the pushpin for the pivot
                        x: w + parseFloat(pushpin.css(&#x27;left&#x27;)),
                        y: h + parseFloat(pushpin.css(&#x27;top&#x27;))
                    });
                }
            }, false, true);

            return pushpin;
        }

        /**
         * Removes the given pushpin from the map
         * @method removePushpin
         * @param {Object} options        some input options
         *          {jQuery obj} pushpin    the pushpin to remove
         *          {Object} mapguid        corresponding map&#x27;s guid
         */
        function removePushpin(options) {
            annotImgs[options.mapguid].removeOverlay(options.pushpin[0]);
            options.pushpin.remove();
        }

        /**
         * Creates location editing interface (used for adding new and editing existing
         * locations)
         * @method createLocationEditor
         * @param {Object} options       some input options
         *          {Object} location       location data to be edited (null for new location)
         *          {Number} index          index of location in location list
         *          {Function} cancelClick  cancel button click handler
         * @return {jQuery obj}          editing container div, which can be appended to list
         */
        function createLocationEditor(options) {
            options = options || {};

            return commonCreateLocationEditor({
                location: options.location,
                custom: true,
                mapguid: mapGuids[currentIndex],
                index: options.index,
                cancelClick: options.cancelClick
            });
        }

        /**
         * Creates a location item in the bottom panel (locationsRegion)
         * @method createLocationItem
         * @param {Object} location      location data for item
         * @param {Doq} mapdoq           the doq representing our map
         */
        function createLocationItem(location, mapdoq) {
            var container = commonCreateLocationItem({
                location: location,
                custom: true,
                mapguid: mapdoq.Identifier
            });
        }

        return {
            init: init,
            drawPushpin: drawPushpin,
            removePushpin: removePushpin,
            createLocationEditor: createLocationEditor,
            createLocationItem: createLocationItem
        };
    }

    /**
     * Common functionality for creating location items
     * @method commonCreateLocationItem
     * @param {Object} options        some input options:
     *          {Object} location        the location in question
     *          {Boolean} custom         whether this is from a custom map
     *          {String} mapguid         the guid of the map in question
     *          
     * @return {jQuery obj}           the outer container of the list item
     */
    function commonCreateLocationItem(options) {
        var container = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationItemContainer&#x27;),
            deleteButton = $(document.createElement(&#x27;img&#x27;)).addClass(&#x27;locationItemDeleteButton&#x27;),
            editButton = $(document.createElement(&#x27;img&#x27;)).addClass(&#x27;locationItemEditButton&#x27;),
            titleContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationItemTitle&#x27;),
            dateContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationItemDate&#x27;),
            descContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationItemDesc&#x27;),
            location = options.location,
            custom = options.custom,
            helper = custom ? customMapHelper : bingMapHelper,
            mapguid = options.mapguid || null,
            pushpin;

        location &amp;&amp; (location.descContainer = descContainer);
        location &amp;&amp; (location.container = container);

        if (!location) {
            console.log(&quot;please provide all options&quot;);
            return;
        }

        pushpin = helper.drawPushpin({
            location: options.location,
            mapdoq: mapDoqs[mapguid],
            editing: false
        });

        pushpin[&#x27;container&#x27;] = container;

        container.css({
            margin: &#x27;0px 0px 10px 0px&#x27;,
            position: &#x27;relative&#x27;,
            width: &#x27;97%&#x27;,
        });
        container.on(&#x27;click&#x27;, function () {
            if (!formIsEnabled) { //don&#x27;t do anything if another form is already open
                if (location.descContainer.css(&#x27;display&#x27;) === &#x27;block&#x27;) { //if previously selected
                    if (custom) {
                        deselect(location, pushpin, true);
                    } else {
                        deselect(location, pushpin, false);
                    }
                }
                else { //if not previously selected
                    if (custom) {
                        annotImgs[mapguid].panToPoint(pushpin[0]);
                        select(location, pushpin, true);
                    } else {
                        select(location, pushpin, false);
                        if (!map.getBounds().contains(pushpin.getLocation())) {
                            map.setView(new Microsoft.Maps.LocationRect.fromLocations(pushpin.getLocation()));
                        }
                    }
                    showMap(mapguid); //don&#x27;t show the map if you are deselecting a label from another map
                }
            }
        });

        if (input.authoring) {

            deleteButton.css({
                display: &#x27;inline-block&#x27;,
                cursor: &#x27;pointer&#x27;,
                height: &#x27;30px&#x27;,
                margin: &#x27;2px&#x27;,
                position: &#x27;relative&#x27;,
                &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
                width: &#x27;30px&#x27;
            });

            deleteButton.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/delete.svg&#x27;);

            deleteButton.on(&#x27;click&#x27;, function (evt) {
                var overlay = LADS.Util.UI.PopUpConfirmation(function () {
                    index = locations.indexOf(location);
                    if (index &gt;= 0) {
                        locations.splice(index, 1);
                        saveRichLocationHistory();
                    } else {
                        console.log(&quot;error&quot;);
                    }
                }, &quot;Are you sure you want to delete this location?&quot;, &quot;Yes&quot;);
                root.append(overlay);
                $(overlay).show();

                evt.stopPropagation();
            });

            editButton.css({
                display: &#x27;inline-block&#x27;,
                cursor: &#x27;pointer&#x27;,
                height: &#x27;30px&#x27;,
                margin: &#x27;2px&#x27;,
                position: &#x27;relative&#x27;,
                &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
                width: &#x27;30px&#x27;
            });

            editButton.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/edit.png&#x27;);

            editButton.on(&#x27;click&#x27;, function (evt) {
                if (!formIsEnabled) {
                    formIsEnabled = true;
                    isEditForm = true;

                    //deselect other locations (if necessary)
                    $(&#x27;.locationItemDesc&#x27;).css({ &#x27;display&#x27;: &#x27;none&#x27; });
                    $(&#x27;.locationItemContainer&#x27;).css(&#x27;background-color&#x27;, &#x27;rgba(0,0,0,0)&#x27;);
                    //reset all pushpins to the green icon
                    $(&#x27;.locationPushpin&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin.svg&#x27;);
                    for (l = 0; l &lt; map.entities.getLength() ; l++) { //iterates through bing map pushpins
                        map.entities.get(l).setOptions({ icon: tagPath+&#x27;images/icons/locationPin.svg&#x27; });
                    }

                    if (custom) {
                        pushpin &amp;&amp; pushpin.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin2.svg&#x27;);
                    }
                    //if it&#x27;s a bing map pushpin, it&#x27;s set to red below

                    var editingFormElements;
                    showMap(mapguid);

                    //make sure that the pin is visible on the map
                    if (custom) {
                        annotImgs[mapguid].panToPoint(pushpin[0]);
                    } else {
                        if (!map.getBounds().contains(pushpin.getLocation())) {
                            map.setView(new Microsoft.Maps.LocationRect.fromLocations(pushpin.getLocation()));
                        }
                    }

                    editingFormElements = helper.createLocationEditor({
                        location: location,
                        index: locations.indexOf(location),
                        cancelClick: function () {
                            commonCreateLocationItem(options).insertAfter($(&#x27;.locationEditingContainer&#x27;));
                            //editingFormElements.container.after(container);
                            //editingFormElements.container.remove();
                            //pushpin = helper.drawPushpin({
                            //    location: location,
                            //    mapdoq: mapDoqs[location.map],
                            //    editing: false
                            //});
                        }
                    });
                    container.after(editingFormElements.container);
                    container.detach();
                    helper.removePushpin({
                        pushpin: pushpin,
                        mapguid: location.map
                    });
                    (!custom) &amp;&amp; map.entities.get(map.entities.getLength() - 1).setOptions({ icon: tagPath+&#x27;images/icons/locationPin2.svg&#x27; }); //set the last pushpin to red

                    //scroll to the correct position
                    locationsRegion.scrollTop(0);
                    locationsRegion.scrollTop(editingFormElements.container.position().top + 20);
                }
            });
        }

        titleContainer.css({
            display: &#x27;inline-block&#x27;,
            margin: &#x27;0px 10px 0px 10px&#x27;,
            position: &#x27;relative&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;font-size&#x27;: &#x27;24px&#x27;
        });
        titleContainer.text((location.title ? location.title + (location.date ? &#x27;,&#x27; : &#x27;&#x27;) : (location.date ? &#x27;&#x27; : &#x27;(Untitled Location)&#x27;)));
        (!location.title &amp;&amp; titleContainer.css({margin:&#x27;0px 0px 0px 10px&#x27;}));

        dateContainer.css({
            display: &#x27;inline-block&#x27;,
            margin: &#x27;0px 0px 0px 0px&#x27;,
            position: &#x27;relative&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;font-size&#x27;: &#x27;24px&#x27;
        });
        dateContainer.text(location.date || &#x27;&#x27;);

        descContainer.css({
            display: &#x27;none&#x27;,
            margin: &#x27;0px 0px 0px 80px&#x27;,
            position: &#x27;relative&#x27;,
            &#x27;vertical-align&#x27;: &#x27;middle&#x27;,
            &#x27;font-size&#x27;: &#x27;20px&#x27;,
            &#x27;padding-right&#x27;: &#x27;20px&#x27;,
            &#x27;font-style&#x27;: &#x27;italic&#x27;
        });

        if (!input.authoring) {
            descContainer.css({ margin: &#x27;0px 0px 0px 10px&#x27; });
        }

        descContainer.text(location.description || &#x27;&#x27;);
        if (descContainer.text() === &#x27;&#x27;) { //don&#x27;t put padding if it&#x27;s empty, so that clicking on it won&#x27;t change the height
            descContainer.css(&#x27;padding-bottom&#x27;, &#x27;0px&#x27;);
        } else {
            descContainer.css(&#x27;padding-bottom&#x27;, &#x27;10px&#x27;);
        }

        if (input.authoring) {
            container.append(deleteButton);
            container.append(editButton);
        }

        container.append(titleContainer);
        container.append(dateContainer);
        container.append(descContainer);

        locationsRegion.append(container);

        return container;
    }

    /**
     * Common functionality for creating location editor UIs. This is here because a lot
     * of code would be copied between the BingMapHelper and CustomMapHelper otherwise. Some
     * functionality is specific to one or the other, though, so that&#x27;s taken care of in their
     * respective createLocationEditor methods using the returned components here.
     * @method commonCreateLocationEditor
     * @param {Object} options       some input options
     *          {Object} location       the location in question
     *          {Boolean} custom        whether this is a custom map
     *          {String} mapguid        the guid of the map in question
     *          {Number} index          index of loaaction in location list
     *          {Function} cancelClick  cancel button click event
     * @return {Object}              the relevant components of the editing form
     */
    function commonCreateLocationEditor(options) {
        options = options || {}; // cut down on null checks later

        //&#x27;de-select&#x27; any previous locations from the list (only want one red pin at a time)
        $(&#x27;.locationItemContainer&#x27;).css(&#x27;background-color&#x27;, &#x27;rgba(0,0,0,0)&#x27;);
        $(&#x27;.locationItemDesc&#x27;).css({ &#x27;display&#x27;: &#x27;none&#x27; });
        $(&#x27;.locationPushpin&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin.svg&#x27;);
        for (var l = 0; l &lt; map.entities.getLength() ; l++) { //iterates through all of the bing map pushpins
            map.entities.get(l).setOptions({ icon: tagPath+&#x27;images/icons/locationPin.svg&#x27; });
        }

        var container = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationEditingContainer&#x27;),

            titleContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationOptionsContainer&#x27;),
            titleInput = $(document.createElement(&#x27;input&#x27;)).addClass(&#x27;locationTitleInput&#x27;),
            titleLabel = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationLabel&#x27;).text(&#x27;Location Title&#x27;),

            dateContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationOptionsContainer&#x27;),
            dateInput = $(document.createElement(&#x27;input&#x27;)).addClass(&#x27;locationDateInput&#x27;),
            dateLabel = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationLabel&#x27;).text(&#x27;Date&#x27;),

            descContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationOptionsContainer&#x27;),
            descInput = $(document.createElement(&#x27;textarea&#x27;)).addClass(&#x27;locationDescInput&#x27;),
            descLabel = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationLabel&#x27;).text(&#x27;Description&#x27;),

            bottomButtonsContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationOptionsContainer&#x27;),
            saveButton = $(document.createElement(&#x27;button&#x27;)).addClass(&#x27;locationSaveButton&#x27;),
            deleteButton = $(document.createElement(&#x27;button&#x27;)).addClass(&#x27;locationDeleteButton&#x27;),
            cancelButton = $(document.createElement(&#x27;button&#x27;)).addClass(&#x27;locationCancelButton&#x27;),

            searchButton,
            resultsDiv,
            location = options.location,
            index = options.index,
            custom = options.custom,
            mapguid = options.mapguid,
            helper = custom ? customMapHelper : bingMapHelper,
            pushpin,
            cancelClick = function () {
                formIsEnabled = false;
                options.cancelClick &amp;&amp; options.cancelClick();
                removeLocationForm();
                helper.removePushpin({
                    pushpin: pushpin,
                    mapguid: mapguid
                });
            };

        if (!custom) {
            if (!location || index &lt; 0 || index &gt;= locations.length) {
                var bounds = map.getBounds();
                var centerCoord = map.getCenter();
                location = {
                    latitude: centerCoord.latitude + (.01 * (bounds.getSouth() - bounds.getNorth())), //1% offset from center is to prevent the new pin from directly 
                    longitude: centerCoord.longitude + (.01 * (bounds.getEast() - bounds.getWest())) //overlapping one that may have been previously selected
                };
                index = locations.length;
            }
        } else {
            if (!location || index &lt; 0 || index &gt;= locations.length) {
                var startLocation = annotImgs[mapguid].createStartingPoint(); //uses the same 1% offset
                location = {
                    x: startLocation.x,
                    y: startLocation.y
                }
                index = locations.length;
            }
        }

        pushpin = helper.drawPushpin({
            location: location,
            mapdoq: mapDoqs[mapguid],
            editing: true
        });

        if (custom) {
            pushpin.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin2.svg&#x27;);
        } else {
            pushpin.setOptions({ icon: tagPath+&#x27;images/icons/locationPin2.svg&#x27; });
        }

        container.css({
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;position&#x27;: &#x27;relative&#x27;,
            &#x27;overflow&#x27;: &#x27;auto&#x27;,
            &#x27;padding&#x27;: &#x27;0px 4% 0px 0px&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;4%&#x27;,
            &#x27;margin-top&#x27;: &#x27;2%&#x27;
        });

        titleLabel.css({
            &#x27;width&#x27;: &#x27;20%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;vertical-align&#x27;: &#x27;top&#x27;,
            &#x27;text-align&#x27;: &#x27;right&#x27;
        });

        dateLabel.css({
            &#x27;width&#x27;: &#x27;20%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;vertical-align&#x27;: &#x27;top&#x27;,
            &#x27;text-align&#x27;: &#x27;right&#x27;
        });

        descLabel.css({
            &#x27;width&#x27;: &#x27;20%&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;vertical-align&#x27;: &#x27;top&#x27;,
            &#x27;text-align&#x27;: &#x27;right&#x27;
        });

        titleContainer.css({
            &#x27;margin-bottom&#x27;: &#x27;2%&#x27;
        });

        dateContainer.css({
            &#x27;margin-bottom&#x27;: &#x27;2%&#x27;
        });

        descContainer.css({
            &#x27;margin-bottom&#x27;: &#x27;2%&#x27;
        });


        titleInput.css({
            position: &#x27;relative&#x27;,
            width: &#x27;52%&#x27;,
            left: &#x27;2%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        titleInput.attr({
            placeholder: &#x27; Title&#x27;,
            value: location.title ? location.title : &#x27;&#x27;
        });

        if (!custom) {

            titleInput.css({ width: &#x27;42%&#x27; });

            searchButton = $(document.createElement(&#x27;button&#x27;)).addClass(&#x27;locationEditorSearchButton&#x27;);
            searchButton.attr({
                type: &#x27;button&#x27;
            });
            searchButton.text(&#x27;Search&#x27;);
            searchButton.css({ &#x27;display&#x27;: &#x27;inline-block&#x27;, &#x27;margin-left&#x27;:&#x27;3.5%&#x27;});

            resultsDiv = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;locationEditorSearchResults&#x27;);
            resultsDiv.css({
                left: &#x27;22%&#x27;,
                &#x27;max-height&#x27;: &#x27;200px&#x27;,
                &#x27;overflow-x&#x27;: &#x27;hidden&#x27;,
                &#x27;overflow-y&#x27;: &#x27;auto&#x27;,
                position: &#x27;relative&#x27;,
                width: &#x27;52.5%&#x27;
            });
        }

        dateInput.css({
            position: &#x27;relative&#x27;,
            width: &#x27;52%&#x27;,
            left: &#x27;2%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        dateInput.attr({
            placeholder: &#x27; Date&#x27;,
            value: location.date ? location.date : &#x27;&#x27;
        });

        descInput.css({
            position: &#x27;relative&#x27;,
            width: &#x27;49.75%&#x27;,
            left: &#x27;2%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        descInput.attr({
            placeholder: &#x27; Description&#x27;,
            rows: &#x27;3&#x27;,
            value: location.description ? location.description : &#x27;&#x27;
        });

        bottomButtonsContainer.css({
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            position: &#x27;relative&#x27;,
            left: &#x27;22%&#x27;,
            width: &#x27;70%&#x27;
        });

        saveButton.css({
            position: &#x27;relative&#x27;,
            &#x27;margin-right&#x27;: &#x27;2%&#x27;
        });
        saveButton.text(&#x27;Save Location&#x27;);
        saveButton.on(&#x27;click&#x27;, function () {
            // TODO only replace the relevant list item rather than recreating whole list
            var pushpinLocation,
                newLoc,
                currInd = currentIndex;

            if (custom) {
                pushpinLocation = annotImgs[mapGuids[currInd]].getOverlayCoordinates(pushpin[0]);
                newLoc = {
                    map: mapGuids[currInd],
                    title: titleInput.val(),
                    date: dateInput.val(),
                    description: descInput.val(),
                    x: pushpinLocation.x,
                    y: pushpinLocation.y
                };
            } else {
                pushpinLocation = pushpin.getLocation();
                newLoc = {
                    map: null,
                    title: titleInput.val(),
                    date: dateInput.val(),
                    description: descInput.val(),
                    latitude: pushpinLocation.latitude,
                    longitude: pushpinLocation.longitude
                };
            }
            if (index &gt;= 0 &amp;&amp; index &lt; locations.length) {
                locations[index] = newLoc;
            } else {
                locations.push(newLoc);
            }

            saveRichLocationHistory({
                callback: function () {
                    showMap(mapGuids[currInd]);
                }
            });
            formIsEnabled = false;
        });

        if (location) {
            deleteButton.css({
                position: &#x27;relative&#x27;,
                &#x27;margin-right&#x27;: &#x27;2%&#x27;
            });
            deleteButton.text(&#x27;Delete&#x27;);
            deleteButton.on(&#x27;click&#x27;, function (evt) {
                formIsEnabled = false;
                var overlay = LADS.Util.UI.PopUpConfirmation(function () {
                    index = locations.indexOf(location);
                    if (index &gt;= 0 &amp;&amp; index &lt; locations.length) {
                        locations.splice(index, 1);
                    }
                    saveRichLocationHistory();
                }, &quot;Are you sure you want to delete this location?&quot;, &quot;Yes&quot;);
                root.append(overlay);
                $(overlay).show();
                evt.stopPropagation();
            });
        }

        cancelButton.css({
            position: &#x27;relative&#x27;,
            &#x27;margin-right&#x27;: &#x27;2%&#x27;
        });
        cancelButton.text(&#x27;Cancel&#x27;);
        cancelButton.on(&#x27;click&#x27;, cancelClick);

        titleContainer.append(titleLabel);
        titleContainer.append(titleInput);
        container.append(titleContainer);
        if (!custom) {
            titleContainer.append(searchButton);
            container.append(resultsDiv);
        }

        dateContainer.append(dateLabel);
        dateContainer.append(dateInput);
        container.append(dateContainer);

        descContainer.append(descLabel);
        descContainer.append(descInput);
        container.append(descContainer);

        bottomButtonsContainer.append(saveButton);
        if (isEditForm) { //new added locations should not have a delete button
            (location &amp;&amp; bottomButtonsContainer.append(deleteButton));
            isEditForm = false;
        }
        bottomButtonsContainer.append(cancelButton);
        container.append(bottomButtonsContainer);

        if (custom) {
            return {
                container: container
            };
        }
        return {
            container: container,
            titleInput: titleInput,
            searchButton: searchButton,
            resultsDiv: resultsDiv,
            pushpin: pushpin
        };
    }

    /**
     * Saves latest rich location history data to the artwork doq. Uses the maps and
     * locations variables, so make sure those are up to date before calling. Reloads
     * all maps afterwards.
     * @method saveRichLocationHistory
     * @param {Object} input       some input options, including:
     *              toadd          a string of comma-separated GUIDs of maps to add
     *              toremove       a string of comma-separated GUIDs of maps to remove
     *              noReload       a boolean telling us whether to reload maps or not
     *              callback       a callback function to be called after saving and reloading artwork is done
     */
    function saveRichLocationHistory(input) {
        var options = {
            RichLocationHistory: generateRichLocationData()
        };

        input = input || {}; // cut down on null checks later

        if (input.toadd) {
            options.AddMaps = input.toadd;
        }

        if (input.toremove) {
            options.RemoveMaps = input.toremove;

        }

        !input.noReload &amp;&amp; showLoadingMessage();
        LADS.Worktop.Database.changeArtwork(artwork.Identifier, options, success, error, error, error);

        function success() {
            LADS.Worktop.Database.getDoq(artwork.Identifier, function (newArtwork) {
                artwork = newArtwork;
                richLocationData = artwork.Metadata.RichLocationHistory ? JSON.parse(artwork.Metadata.RichLocationHistory) : locationToRichLocation(artwork.Metadata.Location);
                locations = richLocationData.locations || [];
                !input.noReload &amp;&amp; getMaps(input.callback);
            }, error, error);
            //input.sort &amp;&amp; input.callback();
        }

        function error() {
            console.log(&#x27;An error occured while saving.&#x27;);
        }
    }

    /**
     * Generates a RichLocationHistory property (string) from the maps and locations
     * variables for saving. A helper function for saveRichLocationHistory.
     * @method generateRichLocationData
     * @return {String}              a string to be used as a RichLocationHistory property
     */
    function generateRichLocationData() {
        return JSON.stringify({
            defaultMapShown: defaultMapShown,
            locations: locations
        });
    }

    /**
     * Toggles the default map overlay to indicate that it is
     * enabled or disabled. Uses the value of defaultMapShown
     * to do so.
     * @method toggleDefaultMap
     */
    function toggleDefaultMap() {
        defaultMapShown = !defaultMapShown;
        defaultMapShown ? disabledOverlay.remove() : disabledOverlay.appendTo(mapHolders[null]);
        deleteButton.text(defaultMapShown ? &#x27;Hide Bing Map&#x27; : &#x27;Show Bing Map&#x27;);
    }

    /**
     * Delete the selected map, reload maps, set the current map to bing map (for now)
     * @method deleteMap
     */
    function deleteMap() {
        var mapguid = mapGuids[currentIndex],
            i,
            locs;
        if (mapguid) {
            removeLocations(mapguid);
            saveRichLocationHistory({
                toremove: mapguid
            });
        } else {
            toggleDefaultMap();
            saveRichLocationHistory({
                noReload: true
            });
        }
    }

    /**
     * Remove locations associated with a given map from artwork metadata
     * @method removeLocations
     * @param {String} guid       map guid
     */
    function removeLocations(guid) {
        var i;

        for (i = locations.length - 1; i &gt;= 0; i--) {
            if (locations[i].map === guid) {
                locations.splice(i, 1);
            }
        }

        richLocationData = {
            defaultMapShown: defaultMapShown,
            locations: locations
        };
    }

    /**
     * Upload a custom map from user&#x27;s computer
     * @method uploadCustomMap
     */
    function importMap() {
        formIsEnabled = false;
        importingMap = true;
        var fileArray,
            i;

        LADS.Authoring.FileUploader(
            root,
            LADS.Authoring.FileUploadTypes.Map, // TODO RLH TESTING: change this to LADS.Authoring.FileUploadTypes.Map to test map uploading
            function (files) {
                fileArray = files;
            },
            function (urls) {
                var newDoq
                if (!urls.length &amp;&amp; urls.length !== 0) { // check to see whether a single file was returned
                    urls = [urls];
                }
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[0]);
                } catch (error) {
                    console.log(&quot;error in uploading: &quot; + error.message);
                    return;
                }
                mapGuids.push(newDoq.Identifier);

                mapDoqs[newDoq.Identifier] = newDoq;
                //update changeartwork and linq the map and artwork
                saveRichLocationHistory({
                    toadd: newDoq.Identifier,
                });

                //reload (which will show the map that has just been imported)
                loadMaps();

                //LADS.Worktop.Database.changeArtwork(artwork.Identifier, {AddMaps:JSON.stringify(maps)});
                // TODO this is just in here for testing purposes
                //LADS.Worktop.Database.changeMap(newDoq.Identifier, { Name: &quot;Custom Map&quot;, Description: &quot;Test description&quot;, AdditionalInfo: &quot;Middle Pharaoh Period&quot; }, function () {
                //    console.log(&#x27;success in changeMap&#x27;);
                //}, function () { }, function () { }, function () { }); // TODO RLH TESTING: make sure map doq is updated properly (the next time it&#x27;s loaded, it should have these metadata)
            },
            [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;],//, &#x27;.tif&#x27;, &#x27;.tiff&#x27; these two crashes visual studio every time we click on the dot to show map. haven&#x27;t found why though
            false,
            function () {
                root.append(LADS.Util.UI.popUpMessage(null, &quot;There was an error uploading the file.  Please try again later.&quot;));
            },
            false // batch upload disabled for now
        );

    }


    /**
     * De-select a location pin and the corresponding location list item
     * @method deselect
     */
    function deselect(location, pushpin, custom) {
        location.descContainer.css({ &#x27;display&#x27;: &#x27;none&#x27; });
        $(&#x27;.locationItemContainer&#x27;).css(&#x27;background-color&#x27;, &#x27;rgba(0,0,0,0)&#x27;);
        if (!custom) {
            pushpin.setOptions({ icon: tagPath+&#x27;images/icons/locationPin.svg&#x27; });
        } else {
            $(&#x27;.locationPushpin&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin.svg&#x27;);
        }
    }

    /**
     * Select a location pin and the corresponding location list item
     * @method select
     */
    function select(location, pushpin, custom) {
        var l;

        //if not previously selected - expand the correct description
        $(&#x27;.locationItemDesc&#x27;).css({ &#x27;display&#x27;: &#x27;none&#x27; });
        location.descContainer.css({ &#x27;display&#x27;: &#x27;block&#x27; });
        $(&#x27;.locationItemContainer&#x27;).css(&#x27;background-color&#x27;, &#x27;rgba(0,0,0,0)&#x27;);
        pushpin.container.css(&#x27;background-color&#x27;, &#x27;rgba(255,255,255,0.2)&#x27;);

        //reset all pushpins here to the green icon
        $(&#x27;.locationPushpin&#x27;).attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin.svg&#x27;);
        if (input.authoring || defaultMapShown) { //can&#x27;t access map if in art mode and bing map is not shown
            for (l = 0; l &lt; map.entities.getLength() ; l++) { //iterates through all of the bing map pushpins
                map.entities.get(l).setOptions({ icon: tagPath+&#x27;images/icons/locationPin.svg&#x27; });
            }
        }

        if (!custom) {
            //make the right pushpin red
            pushpin.setOptions({ icon: tagPath+&#x27;images/icons/locationPin2.svg&#x27; });
        } else {
            //make the right pushpin red
            pushpin &amp;&amp; pushpin.attr(&#x27;src&#x27;, tagPath+&#x27;images/icons/locationPin2.svg&#x27;);
        }
    };

    /**
     * Built-in object extensions
     */

    // From JS: the good parts
    // Shortcut for adding a function to an object
    Function.prototype.method = function (name, func) {
        if (!this.prototype[name]) {
            this.prototype[name] = func;
            return this;
        }
    };

    // Curry a function
    Function.method(&#x27;curry&#x27;, function () {
        var slice = Array.prototype.slice,
            args = slice.apply(arguments),
            that = this;
        return function () {
            return that.apply(null, args.concat(slice.apply(arguments)));
        };
    });

    /**
     * If specified object is in the array, remove it
     * @param obj   object to be removed
     */
    Array.method(&#x27;remove&#x27;, function (obj) {
        var i = this.indexOf(obj);
        if (i !== -1) {
            this.splice(i, 1);
            return true;
        } else {
            return false;
        }
    });

    /**
     * Insert object into array based on comparator fn given
     * Assumes array is already sorted!
     * @param obj       Object to be inserted
     * @param comp      Function used to compare objects; obj will be inserted when comp evaluates to true; takes two args, first is current array elt, second is obj
     * @returns         Index of obj in array after insertion
     */
    Array.method(&#x27;insert&#x27;, function (obj, comp) {
        var i;
        for (i = 0; i &lt; this.length; i++) {
            if (comp(this[i], obj)) {
                this.splice(i, 0, obj);
                return i;
            }
        }
        this.push(obj);
        return this.length - 1;
    });

    /**
     * Constrain a number to given range
     * @param num   value to constrain
     * @param min   minimum limit
     * @param max   maximum limit
     */
    if (!Math.constrain) {
        Math.constrain = function (num, min, max) {
            return Math.min(max, Math.max(min, num));
        };
    }
}


/**
 * Utils for the artwork viewer and the artwork editor
 * @class TAG.Util.Artwork
 */
TAG.Util.Artwork = (function () {
    &quot;use strict&quot;;

    return {
        createThumbnailButton: createThumbnailButton
    };

    /**
     * Creates a thumbnail button to be used in a side bar list
     * @method createThumbnailButton
     * @param {Object} options      options for creating the thumbnail button:
     *            title         title of the button, shown under the thumbnail
     *            handler       a click handler for the button
     *            buttonClass   an extra class to add to the button
     *            buttonID      an id to give to the button
     *            src           thumbnail image source
     *            width         custom width of button
     *            height        custom height of button
     * @return {jQuery obj}      the button
     */
    function createThumbnailButton(options) {
        options = options || {};

        var title       = options.title,
            handler     = options.handler,
            buttonClass = options.buttonClass,
            buttonID    = options.buttonID,
            src         = options.src,
            width       = options.width,
            height      = options.height || 0.15 * $(&#x27;#tagRoot&#x27;).height() + &#x27;px&#x27;,
            holder               = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;thumbnailButton&#x27;),
            thumbHolderDiv       = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;thumbnailHolderDiv&#x27;),
            holderContainer      = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;thumbnailButtonContainer&#x27;),
            holderInnerContainer = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;thumbnailButtonInnerContainer&#x27;),
            thumbnailImage       = $(document.createElement(&#x27;img&#x27;)).addClass(&#x27;thumbnailButtonImage&#x27;),
            titleDiv             = $(document.createElement(&#x27;div&#x27;)).addClass(&#x27;thumbnailButtonTitle&#x27;);

        /********************************************\

        ----------------------------------------------
        |                                            |  &lt;--- holder
        | ------------------------------------------ |
        | |                                        | |
        | |                                        | |
        | |                                        | &lt;------ thumbHolderDiv
        | |                                        | |
        | |              THUMBNAIL                 | |
        | |                IMAGE                   | |
        | |                 HERE                  &lt;--------- thumbnailImage
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | |                                        | |
        | ------------------------------------------ |
        | ------------------------------------------ |
        | |             NAME OF DOQ                | &lt;--- titleDiv
        | |                                        | |
        | ------------------------------------------ |
        ----------------------------------------------

        \********************************************/

        
        buttonClass &amp;&amp; holder.addClass(buttonClass);
        holder.css(&#x27;height&#x27;, height);
        buttonID &amp;&amp; holder.attr(&#x27;id&#x27;, buttonID);

        holder.on(&quot;click&quot;, handler);

        holder.append(thumbHolderDiv);
        thumbHolderDiv.append(holderContainer);
        holderContainer.append(holderInnerContainer);

        thumbnailImage.attr(&#x27;src&#x27;, src);

        thumbnailImage.removeAttr(&#x27;width&#x27;);
        thumbnailImage.removeAttr(&#x27;height&#x27;);

        thumbnailImage.css({ // TODO fix this
            &#x27;max-height&#x27;: 0.15 * 0.7 * $(&quot;#tagRoot&quot;).height() + &quot;px&quot;,
            &#x27;max-width&#x27;: 0.22 * 0.89 * 0.95 * 0.40 * 0.92 * $(&quot;#tagRoot&quot;).width() + &quot;px&quot;
        });

        holderInnerContainer.append(thumbnailImage);

        titleDiv.text(title);
        holder.append(titleDiv);

        return holder;
    }
})();

/**
 * Built-in object extensions
 */

// From JS: the good parts
// Shortcut for adding a function to an object
Function.prototype.method = function (name, func) {
    if (!this.prototype[name]) {
        this.prototype[name] = func;
        return this;
    }
};

// Curry a function
Function.method(&#x27;curry&#x27;, function () {
    var slice = Array.prototype.slice,
        args = slice.apply(arguments),
        that = this;
    return function () {
        return that.apply(null, args.concat(slice.apply(arguments)));
    };
});

/**
 * If specified object is in the array, remove it
 * @param obj   object to be removed
 */
Array.method(&#x27;remove&#x27;, function (obj) {
    var i = this.indexOf(obj);
    if (i !== -1) {
        this.splice(i, 1);
        return true;
    } else {
        return false;
    }
});

/**
 * Insert object into array based on comparator fn given
 * Assumes array is already sorted!
 * @param obj       Object to be inserted
 * @param comp      Function used to compare objects; obj will be inserted when comp evaluates to true; takes two args, first is current array elt, second is obj
 * @returns         Index of obj in array after insertion
 */
Array.method(&#x27;insert&#x27;, function (obj, comp) {
    var i;
    for (i = 0; i &lt; this.length; i++) {
        if (comp(this[i], obj)) {
            this.splice(i, 0, obj);
            return i;
        }
    }
    this.push(obj);
    return this.length - 1;
});

/**
 * Constrain a number to given range
 * @param num   value to constrain
 * @param min   minimum limit
 * @param max   maximum limit
 */
if (!Math.constrain) {
    Math.constrain = function (num, min, max) {
        return Math.min(max, Math.max(min, num));
    };
}

/**
 * Defining a to-two-decimal-places function in Math
 * @method Math.twoDecPlaces
 * @param {Number} x             the number to convert to two decimal places
 * @return {Number}              x chopped at two decimal places
 */
Math.twoDecPlaces = function (x) {
    return Math.floor(x * 100) / 100;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
