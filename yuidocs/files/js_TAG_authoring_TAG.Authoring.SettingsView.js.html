<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js/TAG/authoring/TAG.Authoring.SettingsView.js - Touch Art Gallery web application</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../images/WideLogo.scale-100.png" title="Touch Art Gallery web application"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/TAG.AnnotatedImage.html">TAG.AnnotatedImage</a></li>
            
                <li><a href="../classes/TAG.Authoring.EditorMenu.html">TAG.Authoring.EditorMenu</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkEditor.html">TAG.Layout.ArtworkEditor</a></li>
            
                <li><a href="../classes/TAG.Layout.ArtworkViewer.html">TAG.Layout.ArtworkViewer</a></li>
            
                <li><a href="../classes/TAG.Layout.CollectionsPage.html">TAG.Layout.CollectionsPage</a></li>
            
                <li><a href="../classes/TAG.Layout.InternetFailurePage.js.html">TAG.Layout.InternetFailurePage.js</a></li>
            
                <li><a href="../classes/TAG.Layout.StartPage.html">TAG.Layout.StartPage</a></li>
            
                <li><a href="../classes/TAG.Layout.VideoPlayer.html">TAG.Layout.VideoPlayer</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ArtworkTrack.html">TAG.TourAuthoring.ArtworkTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.AudioTrack.html">TAG.TourAuthoring.AudioTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Command.html">TAG.TourAuthoring.Command</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ComponentControls.html">TAG.TourAuthoring.ComponentControls</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Display.html">TAG.TourAuthoring.Display</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.ImageTrack.html">TAG.TourAuthoring.ImageTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.InkAuthoring.html">TAG.TourAuthoring.InkAuthoring</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.InkTrack.html">TAG.TourAuthoring.InkTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Keyframe.html">TAG.TourAuthoring.Keyframe</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.PlaybackControl.html">TAG.TourAuthoring.PlaybackControl</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Timeline.html">TAG.TourAuthoring.Timeline</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TimeManager.html">TAG.TourAuthoring.TimeManager</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TopMenu.html">TAG.TourAuthoring.TopMenu</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.TourOptions.html">TAG.TourAuthoring.TourOptions</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Track.html">TAG.TourAuthoring.Track</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.UndoManager.html">TAG.TourAuthoring.UndoManager</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.VideoTrack.html">TAG.TourAuthoring.VideoTrack</a></li>
            
                <li><a href="../classes/TAG.TourAuthoring.Viewer.html">TAG.TourAuthoring.Viewer</a></li>
            
                <li><a href="../classes/TAG.Util.Artwork.html">TAG.Util.Artwork</a></li>
            
                <li><a href="../classes/TAG.Util.IdleTimer.html">TAG.Util.IdleTimer</a></li>
            
                <li><a href="../classes/TAG.Util.Splitscreen.html">TAG.Util.Splitscreen</a></li>
            
                <li><a href="../classes/tagInk.html">tagInk</a></li>
            
                <li><a href="../classes/Telemetry.html">Telemetry</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js/TAG/authoring/TAG.Authoring.SettingsView.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿TAG.Util.makeNamespace(&quot;TAG.Authoring.SettingsView&quot;);

/*  Creates a SettingsView, which is the first UI in authoring mode.  
 *  @class TAG.Authoring.SettingsView
 *  @constructor
    TODO- change parameters to options object
 *  @param startView sets the starting setting.  This can be &quot;Exhibitions&quot;, &quot;Artworks&quot;, &quot;Tours&quot;, 
 *       or &quot;General Settings&quot;.  Undefined/null, etc. goes to General Settings.
 *       TODO: Use constants instead of strings
 *   @param {Function} callback  called after the UI is done being created.
 *   @param {Function} backPage is a function to create the page to go back to (null/undefined goes
 *      back to the main page).  This function, when called with no arguments,
 *      should return a dom element that can be provided as an argument to 
 *      slidePageRight.
 *   @param startLabelID selects a middle label automatically if it matches that id.
 *      The label will be scrolled to if it is off screen
 *   @return {Object} public methods and variables
 */
TAG.Authoring.SettingsView = function (startView, callback, backPage, startLabelID) {
    &quot;use strict&quot;;
   
     
    var root = TAG.Util.getHtmlAjax(&#x27;../tagcore/html/SettingsView.html&#x27;), //Get html from html file

        //get all of the ui elements from the root and save them in variables
        middleLoading = root.find(&#x27;#setViewLoadingCircle&#x27;),
        settingsContainer = root.find(&#x27;#setViewSettingsContainer&#x27;),
        searchContainer = root.find(&#x27;#setViewSearchContainer&#x27;),
        navBar = root.find(&#x27;#setViewNavBar&#x27;),
        searchbar = root.find(&#x27;#setViewSearchBar&#x27;),
        newButton = root.find(&#x27;#setViewNewButton&#x27;),
        secondaryButton = root.find(&#x27;#setViewSecondaryButton&#x27;),
        middlebar = root.find(&#x27;#setViewMiddleBar&#x27;),
        middleLabelContainer = root.find(&#x27;#setViewMiddleLabelContainer&#x27;),
        rightbar = root.find(&#x27;#setViewRightBar&#x27;),
        viewer = root.find(&#x27;#setViewViewer&#x27;),
        buttonContainer = root.find(&#x27;#setViewButtonContainer&#x27;),
        settings = root.find(&#x27;#setViewSettingsBar&#x27;),
        label = root.find(&#x27;#setViewLoadingLabel&#x27;),
        circle = root.find(&#x27;#setViewLoadingCircle&#x27;),
        rootContainer = root.find(&#x27;#setViewRoot&#x27;),
        iframeAssetCreateButton = root.find(&#x27;#iframeAssetCreateButton&#x27;),

        // Constants
        VIEWER_ASPECTRATIO = $(window).width() / $(window).height(),
        //Should probably get rid of any hard-coded values here:
        RIGHT_WIDTH = &#x27;54&#x27;, 
        CONTENT_HEIGHT = &#x27;92&#x27;,
        HIGHLIGHT = &#x27;white&#x27;,
        BUTTON_HEIGHT = &#x27;40&#x27;,
        DEFAULT_SEARCH_TEXT = &#x27;Search...&#x27;,
        PICKER_SEARCH_TEXT = &#x27;Search by Name, Artist, or Year...&#x27;,

        // Text for Navagation labels
        NAV_TEXT = {
            general: {
                text: &#x27;General Settings&#x27;,
                subtext: &#x27;Customize TAG experience&#x27;
            },
            exhib: {
                text: &#x27;Collections&#x27;,
                subtext: &#x27;Create and edit collections&#x27;
            },
            art: {
                text: &#x27;Artworks&#x27;,
                subtext: &#x27;Import and manage artworks&#x27;
            },
            media: {
                text: &#x27;Associated Media&#x27;,
                subtext: &#x27;Manage associated media&#x27;
            },
            tour: {
                text: &#x27;Tours&#x27;,
                subtext: &#x27;Build interactive tours&#x27;
            },
            feedback: {
                text: &#x27;Feedback&#x27;,
                subtext: &#x27;View comments and reports&#x27;
            },
        },

        that = {
            getRoot: getRoot,
        },

        //global vars for automatic saving
        currentMetadataHandler,
        saveQueue = LADS.Util.createQueue(),
        saveArray = [],
        previousIdentifier,
        changesHaveBeenMade = false,
        pCL = null, //keep track of progress circles
        pCircle2 = null,
        backButtonClicked = false,
        generalIsLoading = false,
        collectionsIsLoading = false,
        artworksIsLoading = false,
        associatedMediaIsLoading = false,
        toursIsLoading = false,
        generalProgressCircle = null,
        labelOne,
        labelTwo,

        settingsViewKeyHandler = {
            13: enterKeyHandlerSettingsView,
            46: deleteKeyHandlerSettingsView,
            40: downKeyHandlerSettingsView,
            38: upKeyHandlerSettingsView,
        },
    
        prevSelectedSetting,
        prevSelectedMiddleLabel,
        // These are &#x27;asynchronous&#x27; queues to perform tasks. These queues will process events in order, but asynchronously so
        // they can be completed in the &#x27;background&#x27;. Calling .add(fn) adds a function to the queue while .clear() clears the queue.  
        //Note that an in progress function will not be canceled by .clear().
        middleQueue = TAG.Util.createQueue(),  //used to add things to the middle label container
        rightQueue = TAG.Util.createQueue(), //used to add things to the right panel
        cancelLastSetting,
        artPickerOpen = false,
        nav = [],
        artworks = [],
        assetUploader,
        mediaMetadata = [],
        numFiles = 0,
        isUploading = false,
        isCreatingMedia = false,
        artworkAssociations = [], // entry i contains the artwork info for the ith associated media
        artworkList = [], // save artworks retrieved from the database
        mediaCheckedIDs = [], // artworks checked in associated media uploading
        mediaUncheckedIDs = [], // artworks unchecked in associated media uploading
        editArt, // enter artwork editor button
        artmodeList, // list of all artworks in a collection

        // key handling stuff
        deleteType,
        toDelete,
        currentList,
        currentIndex = 0,
        currentSelected,
		currentSelectedSetting,
		leftButton,
        popUpBoxVisible = false,

        // booleans
		inGeneralView = false,
        inCollectionsView = false,
        inArtworkView = false,
        inAssociatedView = false,
        inToursView = false,
        inFeedbackView = false;

        //window.addEventListener(&#x27;keydown&#x27;, keyHandler),
        TAG.Util.UI.initKeyHandler();
        TAG.Util.UI.getStack()[0] = settingsViewKeyHandler;

    loadHelper();
    if (callback) {
        callback(that);
    }
	   
    //an array to store video guids that need to be converted
    var conversionVideos = [];
	function checkConversion() {
        for (var i = 0; i &lt; conversionVideos.length; i++) {
            var artwork = conversionVideos[i];
            LADS.Worktop.Database.getConvertedVideoCheck(
                (function (i, artwork) {
                    return function (output) {
                        if (output!==&quot;&quot;||output !== &quot;False&quot;) {
                            console.log(&quot;converted: &quot;);
                            var element = $(document.getElementById(&quot;videoInPreview&quot;));
                            if (element &amp;&amp; element.attr(&quot;identifier&quot;) === output) {
                                reloadVideo(element);
                                conversionVideos.remove(artwork);
                            }
                        } else {
                            console.log(&quot;not converted: &quot;);
                        }
                    }
                })(i, artwork), null, conversionVideos[i]);
        }
	}

    setInterval(checkConversion, 1000 * 60);
	function reloadVideo(element) {
        var source = element.attr(&quot;src&quot;);
        if (element[0].children.length &lt; 3) {
            element.removeAttr(&quot;src&quot;);
            var sourceWithoutExtension = source.substring(0, source.lastIndexOf(&#x27;.&#x27;));
            var sourceMP4 = sourceWithoutExtension + &quot;.mp4&quot;;
            var sourceWEBM = sourceWithoutExtension + &quot;.webm&quot;;
            var sourceOGV = sourceWithoutExtension + &quot;.ogv&quot;;

            addSourceToVideo(element, sourceMP4, &#x27;video/mp4&#x27;);
            addSourceToVideo(element, sourceWEBM, &#x27;video/webm&#x27;);
            addSourceToVideo(element, sourceOGV, &#x27;video/ogv&#x27;);
        }
        $(document.getElementById(&quot;middleLoading&quot;)).remove();
        $(function () {
            $(&quot;#middleLoading&quot;).remove();
        })
        if($(&quot;#videoErrorMsg&quot;)){
            $(&quot;#videoErrorMsg&quot;).remove();
        }
        element.show();
        var video = document.getElementById(&quot;videoInPreview&quot;);
        video.load();
        video.play();
    }
    
    
    //an array to store video guids that need to be converted
    var conversionVideos = [];
    /**
    * check for conversion in interval
    */
    function checkConversion() {
        for (var i = 0; i &lt; conversionVideos.length; i++) {
            var artwork = conversionVideos[i];
            TAG.Worktop.Database.getConvertedVideoCheck(
                (function (i, artwork) {
                    return function (output) {
                        if (output !== &quot;&quot; &amp;&amp; output !== &quot;False&quot; &amp;&amp; output !== &quot;Error&quot;) {
                            console.log(&quot;converted: &quot;);
                            var element = $(document.getElementById(&quot;videoInPreview&quot;));
                            if (element &amp;&amp; element.attr(&quot;identifier&quot;) === output) {
                                reloadVideo(element);
                                conversionVideos.remove(artwork);
                            }
                        } else if (output === &quot;Error&quot;) {
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;There is an error occured when converting this video. Please try again&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            conversionVideos.remove(artwork);
                        }
                        else {
                            console.log(&quot;not converted: &quot;);
                        }
                    }
                })(i, artwork), null, conversionVideos[i]);
        }
    }
    setInterval(checkConversion, 1000 * 60);

    /** Reload the video when conversion is done
    * @ param: videoInPreview element
    */

    function reloadVideo(element) {
        var source = element.attr(&quot;src&quot;);
        if (element[0].children.length &lt; 3) {
            element.removeAttr(&quot;src&quot;);
            var sourceWithoutExtension = source.substring(0, source.lastIndexOf(&#x27;.&#x27;));
            var sourceMP4 = sourceWithoutExtension + &quot;.mp4&quot;;
            var sourceWEBM = sourceWithoutExtension + &quot;.webm&quot;;
            var sourceOGV = sourceWithoutExtension + &quot;.ogv&quot;;

            addSourceToVideo(element, sourceMP4, &#x27;video/mp4&#x27;);
            addSourceToVideo(element, sourceWEBM, &#x27;video/webm&#x27;);
            addSourceToVideo(element, sourceOGV, &#x27;video/ogv&#x27;);
        }
        $(document.getElementById(&quot;leftLoading&quot;)).remove();
        $(function () {
            $(&quot;#leftLoading&quot;).remove();
        })
        if ($(&quot;#videoErrorMsg&quot;)) {
            $(&quot;#videoErrorMsg&quot;).remove();
        }
        element.show();
        var video = document.getElementById(&quot;videoInPreview&quot;);
        video.load();
        video.play();
    }

    /**Handles enter key press on the SettingsView page
     * @ method enterKeyHandlerSettingsView
     */
    function enterKeyHandlerSettingsView() {
        if (!$(&quot;input, textarea&quot;).is(&quot;:focus&quot;)) {
            if (inCollectionsView) { manageCollection(currentList[currentIndex]);  }
            if (inArtworkView) { editArtwork(currentList[currentIndex]);  }
            if (inAssociatedView) { assocToArtworks(currentList[currentIndex]); }
            if (inToursView) { editTour(currentList[currentIndex]); }
            if (inFeedbackView) { deleteFeedback(currentList[currentIndex]); }
        }
    }

    /**Handles delete key press on the SettingsView page
     * @ method deleteKeyHandlerSettingsView
     */
    function deleteKeyHandlerSettingsView() {
        if (!$(&quot;input, textarea&quot;).is(&quot;:focus&quot;)) {
            deleteType(toDelete);
        }
    }

    /**Handles up key press on the SettingsView page
     * @ method upKeyHandlerSettingsView
     */
    function upKeyHandlerSettingsView() {
        if (!$(&quot;input, textarea&quot;).is(&quot;:focus&quot;)) {
            if (prevSelectedMiddleLabel &amp;&amp; prevSelectedMiddleLabel === currentSelected) {
                if (currentSelected.prev()) {
                    if (currentIndex &gt; 0) {
                        resetLabels(&#x27;.middleLabel&#x27;);
                        selectLabel(currentSelected.prev());
                        currentSelected = currentSelected.prev();
                        prevSelectedMiddleLabel = currentSelected;
                        currentIndex--;
                        

                        if (inCollectionsView) { 
                            loadExhibition(currentList[currentIndex]); 
                        }
                        if (inArtworkView) { 
                            loadArtwork(currentList[currentIndex]); 
                        }
                        if (inAssociatedView) { 
                            loadAssocMedia(currentList[currentIndex]); 
                        }
                        if (inToursView) { 
                            loadTour(currentList[currentIndex]); 
                        }
                        if (inFeedbackView) {
                            loadFeedback(currentList[currentIndex]); 
                        }
                    }
                }
            }
			if (inGeneralView) {
                if (currentSelected === labelTwo) {
                    resetLabels(&#x27;.leftLabel&#x27;);
                    selectLabel(labelOne);
                    currentSelected = labelOne;
                    loadCustomization();
                }
            }
        }
    }

    /**Handles the down arrow key press on the SettingsViewPage
     * @method downKeyHandlerSettingsView
     */
    function downKeyHandlerSettingsView() {
        
        if (!$(&quot;input, textarea&quot;).is(&quot;:focus&quot;)) {
            if (prevSelectedMiddleLabel &amp;&amp; prevSelectedMiddleLabel === currentSelected) {
                if (currentSelected.next()) {
                    if(currentIndex &lt; (currentList.length - 1)) {
                        resetLabels(&#x27;.middleLabel&#x27;);
                        selectLabel(currentSelected.next());
                        currentSelected = currentSelected.next();
                        prevSelectedMiddleLabel = currentSelected;
                        currentIndex++;
                        
                        if (inCollectionsView) { 
                            loadExhibition(currentList[currentIndex]); 
                        }
                        if (inArtworkView) { 
                            loadArtwork(currentList[currentIndex]); 
                        }
                        if (inAssociatedView) { 
                            loadAssocMedia(currentList[currentIndex]); }
                        if (inToursView) { loadTour(currentList[currentIndex]); 
                        }
                        if (inFeedbackView) { 
                            loadFeedback(currentList[currentIndex]); 
                        }
                    }
                }
            }
			if (inGeneralView) {
                if (currentSelected === labelOne) {
                    resetLabels(&#x27;.leftLabel&#x27;);
                    selectLabel(labelTwo);
                    currentSelected = labelTwo;
                    loadPasswordScreen();
                }
            }
        }
    }

   

    /**
     * Helper function to set up UI elements and switch to first view
     * @method loadHelper
     * @param {Object} main  
     */
    function loadHelper(main){

        //Setting up UI:
        var backButton = root.find(&#x27;#setViewBackButton&#x27;);
        backButton.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/Back.svg&#x27;);

        backButton.mousedown(function () {
            TAG.Util.UI.cgBackColor(&quot;backButton&quot;, backButton, false);
        });

        backButton.mouseleave(function () {
            TAG.Util.UI.cgBackColor(&quot;backButton&quot;, backButton, true);
        });

        backButton.click(function () {
            TAG.Auth.clearToken();
            rightQueue.clear();
            middleQueue.clear();
            backButton.off(&#x27;click&#x27;);
            if (backPage) {
                var bpage = backPage();
                TAG.Util.UI.slidePageRight(bpage);
            } else {
                TAG.Layout.StartPage(null, function (page) {
                    TAG.Util.UI.slidePageRight(page);
                });
            }
            TAG.Util.UI.getStack()[0] = null;
            
        });

        iframeAssetCreateButton.on(&#x27;click&#x27;, function () { // TODO iframe -- change styling and location in styl and jade files
            createIframeSourceDialog();
        });

        var topBarLabel = root.find(&#x27;#setViewTopBarLabel&#x27;);
        var topBarLabelSpecs = TAG.Util.constrainAndPosition($(window).width(), $(window).height() * 0.08,
        {
            width: 0.4,
            height: 0.9,
        });
        topBarLabel.css({
            &#x27;height&#x27;: topBarLabelSpecs.height + &#x27;px&#x27;,
            &#x27;width&#x27;: topBarLabelSpecs.width + &#x27;px&#x27;,
        });
        var fontsize = TAG.Util.getMaxFontSizeEM(&#x27;Tour Authoring&#x27;, 0.5, topBarLabelSpecs.width, topBarLabelSpecs.height * 0.8, 0.1);
        topBarLabel.css({ &#x27;font-size&#x27;: fontsize });
        topBarLabel.text(&#x27;Authoring Mode&#x27;);

        //Add text to navigation bar:

        navBar.append(nav[NAV_TEXT.general.text] = createNavLabel(NAV_TEXT.general, loadGeneralView));
        navBar.append(nav[NAV_TEXT.exhib.text] = createNavLabel(NAV_TEXT.exhib, loadExhibitionsView));
        navBar.append(nav[NAV_TEXT.art.text] = createNavLabel(NAV_TEXT.art, loadArtView));
        navBar.append(nav[NAV_TEXT.media.text] = createNavLabel(NAV_TEXT.media, loadAssocMediaView)); // COMMENT!!!!!!!!
        navBar.append(nav[NAV_TEXT.tour.text] = createNavLabel(NAV_TEXT.tour, loadTourView));
        navBar.append(nav[NAV_TEXT.feedback.text] = createNavLabel(NAV_TEXT.feedback, loadFeedbackView));
        searchbar.keyup(function () {
            search(searchbar.val(), &#x27;.middleLabel&#x27;, &#x27;div&#x27;);
        });
        searchbar.change(function () {
            search(searchbar.val(), &#x27;.middleLabel&#x27;, &#x27;div&#x27;);
        });

        // Workaround for clear button (doesn&#x27;t fire a change event...)
        searchbar.mouseup(function () {
            setTimeout(function () {
                search(searchbar.val(), &#x27;.middleLabel&#x27;, &#x27;div&#x27;);
            }, 1);
        });
        
       // rootContainer.keydown(keyHandler);
        searchbar.attr(&#x27;placeholder&#x27;, &#x27;Search...&#x27;);
        newButton.text(&#x27;New&#x27;);
        secondaryButton.text(&#x27;Video&#x27;);
        label.text(&#x27;Loading...&#x27;);
        circle.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/progress-circle.gif&#x27;);

        viewer.css({
            &#x27;height&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
        });

        buttonContainer.css({
            &#x27;top&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
        });
        settings.css({
            &#x27;height&#x27;: getSettingsHeight() + &#x27;px&#x27;,
        });
        switchView(startView, startLabelID);
    }
    
    /**Switches the view based on selected navigation label
     * @method switchView
     * @param {String} view         the view to switch to
     * @param {Object} id           the id of the middle label to start on
     */
    function switchView(view, id) {
        resetLabels(&#x27;.navContainer&#x27;);
        switch (view) {
            case &quot;Exhibitions&quot;:
                selectLabel(nav[NAV_TEXT.exhib.text]);
                prevSelectedSetting = nav[NAV_TEXT.exhib.text];
                loadExhibitionsView(id);
                break;
            case &quot;Artworks&quot;:
                selectLabel(nav[NAV_TEXT.art.text]);
                prevSelectedSetting = nav[NAV_TEXT.art.text];
                loadArtView(id);
                break;
            case &quot;Associated Media&quot;: 
                selectLabel(nav[NAV_TEXT.media.text]);
                prevSelectedSetting = nav[NAV_TEXT.media.text];
                loadAssocMediaView(id);
                break;
            case &quot;Tours&quot;:
                
                selectLabel(nav[NAV_TEXT.tour.text]);
                prevSelectedSetting = nav[NAV_TEXT.tour.text];
                loadTourView(id);
                break;
            case &quot;Feedback&quot;:
                selectLabel(nav[NAV_TEXT.feedback.text]);
                prevSelectedSetting = nav[NAV_TEXT.feedback.text];
                loadFeedbackView(id);
                break;
            case &quot;General Settings&quot;:
            default:
                selectLabel(nav[NAV_TEXT.general.text]);
                prevSelectedSetting = nav[NAV_TEXT.general.text];
                loadGeneralView();
                break;
        }
    }

    /**Returns root
     * @method getRoot
     * @return {Object} root 
     */
    function getRoot() {
        return root;
    }

    // Navigation Bar Functions:

     /**Create a navigation label
     * @method createNavLabel
     * @param {String} text         text for label
     * @param {Function} onclick    onclick function for label
     * @return {Object} container   container containing new label
     */
    function createNavLabel(text, onclick) {
        var container = $(document.createElement(&#x27;div&#x27;));
        container.attr(&#x27;class&#x27;, &#x27;navContainer&#x27;);
        container.attr(&#x27;id&#x27;, &#x27;nav-&#x27; + text.text);
        container.mousedown(function () {
            container.css({
                &#x27;background&#x27;: HIGHLIGHT
            });
        });
        container.mouseup(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.mouseleave(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.click(function () {
            // If a label is clicked return if its already selected.
            if (prevSelectedSetting === container)
                return;
            // Reset all labels and then select this one
            resetLabels(&#x27;.navContainer&#x27;);
            selectLabel(container);
            // Do the onclick function
            if (onclick) {
                onclick();
            }
            prevSelectedSetting = container;
        });

        var navtext = $(document.createElement(&#x27;label&#x27;));
        navtext.attr(&#x27;class&#x27;,&#x27;navtext&#x27;);
        navtext.text(text.text);

        var navsubtext = $(document.createElement(&#x27;label&#x27;));
        navsubtext.attr(&#x27;class&#x27;,&#x27;navsubtext&#x27;);
        navsubtext.text(text.subtext);

        container.append(navtext);
        container.append(navsubtext);
        return container;
    }

    // General Settings Functions:

    /**Loads the General Settings view
     * @method loadGeneralView
     */
    function loadGeneralView() {
        prepareNextView(false);

		inGeneralView = true;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;
        // Add this to our queue so the UI doesn&#x27;t lock up
        middleQueue.add(function () {
            var label;
            // Add the Splash Screen label and set it as previously selected because its our default
            middleLoading.before(label = selectLabel(createMiddleLabel(&#x27;Splash Screen&#x27;, null, loadSplashScreen), true));
            prevSelectedMiddleLabel = label;
            // Default to loading the splash screen
            loadSplashScreen();
            // Add the Password Settings label
            middleLoading.before(createMiddleLabel(&#x27;Password Settings&#x27;, null, loadPasswordScreen).attr(&#x27;id&#x27;, &#x27;password&#x27;));
            middleLoading.hide();
        });
        cancelLastSetting = null;
    }

    // Fixes volume far for video/audio
    function fixVolumeBar(mediaElement) {
        var media = mediaElement[0];
        var lastVolume = media.volume;
        var muted = false;
        media.addEventListener(&#x27;volumechange&#x27;, function () {
            if (media.muted) {
                media.volume = 0;
                muted = true;
            }
            else {
                if (muted) {
                    media.volume = lastVolume;
                    muted = false;
                }
                lastVolume = media.volume;
            }
        }, false);
    }

    /**Sets up the right side of the UI for the splash screen
     * including the viewer, buttons, and settings container.
     * @method loadSplashScreen
     */
     /*
      * TODO: refactor this to be loadCustomization(), so it is extensible to have previews
      * for the collections and artwork viewer pages too.
      */
    function loadSplashScreen() {
        prepareViewer(true);
        clearRight();

        // Load the start page, the callback will add it to the viewer when its done
		if (generalIsLoading) {
            generalProgressCircle = displayLoadingSettings();
        } else {
            generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        }
        var startPage = previewStartPage();

        // Get DB Values
        var alpha = TAG.Worktop.Database.getMuseumOverlayTransparency();
        var overlayColor = TAG.Worktop.Database.getMuseumOverlayColor();
        var name = TAG.Worktop.Database.getMuseumName();
        var loc = TAG.Worktop.Database.getMuseumLoc();
        var info = TAG.Worktop.Database.getMuseumInfo();
        if (name === undefined) {
            name = &quot;&quot;;
        }
        if (loc === undefined) {
            loc = &quot;&quot;;
        }
        if (info === undefined) {
            info = &quot;&quot;;
        }
        var logoColor = TAG.Worktop.Database.getLogoBackgroundColor();
        var backgroundColor = TAG.Worktop.Database.getBackgroundColor();
        var backgroundOpacity = TAG.Worktop.Database.getBackgroundOpacity();
        var primaryFontColor = TAG.Worktop.Database.getPrimaryFontColor();
        var secondaryFontColor = TAG.Worktop.Database.getSecondaryFontColor();
        var fontFamily = TAG.Worktop.Database.getFontFamily();

        // Create inputs
        var alphaInput = createTextInput(Math.floor(alpha * 100), true);
        var bgImgInput = createButton(&#x27;Change Image&#x27;, function () {
            changesHaveBeenMade = true;
			uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                bgImgInput.val(url);
                $(&#x27;#background&#x27;).css({
                    &#x27;background-image&#x27;: &#x27;url(&quot;&#x27; + TAG.Worktop.Database.fixPath(url) + &#x27;&quot;)&#x27;,
                    &#x27;background-size&#x27;: &#x27;cover&#x27;,
                });
            });
        });
        var logoInput = createButton(&#x27;Change Logo&#x27;, function () {
            changesHaveBeenMade = true;
			uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                var url = urls[0];
                logoInput.val(url);
                $(&#x27;#logo&#x27;)[0].src = TAG.Worktop.Database.fixPath(url);
            });
        });
        var overlayColorInput = createBGColorInput(overlayColor, &#x27;.infoDiv&#x27;, null, function () { return alphaInput.val(); });
        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(name), true, 40);
        var locInput = createTextInput(TAG.Util.htmlEntityDecode(loc), true, 45);
        var infoInput = createTextAreaInput(TAG.Util.htmlEntityDecode(info), true);
        var logoColorInput = createBGColorInput(logoColor, &#x27;.logoContainer&#x27;, null, function () { return 100; });
        var backgroundColorInput = createBGColorInput(backgroundColor, &#x27;.background&#x27;, null, function() { return backgroundOpacityInput.val(); });
        var backgroundOpacityInput = createTextInput(backgroundOpacity, true);
        var primaryFontColorInput = createBGColorInput(primaryFontColor, null, &#x27;.primaryFont&#x27;, function() { return 100; });
        var secondaryFontColorInput = createBGColorInput(secondaryFontColor, null, &#x27;.secondaryFont&#x27;, function() { return 100; });
        var fontFamilyInput = createSelectInput([&#x27;Arial&#x27;, &#x27;Calibri&#x27;, &#x27;Comic Sans MS&#x27;, &#x27;Courier New&#x27;, &#x27;Franklin Gothic&#x27;, &#x27;Lobster&#x27;, &#x27;Pacifico&#x27;, &#x27;Raavi&#x27;, &#x27;Segoe Print&#x27;, &#x27;Segoe UI Light&#x27;, &#x27;Source Sans Pro&#x27;, &#x27;Times New Roman&#x27;, &#x27;Trebuchet MS&#x27;, &#x27;Verdana&#x27;], TAG.Worktop.Database.getFontFamily);
        

        // Handle changes
        onChangeUpdateNum(alphaInput, 0, 100, function (num) {
            updateBGColor(&#x27;.infoDiv&#x27;, overlayColorInput.val(), num);
        });
        onChangeUpdateText(nameInput, &#x27;#museumName&#x27;, 40);
        nameInput.keyup(function () {
            startPage.fixText();
        });
        nameInput.keydown(function () {
            startPage.fixText();
        });var museumLoc
        nameInput.change(function () {
            startPage.fixText();
        });
        onChangeUpdateText(locInput, &#x27;#subheading&#x27;, 33);
        onChangeUpdateText(infoInput, &#x27;#museumInfo&#x27;, 300);
        onChangeUpdateNum(backgroundOpacityInput, 0, 100, function(num) {
            updateBGColor(&#x27;.background&#x27;, backgroundColorInput.val(), num);
        })

        var bgImage = createSetting(&#x27;Background Image&#x27;, bgImgInput);
        var overlayAlpha = createSetting(&#x27;Overlay Transparency (0-100)&#x27;, alphaInput);
        var overlayColorSetting = createSetting(&#x27;Overlay Color&#x27;, overlayColorInput);
        var museumName = createSetting(&#x27;Museum Name&#x27;, nameInput);
        var museumLoc = createSetting(&#x27;Museum Location&#x27;, locInput);
        var museumInfo = createSetting(&#x27;Museum Info&#x27;, infoInput);
        var museumLogo = createSetting(&#x27;Museum Logo&#x27;, logoInput);
        var logoColorSetting = createSetting(&#x27;Museum Logo Background Color&#x27;, logoColorInput);
        var backgroundColorSetting = createSetting(&#x27;Background Color&#x27;, backgroundColorInput);
        var backgroundOpacitySetting = createSetting(&#x27;Background Opacity (0-100)&#x27;, backgroundOpacityInput);
        var primaryFontColorSetting = createSetting(&#x27;Primary Font Color&#x27;, primaryFontColorInput);
        var secondaryFontColorSetting = createSetting(&#x27;Secondary Font Color&#x27;, secondaryFontColorInput);
        var fontFamilySetting = createSetting(&#x27;Font Family&#x27;, fontFamilyInput);

        settingsContainer.append(bgImage);
        settingsContainer.append(overlayColorSetting);
        settingsContainer.append(overlayAlpha);
        settingsContainer.append(museumName);
        settingsContainer.append(museumLoc);
        settingsContainer.append(museumInfo);
        settingsContainer.append(museumLogo);
        settingsContainer.append(logoColorSetting);
        settingsContainer.append(backgroundColorSetting);
        settingsContainer.append(backgroundOpacitySetting);
        settingsContainer.append(primaryFontColorSetting);
        settingsContainer.append(secondaryFontColorSetting);
        settingsContainer.append(fontFamilySetting);
		//automatically save General Settings - Customization

        currentMetadataHandler = function () {
            if (locInput === undefined) {
                locInput = &quot;&quot;;
            }
            if (infoInput === undefined) {
                infoInput = &quot;&quot;;
            }
            saveSplashScreen({
                alphaInput: alphaInput,                             //Overlay Transparency
                overlayColorInput: overlayColorInput,               //Overlay Color
                nameInput: nameInput,                               //Museum Name
                locInput: locInput,                                 //Museum Location
                infoInput: infoInput,                               //Museum Info
                logoColorInput: logoColorInput,                     //Logo background color
                bgImgInput: bgImgInput,                             //Background image
                logoInput: logoInput,                               //Logo image
                backgroundColorInput: backgroundColorInput,         //Background Color
                backgroundOpacityInput: backgroundOpacityInput,     //Background Opacity
                primaryFontColorInput: primaryFontColorInput,       //Primary Font Color
                secondaryFontColorInput: secondaryFontColorInput,   //Secondary Font Color
                fontFamilyInput: fontFamilyInput,
            });
        };

        // Save button
        var saveButton = createButton(&#x27;Save Changes&#x27;, function () {
            if (locInput === undefined) {
                locInput = &quot;&quot;;
            }
            if (infoInput === undefined) {
                infoInput = &quot;&quot;;
            }
            //save Splash screen and pass in inputs with following keys:
            saveSplashScreen({
                alphaInput: alphaInput,                             //Overlay Transparency
                overlayColorInput: overlayColorInput,               //Overlay Color
                nameInput: nameInput,                               //Museum Name
                locInput: locInput,                                 //Museum Location
                infoInput: infoInput,                               //Museum Info
                logoColorInput: logoColorInput,                     //Logo background color
                bgImgInput: bgImgInput,                             //Background image
                logoInput: logoInput,                               //Logo image
                backgroundColorInput: backgroundColorInput,         //Background Color
                backgroundOpacityInput: backgroundOpacityInput,     //Background Opacity
                primaryFontColorInput: primaryFontColorInput,       //Primary Font Color
                secondaryFontColorInput: secondaryFontColorInput,   //Secondary Font Color
                fontFamilyInput: fontFamilyInput,
            });
        }, {
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
            &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
            &#x27;float&#x27;: &#x27;right&#x27;
        });
        
        // preview buttons
        var previewStartPageButton = createButton(&#x27;Splash Screen&#x27;, previewStartPage, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        var previewCollectionsPageButton = createButton(&#x27;Collections Page&#x27;, previewCollectionsPage, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        var previewArtworkViewerButton = createButton(&#x27;Artwork Viewer&#x27;, previewArtworkViewer, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        buttonContainer.append(saveButton);
        buttonContainer.append(previewStartPageButton);
        buttonContainer.append(previewCollectionsPageButton);
        buttonContainer.append(previewArtworkViewerButton);
    }

    /**Saves the splash screen settings
     * @method saveSplashScreen
     * @param {Object} inputs       information from setting inputs
     */
    function saveSplashScreen(inputs) {
        backButtonClicked &amp;&amp; prepareNextView(false, null, null, &quot;Saving...&quot;);
		generalIsLoading = true;
        clearRight();
        //prepareViewer(true);

        var alpha = inputs.alphaInput.val()/100;
        var overlayColor = inputs.overlayColorInput.val();
        var name = inputs.nameInput.val();
        var loc = inputs.locInput.val();
        var info = inputs.infoInput.val().replace(&#x27;/\n\r?/g&#x27;, &#x27;&lt;br /&gt;&#x27;);
        var logoColor = inputs.logoColorInput.val();
        var bgImg = inputs.bgImgInput.val();
        var logo = inputs.logoInput.val();
        var backgroundColor = inputs.backgroundColorInput.val();
        var backgroundOpacity = inputs.backgroundOpacityInput.val();
        var primaryFontColor = inputs.primaryFontColorInput.val();
        var secondaryFontColor = inputs.secondaryFontColorInput.val();
        var fontFamily = inputs.fontFamilyInput.val();
        var baseFontSize = LADS.Util.getMaxFontSize(&#x27;Test&#x27;, 2, 100000000, 30, 0.1);

        var options = {
            Name: name,
            OverlayColor: overlayColor,
            OverlayTrans: alpha,
            Location: loc,
            Info: info,
            IconColor: logoColor,
            BackgroundColor: backgroundColor,
            BackgroundOpacity: backgroundOpacity,
            PrimaryFontColor: primaryFontColor,
            SecondaryFontColor: secondaryFontColor,
            FontFamily: fontFamily,
            BaseFontSize: baseFontSize,
        };
        if (bgImg) options.Background = bgImg;
        if (logo) options.Icon = logo;
        //Change the settings in the database
        TAG.Worktop.Database.changeMain(options, function () {
            generalIsLoading = false;
            if (!(generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don&#x27;t continue if more sections are still loading - wait for them to finish
                backButtonClicked &amp;&amp; backButtonClickHandler();
            };
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.general.text]) {
                LADS.Worktop.Database.getMain();
                return;
            };
            LADS.Worktop.Database.getMain(function () {
                if (!(prevSelectedLeftLabel &amp;&amp; (prevSelectedLeftLabel.text() === &quot;Password Settings&quot;))) {
                    loadGeneralView();
                };
            }, error(loadGeneralView), null);
        }, authError, conflict({ Name: &#x27;Main&#x27; }, &#x27;Update&#x27;, loadGeneralView), error(loadGeneralView));
    }

    /**Set up the right side of the UI for the  password changer
     * @method loadPasswordScreen
     */
    function loadPasswordScreen() {
        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        prepareViewer(false, null, false);
        clearRight();

        var loading = createLabel(&#x27;Loading...&#x27;);
        var loadingSetting = createSetting(&#x27;&#x27;, loading);
        settingsContainer.append(loadingSetting);

        TAG.Worktop.Database.checkSetting(&#x27;AllowChangePassword&#x27;, function (val) {
            loadingSetting.remove();
            if (val.toLowerCase() === &#x27;true&#x27;) {
                var oldInput = createTextInput(&#x27;&#x27;, false);
                var newInput1 = createTextInput(&#x27;&#x27;, false);
                var newInput2 = createTextInput(&#x27;&#x27;, false);
                var msgLabel = createLabel(&#x27;&#x27;);

                oldInput.attr(&#x27;type&#x27;, &#x27;password&#x27;);
                newInput1.attr(&#x27;type&#x27;, &#x27;password&#x27;);
                newInput2.attr(&#x27;type&#x27;, &#x27;password&#x27;);

                var old = createSetting(&#x27;Current Password&#x27;, oldInput);
                var new1 = createSetting(&#x27;New Password&#x27;, newInput1);
                var new2 = createSetting(&#x27;Confirm New Password&#x27;, newInput2);
                var msg = createSetting(&#x27;&#x27;, msgLabel);

                settingsContainer.append(old);
                settingsContainer.append(new1);
                settingsContainer.append(new2);
               

                //Hide or else unused div covers &#x27;Old Password&#x27; line
                buttonContainer.css(&#x27;display&#x27;, &#x27;none&#x27;);

                var saveButton = createButton(&#x27;Update Password&#x27;, function () {
                    savePassword({
                        old: oldInput,         // Old password
                        new1: newInput1,       // New password
                        new2: newInput2,       // New password confirmation
                        msg: msgLabel,         // Message area
                    });
                });
                // Make the save button respond to enter
                saveButton.removeAttr(&#x27;type&#x27;);
                var save = createSetting(&#x27;&#x27;, saveButton);
                settingsContainer.append(save);
                settingsContainer.append(msg);
            } else {
                passwordChangeNotSupported();
            }
        });
    }

    /**Display label if password change not supported by server
     *@method passwordChangeNotSupported
     */
    function passwordChangeNotSupported() {
        var label = createLabel(&#x27;&#x27;);
        var setting = createSetting(&#x27;Changing the password has been disabled by the server.  Contact the server administrator for more information&#x27;, label);
        settingsContainer.append(setting);
    }

    /**Updates the new password
     * @method savePassword
     * @param {Object} inputs    keys for password change
     */
    function savePassword(inputs) {
        inputs.msg.text(&#x27;Processing...&#x27;);
        if (inputs.new1.val() !== inputs.new2.val()) {
            inputs.msg.text(&#x27;New passwords do not match.&#x27;);
        } else {
            TAG.Auth.changePassword(inputs.old.val(), inputs.new1.val(),
                function () {
                    inputs.msg.text(&#x27;Password Saved.&#x27;);
                    inputs.old.val(&#x27;&#x27;);
                    inputs.new1.val(&#x27;&#x27;);
                    inputs.new2.val(&#x27;&#x27;);
                },
                function (msg) {
                    if (msg) {
                        inputs.msg.html(msg);
                    } else {
                        inputs.msg.text(&#x27;Incorrect Password.&#x27;);
                    }
                },
                function () {
                    inputs.msg.text(&#x27;There was an error contacting the server.&#x27;);
                });
        }
    }

    // PREVIEWS OF SPLASH SCREEN, COLLECTIONS PAGE, ARTOWRK VIEWER FOR CUSTOMIZATION

    /**Preview splash screen
     * @method previewStartPage
     */
    function previewStartPage() {
        // Load the start page, the callback adds it to the viewer when it&#x27;s done loading
        var startPage = TAG.Layout.StartPage(null, function(startPage) {
            if(prevSelectedSetting &amp;&amp; prevSelectedSetting != nav[NAV_TEXT.general.text]) {
                return;
            }
            viewer.empty();
            viewer.append(startPage);
            preventClickthrough(viewer);
        });
        return startPage;
    }

    /**Preview collections page
     * @method previewCollectionsPage
     */
    function previewCollectionsPage() {
        // Load the collections page, the callback adds it to the viewer when it&#x27;s done loading
        var collectionsPage = TAG.Layout.CollectionsPage(null, null, viewer);
        var croot = collectionsPage.getRoot();
        $(croot).css({ &#x27;z-index&#x27;: &#x27;1&#x27; });
        if(prevSelectedSetting &amp;&amp; prevSelectedSetting != nav[NAV_TEXT.general.text]) {
            return;
        }
        viewer.empty();
        viewer.append(croot);
        preventClickthrough(viewer);
    }

    /**Preview artwork viewer
     * @method previewArtworkViewer
     */
    function previewArtworkViewer() {
        // Load the artwork viewer, the callback adds it to the viewer when it&#x27;s done loading
        var artworkViewer = TAG.Layout.ArtworkViewer({ catalogState: {}, doq: artworkList[0] || null, split: &#x27;L&#x27; }, viewer);
        var aroot = artworkViewer.getRoot();
        $(aroot).css(&#x27;z-index&#x27;, &#x27;-1&#x27;);
        if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.general.text]) {
            return;
        }
        viewer.empty();
        viewer.append(aroot);
        // Don&#x27;t allow the viewer to be clicked
        preventClickthrough(viewer);
    }

    // Collection Functions:

    /**Loads the collections view
     * @method loadExhibitionsView
     * @param {Object} id       id of middle label to start on
     */
    function loadExhibitionsView(id) {
        var cancel = false;
        // Set the new button text to &quot;New&quot;
        prepareNextView(true, &quot;New&quot;, createExhibition);
        clearRight();
        prepareViewer(true);

        if (generalIsLoading || collectionsIsLoading ||
                 artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
            hideLoading();
            hideLoadingSettings(pCL);
        };

        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        collectionsIsLoading &amp;&amp; showLoading();
        (saveArray.indexOf(previousIdentifier) &lt; 0) &amp;&amp; function () { hideLoading(); hideLoadingSettings(pCL); };

        inGeneralView = false;
        inCollectionsView = true;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;

        // Make an async call to get the list of exhibitions
        TAG.Worktop.Database.getExhibitions(function (result) {
            if (cancel) {
                return;
            } 
            sortAZ(result);
            currentList = result;
            currentIndex = 0;
            
            $.each(result, function (i, val) {
                if (cancel) { 
                    return;
                }
                // Add each label as a separate function in the queue so they don&#x27;t lock up the UI
                middleQueue.add(function () {
                    if (cancel) {
                        return;
                    }
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedMiddleLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        
                        // Select the first one or the specified id
                        middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, null, function () {
                            previousIdentifier = val.Identifier;
                            loadExhibition(val);
                            currentIndex = i;
                        }, val.Identifier), true));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (middlebar.scrollTop() === 0 &amp;&amp; label.offset().top - middlebar.height() &gt; 0) {
                            middlebar.animate({
                                scrollTop: (label.offset().top - middlebar.height())
                            }, 1000);
                        }
                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        currentIndex = i;
                        loadExhibition(val);
                    } else {
                        middleLoading.before(label = createMiddleLabel(val.Name, null, function () {
                            if (changesHaveBeenMade) {
                                saveArray.push(previousIdentifier);
                                currentMetadataHandler &amp;&amp; saveQueue.add(currentMetadataHandler());
                                changesHaveBeenMade = false;
                            } else {
                                loadExhibition(val); //immediately loading the next exhibition that has been clicked on if no changes have been made
                                //otherwise the next exhibition is loaded when saving is complete
                            };
                            previousIdentifier = val.Identifier;
                            currentIndex = i;
                        }, val.Identifier));
                        //prevSelectedMiddleLabel = label;
                        //currentSelected = prevSelectedMiddleLabel;
                    }
                    // Hide the label if it doesn&#x27;t match the current search criteria
                    if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    //CLICK HANDLER FOR SORT OPTIONS
    function clickCallback(sortDiv) {
        return function () {
            if (sortDiv.attr(&quot;setSort&quot;) == &quot;true&quot; || sortDiv.attr(&quot;setSort&quot;) == true) {
                sortDiv.attr(&quot;setSort&quot;, false);
                sortDiv.css({
                    &quot;background-color&quot;: &quot;white&quot;,
                    &quot;color&quot;: &quot;black&quot;,
                    &quot;border&quot;: &quot;2px solid black&quot;
                });
            } else {
                sortDiv.attr(&quot;setSort&quot;, true);
                sortDiv.css({
                    &quot;background-color&quot;: &quot;#0040FF&quot;,
                    &quot;color&quot;: &quot;white&quot;,
                    &quot;border&quot;: &quot;2px solid white&quot;
                });
            }
        };
    };

    //CREATE SORT OPTIONS DIV
    function createSortOptions(sortOptions) {
        var sortOptionsDiv = $(document.createElement(&quot;div&quot;))
            .css({
                &#x27;width&#x27;: &quot;50%&quot;,
                &quot;height&quot;: &quot;100px&quot;,
                &#x27;float&#x27;: &#x27;right&#x27;,
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &quot;overflow&quot;: &quot;scroll&quot;,
                &quot;overflow-x&quot;: &quot;hidden&quot;
            });


        var sortObj, sortDiv;

        if (sortOptions) {
            for (sortObj in sortOptions) {
                if (sortObj !== &quot;InfoFields&quot; &amp;&amp; sortOptions.hasOwnProperty(sortObj)) {
                    sortDiv = $(document.createElement(&quot;div&quot;))
                                .text(sortObj)
                                .css({
                                    &quot;width&quot;: &quot;90%&quot;,
                                    &#x27;font-size&#x27;: INPUT_FONTSIZE,
                                    &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
                                    &quot;border&quot;: &quot;2px solid black&quot;,
                                    &quot;background-color&quot;: &quot;white&quot;,
                                    &quot;margin-bottom&quot;: &quot;1%&quot;,
                                    &quot;text-align&quot;: &quot;center&quot;,
                                    &quot;color&quot;: &quot;black&quot;,
                                    &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;
                                });
                    sortDiv.attr(&quot;setSort&quot;, false);
                    if ((sortOptions[sortObj]) == true || (sortOptions[sortObj]) == &quot;true&quot;) {
                        sortDiv.css({
                            &quot;background-color&quot;: &quot;#0040FF&quot;,
                            &quot;color&quot;: &quot;white&quot;,
                            &quot;border&quot;: &quot;2px solid white&quot;
                        });
                        sortDiv.attr(&quot;setSort&quot;, true);
                    }

                    sortDiv.click(clickCallback(sortDiv));
                    sortOptionsDiv.append(sortDiv);
                }
            }
            for (sortObj in sortOptions.InfoFields) {
                if (sortOptions.InfoFields.hasOwnProperty(sortObj)) {
                    sortDiv = $(document.createElement(&quot;div&quot;))
                                .text(sortObj)
                                .css({
                                    &quot;width&quot;: &quot;90%&quot;,
                                    &#x27;font-size&#x27;: INPUT_FONTSIZE,
                                    &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
                                    &quot;border&quot;: &quot;2px solid black&quot;,
                                    &quot;background-color&quot;: &quot;white&quot;,
                                    &quot;margin-bottom&quot;: &quot;1%&quot;,
                                    &quot;text-align&quot;: &quot;center&quot;,
                                    &quot;color&quot;: &quot;black&quot;,
                                    &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;
                                });
                    sortDiv.attr(&quot;setSort&quot;, false);
                    if ((sortOptions.InfoFields[sortObj])[1] == true || (sortOptions.InfoFields[sortObj])[1] == &quot;true&quot;) {
                        sortDiv.css({
                            &quot;background-color&quot;: &quot;#0040FF&quot;,
                            &quot;color&quot;: &quot;white&quot;,
                            &quot;border&quot;: &quot;2px solid white&quot;
                        });
                        sortDiv.attr(&quot;setSort&quot;, true);
                    }

                    sortDiv.click(clickCallback(sortDiv));
                    sortOptionsDiv.append(sortDiv);
                }
            }
        }
        return sortOptionsDiv;
    }    

    /**Editing collections by adding/removing artworks
     * @method manageCollection
     * @param {doq} exhibition      the current collection to be edited
     */
     function manageCollection(exhibition) {
        TAG.Util.UI.createAssociationPicker(root, &quot;Add and Remove Artworks in this Collection&quot;,
                { comp: exhibition, type: &#x27;exhib&#x27; },
                &#x27;exhib&#x27;, [{
                    name: &#x27;All Artworks&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksAndTours,
                }, {
                    name: &#x27;Artworks in this Collection&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }], {
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }, function () {
                    prepareNextView(true, &quot;New&quot;, createExhibition);
                    clearRight();
                    prepareViewer(true);
                    loadExhibitionsView(exhibition.Identifier);
                });
     }



    /**Set up the right side for a collection
     * @method loadExhibition
     * @param {Object} exhibition   exhibition to load
     */
    function loadExhibition(exhibition) {
        prepareViewer(true);
        clearRight();
        deleteType = deleteExhibition;
        toDelete = exhibition;

        // Set the viewer to exhibition view (see function below)
        exhibitionView(exhibition);

        // Create inputs
        var privateState;
        if (exhibition.Metadata.Private) {
            privateState = (/^true$/i).test(exhibition.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton(&#x27;Unpublish&#x27;, function () {
            privateState = true;
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            publicInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        privateInput.attr(&#x27;class&#x27;, &#x27;settingButton&#x27;);
        var publicInput = createButton(&#x27;Publish&#x27;, function () {
            privateState = false;
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            privateInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        publicInput.attr(&#x27;class&#x27;, &#x27;settingButton&#x27;);
        if (privateState) {
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        } else {
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        }
        var pubPrivDiv = $(document.createElement(&#x27;div&#x27;));
        pubPrivDiv.append(privateInput).append(publicInput);

        // local visibility
        var localVisibility = LADS.Util.localVisibility(exhibition.Identifier);
        var invisibilityInput = createButton(&#x27;Hidden&#x27;, function () {
            if (localVisibility) { changesHaveBeenMade = true; };
            localVisibility = false;
            invisibilityInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            visibilityInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        var visibilityInput = createButton(&#x27;Visible&#x27;, function () {
            if (!localVisibility) { changesHaveBeenMade = true; };
            localVisibility = true;
            visibilityInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            invisibilityInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        if (localVisibility) {
            visibilityInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        } else {
            invisibilityInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        }
        var visDiv = $(document.createElement(&#x27;div&#x27;));
        visDiv.append(invisibilityInput).append(visibilityInput);

        //TO-DO: add in on server side from TAG.Worktop.Database.js changeExhibition() 
        var timelineShown;
        if (exhibition.Metadata.Timeline === (&quot;true&quot;||&quot;false&quot;)){
            exhibition.Metadata.Timeline === &quot;true&quot; ? timelineShown = true: timelineShown = false;
        } else {
            //backwards compatibility
            timelineShown = true;
        }
        console.log(timelineShown);
        var showTimeline = createButton(&#x27;Show Timeline&#x27;, function(){
            timelineShown = true;
            showTimeline.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            hideTimeline.css(&#x27;background-color&#x27;,&#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;:&#x27;48%&#x27;,
            &#x27;padding-left&#x27;: &#x27;10px&#x27;,
            &#x27;padding-right&#x27;: &#x27;10px&#x27;
        });
        showTimeline.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        var hideTimeline = createButton(&#x27;Hide Timeline&#x27;, function(){
            timelineShown = false;
            hideTimeline.css(&#x27;background-color&#x27;,&#x27;white&#x27;);
            showTimeline.css(&#x27;background-color&#x27;,&#x27;&#x27;);
            }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;
        });
        hideTimeline.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        if (timelineShown){
            showTimeline.css(&#x27;background-color&#x27;,&#x27;white&#x27;);
        }else{
            hideTimeline.css(&#x27;background-color&#x27;,&#x27;white&#x27;);
        }
        var timelineOptionsDiv = $(document.createElement(&#x27;div&#x27;));
        timelineOptionsDiv.append(showTimeline).append(hideTimeline);

        var sortDropDown;
        var privateSetting;
        var localVisibilitySetting;
        var name;
        var desc;
        var bg;
        var preview;
        var sortOptions;
        var idLabel;
        var nameInput;
        var descInput;
        var bgInput;
        var previewInput;
        if (!exhibition.Metadata.SortOptions) { //NEEDS T OBE CHANGESEDFDJAKLSDJF
            LADS.Worktop.Database.getArtworksIn(exhibition.Identifier, function (artworks) {
                var sortOptions = {
                    &quot;Title&quot;: true,
                    &quot;Artist&quot;: true,
                    &quot;Year&quot;: true,
                    &quot;Tour&quot;: false,
                    &quot;InfoFields&quot;: {}
                };
                var item;
                if (!artworks || !artworks[0]) {

                } else {
                    for (var i = 0; i &lt; artworks.length; i++) {
                        if (artworks[i].Metadata.RelatedArtworks) {
                            (sortOptions[&quot;Tour&quot;])[0]++;
                        } else if (artworks[i].Metadata.InfoFields) {
                            for (var info in artworks[i].Metadata.InfoFields) {
                                if (artworks[i].Metadata.InfoFields.hasOwnProperty(info)) {
                                    if (sortOptions.InfoFields[info]) {
                                        (sortOptions.InfoFields[info])[0]++;
                                    } else {
                                        sortOptions.InfoFields[info] = [1, false];
                                    }
                                }
                            }
                        }
                    }
                }
                LADS.Worktop.Database.changeExhibition(exhibition.Identifier, { SortOptions: JSON.stringify(sortOptions) });
                sortDropDown = createSortOptions(sortOptions);
                createCollectionSettings();
            });
        } else {
            sortDropDown = createSortOptions(JSON.parse(exhibition.Metadata.SortOptions));
            createCollectionSettings();
        }

        function createCollectionSettings() {

            nameInput = createTextInput(TAG.Util.htmlEntityDecode(exhibition.Name), &#x27;Collection name&#x27;, 40);
            descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(exhibition.Metadata.Description), false);
            bgInput = createButton(&#x27;Change Background Image&#x27;, function () {
                uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                    var url = urls[0];
                    bgInput.val(url);
                    $(&#x27;#bgimage&#x27;).css({
                        &#x27;background-image&#x27;: &#x27;url(&quot;&#x27; + TAG.Worktop.Database.fixPath(url) + &#x27;&quot;)&#x27;,
                        &#x27;background-size&#x27;: &#x27;cover&#x27;,
                    });
                });
            });
            var previewInput = createButton(&#x27;Change Image&#x27;, function () {
                uploadFile(TAG.Authoring.FileUploadTypes.Standard, function (urls) {
                    var url = urls[0];
                    previewInput.val(url);
                    $(&#x27;#img1&#x27;)[0].src = TAG.Worktop.Database.fixPath(url);
                });
            });

            nameInput.focus(function () {
                if (nameInput.val() === &#x27;Collection&#x27;)
                    nameInput.select();
            });

            descInput.focus(function () {
                if (descInput.val() === &#x27;Description&#x27;)
                    descInput.select();
            });

            // Handle Changes
            onChangeUpdateText(nameInput, &#x27;#exhibition-title&#x27;, 40);
            onChangeUpdateText(descInput, &#x27;#description-text&#x27;, 1790);

            privateSetting = createSetting(&#x27;Change Publish Setting&#x27;, pubPrivDiv);
            name = createSetting(&#x27;Collection Name&#x27;, nameInput);
            desc = createSetting(&#x27;Collection Description&#x27;, descInput);
            bg = createSetting(&#x27;Collection Background Image&#x27;, bgInput);
            preview = createSetting(&#x27;Collection Preview Image&#x27;, previewInput);
            timeline = createSetting(&#x27;Change Timeline Setting&#x27;, timelineOptionsDiv);

            settingsContainer.append(privateSetting);
            settingsContainer.append(name);
            settingsContainer.append(desc);
            settingsContainer.append(bg);
            settingsContainer.append(preview);
            settingsContainer.append(timeline);
        }

        //Automatically save changes
        currentMetadataHandler = function () {
            if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                nameInput.val(&quot;Untitled Collection&quot;);
            }
            LADS.Util.localVisibility(exhibition.Identifier, { visible: localVisibility });
            saveExhibition(exhibition, {
                privateInput: privateState,
                nameInput: nameInput,
                descInput: descInput,
                bgInput: bgInput,
                previewInput: previewInput,
                sortOptions: sortDropDown
            });
        };

        // Buttons
        var saveButton = createButton(&#x27;Save Changes&#x27;, function () {
            if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                nameInput.val(&quot;Untitled Collection&quot;);
            }
            saveExhibition(exhibition, {
                privateInput: privateState,  //default set unpublished
                nameInput: nameInput,        //Collection name
                descInput: descInput,        //Collection description
                bgInput: bgInput,            //Collection background image
                previewInput: previewInput,  //Collection preview image
                timelineInput: timelineShown,  //to-do make sure default is shown
            });
        }, {
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
            &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
            &#x27;float&#x27;: &#x27;right&#x27;,
        });

        var deleteButton = createButton(&#x27;Delete Collection&#x27;, function () {
            deleteExhibition(exhibition);
        }, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        var catalogNext = true;
        // Creates the button to toggle between views
        var switchViewButton = createButton(&#x27;Preview Catalog&#x27;, function () {
            viewer.empty();
            if (catalogNext) {
                // If there is no art the program crashes when entering catalog mode
                // Show a message and return if thats the case (would prefer not having
                // to request all the artwork)
                LADS.Worktop.Database.getArtworksIn(exhibition.Identifier, function (artworks) {
                    if (!artworks || !artworks[0]) {
                        var messageBox = LADS.Util.UI.popUpMessage(null, &quot;Cannot view in catalog mode because there is no artwork in this exhibit.&quot;, null, true);
                        root.append(messageBox);
                        $(messageBox).show();
                        exhibitionView();
                    } else {
                        switchViewButton.text(&#x27;Preview Collection&#x27;);
                        catalogView();
                        catalogNext = !catalogNext;
                    }
                });

                return;
            } else {
                switchViewButton.text(&#x27;Preview Catalog&#x27;);
                exhibitionView();
            }
            catalogNext = !catalogNext;
        }, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        var artPickerButton = createButton(&#x27;Manage Collection&#x27;, function () {
            TAG.Util.UI.createAssociationPicker(root, &quot;Add and Remove Artworks in this Collection&quot;,
                { comp: exhibition, type: &#x27;exhib&#x27; },
                &#x27;exhib&#x27;, [{
                    name: &#x27;All Artworks&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksAndTours,
                }, {
                    name: &#x27;Artworks in this Collection&#x27;,
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }], {
                    getObjs: TAG.Worktop.Database.getArtworksIn,
                    args: [exhibition.Identifier]
                }, function () {
                    prepareNextView(true, &quot;New&quot;, createExhibition);
                    clearRight();
                    prepareViewer(true);
                    loadExhibitionsView(exhibition.Identifier);
                });

        }, {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });

        leftButton = artPickerButton;
        // Sets the viewer to catalog view
        function catalogView() {
            rightQueue.add(function () {
                var catalog;
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                    return;
                }
                LADS.Layout.Catalog(exhibition, null, function (catalog) {
                    viewer.append(catalog.getRoot());
                    catalog.loadInteraction();
                    preventClickthrough(viewer);

                });
            });
        }

        /**Helper method to set the viewer to exhibition view
         * @method exhibitionView
         * @param {Object} exhibition    exhibition to load
         */
        function exhibitionView(exhibition) {
            rightQueue.add(function () {
                var options = {
                    backCollection : exhibition
                };
                var exhibView = new TAG.Layout.CollectionsPage(options);
                var exroot = exhibView.getRoot();
                $(exroot).css(&#x27;z-index&#x27;,&#x27;-1&#x27;); // otherwise, you can use the search box and sorting tabs!
                viewer.append(exroot);
                preventClickthrough(viewer);
            });
        }

        buttonContainer.append(artPickerButton).append(deleteButton).append(saveButton);
    }

    /**Create an exhibition
     * @method createExhibition
     */
    function createExhibition() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createExhibition(null, function (newDoq) {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                return;
            }
            if (!newDoq) { // Shouldn&#x27;t happen!
                // TODO: Error Message
                loadExhibitionsView();
                return;
            }
            loadExhibitionsView(newDoq.Identifier);
        }, authError, error(loadExhibitionsView), true);
    }

    /** Save a collection
     * @method saveExhibition
     * @param {Object} exhibition   collection to save
     * @inputs {Object} inputs      keys from input fields
     */
    function saveExhibition(exhibition, inputs) {
        pCL = displayLoadingSettings();
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        //prepareViewer(true);

        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();
        var bg = inputs.bgInput.val();
        var preview = inputs.previewInput.val();
        var priv = inputs.privateInput;
        var timeline = inputs.timelineInput;

        console.log(timeline);

        var sortOptions = JSON.parse(exhibition.Metadata.SortOptions);
        var option;

        sortOptions[$(inputs.sortOptions[0].children[0]).text()] = $(inputs.sortOptions[0].children[0]).attr(&quot;setSort&quot;); //Title
        sortOptions[$(inputs.sortOptions[0].children[1]).text()] = $(inputs.sortOptions[0].children[1]).attr(&quot;setSort&quot;); //ARtist
        sortOptions[$(inputs.sortOptions[0].children[2]).text()] = $(inputs.sortOptions[0].children[2]).attr(&quot;setSort&quot;); //Year
        sortOptions[$(inputs.sortOptions[0].children[3]).text()] = $(inputs.sortOptions[0].children[3]).attr(&quot;setSort&quot;); //Tour
        for (var i = 4; i &lt; inputs.sortOptions[0].children.length; i++) { //start at 4 because filter by 4 main fields
            var option = $(inputs.sortOptions[0].children[i]);
            if (sortOptions.InfoFields[option.text()]) {
                (sortOptions.InfoFields[option.text()])[1] = option.attr(&quot;setSort&quot;);
            }
        }

        var options = {
            Name: name,
            Private: priv,
            Description: desc,
            SortOptions: JSON.stringify(sortOptions),
            Timeline: timeline
        }

        if (bg)
            options.Background = bg;
        if (preview)
            options.Img1 = preview;

        TAG.Worktop.Database.changeExhibition(exhibition.Identifier, options, function () {
            ollectionsIsLoading = false;
            if (backButtonClicked &amp;&amp; !(generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don&#x27;t continue if more sections are still loading - wait for them to finish
                backButtonClickHandler();
            };
            if (!backButtonClicked &amp;&amp; (prevSelectedSetting &amp;&amp; prevSelectedSetting === nav[NAV_TEXT.exhib.text])) {
                loadExhibitionsView(exhibition.Identifier); //eventually don&#x27;t want this here? - reloads everything
            };
            hideLoading();
            hideLoadingSettings(pCL);
            saveArray.splice(saveArray.indexOf(exhibition.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                LADS.Worktop.Database.getExhibitions();
                return;
            }
        }, authError, conflict(exhibition, &quot;Update&quot;, loadExhibitionsView), error(loadExhibitionsView));
    }

    /**Delete a collection
     * @method deleteExhibition
     * @param {Object} exhibition     collection to delete
     */
    function deleteExhibition(exhibition) {

        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the exhibition
            TAG.Worktop.Database.deleteDoq(exhibition.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.exhib.text]) {
                    return;
                }
                loadExhibitionsView();
            }, authError, conflict(exhibition, &quot;Delete&quot;, loadExhibitionsView), error(loadExhibitionsView));
        }, &quot;Are you sure you want to delete &quot; + exhibition.Name + &quot;?&quot;, &quot;Delete&quot;, true, function() { $(confirmationBox).hide(); });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }


    // Tour Functions:

    /**Load the tour view
     * @method loadTourView
     * @param {Object} id   id of middle label to start on
     */
    function loadTourView(id) {
        
        prepareNextView(true, &quot;New&quot;, createTour);
        clearRight();
        prepareViewer(true);
        var cancel = false;

        if (generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
            hideLoading();
            hideLoadingSettings(pCL);
        };
        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        toursIsLoading &amp;&amp; showLoading();
        (saveArray.indexOf(previousIdentifier) &lt; 0) &amp;&amp; function () { hideLoading(); hideLoadingSettings(pCL); };

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = true;
        inFeedbackView = false;

        // Make an async call to get tours
        TAG.Worktop.Database.getTours(function (result) {
            if (cancel) return;
            sortAZ(result);
            currentList = result;
            currentIndex = 0;
            $.each(result, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn&#x27;t lock up
                middleQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                        return;
                    }
                    var label;
                    if (!prevSelectedMiddleLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        // Select the first one
                        middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, null, function () {
                            previousIdentifier = val.Identifier;
                            loadTour(val);
                            currentIndex = i;
                        }, val.Identifier, false, function () {
                            editTour(val);
                        }), true));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (middlebar.scrollTop() === 0 &amp;&amp; label.offset().top - middlebar.height() &gt; 0) {
                            middlebar.animate({
                                scrollTop: (label.offset().top - middlebar.height())
                            }, 1000);
                        }
                        
                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        currentIndex = i;
                        loadTour(val);
                    } else {

                        middleLoading.before(label = createMiddleLabel(val.Name, null, function () {
                            if (changesHaveBeenMade) {
                                saveArray.push(previousIdentifier);
                                currentMetadataHandler &amp;&amp; saveQueue.add(currentMetadataHandler());
                                changesHaveBeenMade = false;
                            } else {
                                loadTour(val); //immediately loading the next tour that has been clicked on if no changes have been made
                                //otherwise the next tour is loaded when saving is complete
                            };
                            previousIdentifier = val.Identifier;
                            currentIndex = i;
                        }, val.Identifier, false, function () {
                            editTour(val);
                            
                        }));
                        //prevSelectedMiddleLabel = label;
                        //currentSelected = prevSelectedMiddleLabel;
                    }
                    // Hide if it doesn&#x27;t match search criteria
                    if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    /**Load a tour to the right side
     * @method loadTour
     * @param {Object} tour     tour to load
     */
    function loadTour(tour) {
        prepareViewer(true);
        clearRight();
        deleteType = deleteTour;
        toDelete = tour;

        // Create an img element just to load the image
        var img = $(document.createElement(&#x27;img&#x27;));
        img.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail));

        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;30%&#x27;,
            &#x27;top&#x27;: &#x27;22%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: viewer.height() / 2 + &#x27;px&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;
        };
        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        var selectedLabel = prevSelectedMiddleLabel;
        img.load(function () {
            // If the selection has changed since we started loading return
            if (prevSelectedMiddleLabel &amp;&amp; prevSelectedMiddleLabel.text() !== tour.Name) {
                TAG.Util.removeProgressCircle(circle);
                return;
            }
            TAG.Util.removeProgressCircle(circle);
            // Set the image as a background image, centered and contained
            viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + TAG.Worktop.Database.fixPath(tour.Metadata.Thumbnail) + &#x27;) no-repeat center / contain&#x27;);
        });

        // Create inputs
        // inputs
        var privateState;
        if (tour.Metadata.Private) {
            privateState = (/^true$/i).test(tour.Metadata.Private);
        } else {
            privateState = false;
        }
        var privateInput = createButton(&#x27;Unpublish&#x27;, function () {
            privateState = true;
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            publicInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;margin-right&#x27;: &#x27;4%&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        privateInput.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        var publicInput = createButton(&#x27;Publish&#x27;, function () {
            if (privateState) { 
                changesHaveBeenMade = true; 
            };
            privateState = false;
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
            privateInput.css(&#x27;background-color&#x27;, &#x27;&#x27;);
        }, {
            &#x27;min-height&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;48%&#x27;,
        });
        publicInput.attr(&#x27;class&#x27;,&#x27;settingButton&#x27;);
        if (privateState) {
            privateInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        } else {
            publicInput.css(&#x27;background-color&#x27;, &#x27;white&#x27;);
        }
        var pubPrivDiv = $(document.createElement(&#x27;div&#x27;));
        pubPrivDiv.append(privateInput).append(publicInput);

        var nameInput = createTextInput(TAG.Util.htmlEntityDecode(tour.Name), true, 120);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(tour.Metadata.Description).replace(/\n/g,&#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, false);
        var tourIdInput = createTextInput(tour.Identifier, &#x27;Tour ID (read-only)&#x27;, 80, false, true);
        nameInput.focus(function () {
            if (nameInput.val() === &#x27;Untitled Tour&#x27;)
                nameInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Tour Description&#x27;)
                descInput.select();
        });

        // on change behavior
        onChangeUpdateText(descInput, null, 1500); // What should max length be?
        onChangeUpdateText(nameInput, null, 1500);

        var privateSetting = createSetting(&#x27;Change Publish Setting&#x27;, pubPrivDiv);
        var name = createSetting(&#x27;Tour Name&#x27;, nameInput);
        var desc = createSetting(&#x27;Tour Description&#x27;, descInput);
        var tourIdLabel = createSetting(&#x27;Tour ID (read-only)&#x27;, tourIdInput);

        settingsContainer.append(privateSetting);
        settingsContainer.append(name);
        settingsContainer.append(desc);
        settingsContainer.append(tourIdLabel);

        //Automatically save changes
        currentMetadataHandler = function () {
            if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                nameInput.val() = &quot;Untitled Tour&quot;;
            }
            saveTour(tour, {
                privateInput: privateState,
                nameInput: nameInput,
                descInput: descInput,
            });
        };

        // Create buttons
        var editButton = createButton(&#x27;Edit Tour&#x27;,
            function () { editTour(tour); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var deleteButton = createButton(&#x27;Delete Tour&#x27;,
            function () { deleteTour(tour); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var duplicateButton = createButton(&#x27;Duplicate Tour&#x27;,
            function () {
                duplicateTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (nameInput.val() === undefined || nameInput.val() === &quot;&quot;) {
                    nameInput.val(&quot;Untitled Tour&quot;);
                }
                saveTour(tour, {
                    privateInput: privateState,
                    nameInput: nameInput,
                    descInput: descInput,
                });
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });

        buttonContainer.append(editButton).append(duplicateButton).append(deleteButton).append(saveButton);
    }

    /** Create a tour
     * @method createTour
     */
    function createTour() {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);

        TAG.Worktop.Database.createTour(null, function (newDoq) {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            if (!newDoq) {
                // TODO: ERROR
                loadTourView();
                return;
            }
            loadTourView(newDoq.Identifier);
        }, authError, error(loadTourView), true);
    }

    /**Edit a tour
     * @method editTour
     * @param {Object} tour     tour to edit
     */
    function editTour(tour) {
        // Overlay doesn&#x27;t spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay(&#x27;Loading Tour...&#x27;);
        middleQueue.clear();
        rightQueue.clear();
        setTimeout(function () {
            var toureditor = new TAG.Layout.TourAuthoringNew(tour, function () {
                TAG.Util.UI.slidePageLeft(toureditor.getRoot());
            });
        }, 1);
    }

    /**Delete a tour
     * @method deleteTour
     * @param {Object} tour     tour to delete
     */
    function deleteTour(tour) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the tour
            TAG.Worktop.Database.deleteDoq(tour.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                    return;
                }
                loadTourView();
            }, authError, conflict(tour, &quot;Delete&quot;, loadTourView), error(loadTourView));
        }, &quot;Are you sure you want to delete &quot; + tour.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { 
            $(confirmationBox).hide(); 
        });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }

    /**Duplicate a tour
     * @method duplicateTour
     * @param {Object} tour     tour to duplicate
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function duplicateTour(tour, inputs) {
        prepareNextView(false);
        clearRight();
        prepareViewer(true);
        var options = {
            Name: &quot;Copy: &quot; + tour.Name,
            Description: tour.Metadata.Description,
            Content: tour.Metadata.Content,
            Thumbnail: tour.Metadata.Thumbnail,
            Private: &quot;true&quot;, // always want to create duplicates as unpublished
        };

        TAG.Worktop.Database.createTour(options, function (tewer) {
            console.log(&quot;success&quot;);
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                return;
            }
            loadTourView(tewer.Identifier);
        }, function () {
            console.log(&quot;error&quot;);
        }, function () {
            console.log(&quot;cacheError&quot;);
        });
    }

    /**Save a tour
     * @method saveTour
     * @param {Object} tour     tour to save
     * @param {Object} inputs   keys for name, description, and privateInput of tour
     */
    function saveTour(tour, inputs) {
        pCL = displayLoadingSettings();
        var name = inputs.nameInput.val();
        var desc = inputs.descInput.val();

        if (name.indexOf(&#x27; &#x27;) === 0) {
            var messageBox = TAG.Util.UI.popUpMessage(null, &quot;Tour Name cannot start with a space.&quot;, null, true);
            $(root).append(messageBox);
            $(messageBox).show();
            return;
        }

        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        //prepareViewer(true);

        TAG.Worktop.Database.changeTour(tour.Identifier, {
            Name: name,
            Description: desc,
            Private: inputs.privateInput,
        }, function () {
            toursIsLoading = false;
            if (backButtonClicked &amp;&amp; !(generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don&#x27;t continue if more sections are still loading - wait for them to finish
                backButtonClickHandler();
            };
            if (!backButtonClicked &amp;&amp; (prevSelectedSetting &amp;&amp; prevSelectedSetting === nav[NAV_TEXT.tour.text])) {
                loadTourView(previousIdentifier); //eventually don&#x27;t want this here? - reloads everything
            };
            hideLoading();
            hideLoadingSettings(pCL);
            saveArray.splice(saveArray.indexOf(tour.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.tour.text]) {
                LADS.Worktop.Database.getTours();
                return;
            }
        }, authError, conflict(tour, &quot;Update&quot;, loadTourView), error(loadTourView));
    }

    // Associated Media functions:

    /**Load Associated Media view
     * @method load AssocMediaView
     * @param {Object} id   id of middle label to start on
     */
    function loadAssocMediaView(id) {
        prepareNextView(true, &quot;Import&quot;, createAsset);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        if (generalIsLoading || collectionsIsLoading ||
          artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
            hideLoading();
            hideLoadingSettings(pCL);
        };
        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        associatedMediaIsLoading &amp;&amp; showLoading();
        (saveArray.indexOf(previousIdentifier) &lt; 0) &amp;&amp; function () { hideLoading(); hideLoadingSettings(pCL); };

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = true;
        inToursView = false;
        inFeedbackView = false;

        // Make an async call to get artworks
        TAG.Worktop.Database.getAssocMedia(function (result) {
            if (cancel) return;
            sortAZ(result);
            currentList = result;
            currentIndex = 0;

            if (result[0] &amp;&amp; result[0].Metadata) {
                $.each(result, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue so the UI doesn&#x27;t lock up
                    middleQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.ContentType.toLowerCase()) {
                            case &#x27;video&#x27;:
                                imagesrc = (val.Metadata.Thumbnail &amp;&amp; !val.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + &#x27;images/video_icon.svg&#x27;;
                                break;
                            case &#x27;audio&#x27;:
                                imagesrc = tagPath + &#x27;images/audio_icon.svg&#x27;;
                                break;
                            case &#x27;iframe&#x27;:
                                imagesrc = tagPath + &#x27;images/audio_icon.svg&#x27;; // TODO iframe replace icon
                                break;
                            case &#x27;image&#x27;:
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + &#x27;images/image_icon.svg&#x27;;
                                break;
                            default:
                                imagesrc = null;
                                break;
                        }
                        if (!prevSelectedMiddleLabel &amp;&amp;
                            ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                            // Select the first one
                            middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                previousIdentifier = val.identifier;
                                loadAssocMedia(val);
                                currentIndex = i;
                            }, val.Identifier, false), true));

                            // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                            if (middlebar.scrollTop() === 0 &amp;&amp; label.offset().top - middlebar.height() &gt; 0) {
                                middlebar.animate({
                                    scrollTop: (label.offset().top - middlebar.height())
                                }, 1000);
                            }

                            prevSelectedMiddleLabel = label;
                            currentSelected = prevSelectedMiddleLabel;
                            loadAssocMedia(val);
                        } else {
                            middleLoading.before(label = createMiddleLabel(val.Name, imagesrc, function () {
                                if (changesHaveBeenMade) {
                                    saveArray.push(previousIdentifier);
                                    currentMetadataHandler &amp;&amp; saveQueue.add(currentMetadataHandler());
                                    changesHaveBeenMade = false;
                                } else {
                                    loadAssocMedia(val); //immediately loading the next assocmedia that has been clicked on if no changes have been made
                                    //otherwise the next assocmedia is loaded when saving is complete
                                };
                                previousIdentifier = val.Identifier;
                                currentIndex = i;
                            }, val.Identifier, false));
                        }
                        // Hide if it doesn&#x27;t match search criteria
                        if (!TAG.Util.searchString(val.Name, searchbar.val())) {
                            label.hide();
                        }
                    });
                });
                // Hide the loading label when we&#x27;re done
                middleQueue.add(function () {
                    middleLoading.hide();
                });
            } else {
                middleLoading.hide();
            }
        });
        cancelLastSetting = function () { cancel = true; };
    }
    
    /**Loads associated media to the right side
     * @method loadAssocMedia
     * @param {Object} media    associated media to load
     */
    function loadAssocMedia(media) {
        prepareViewer(true);
        clearRight();
        deleteType = deleteAssociatedMedia;
        toDelete = media;
        // Create an img element to load the image
        var type = media.Metadata.ContentType.toLowerCase();
        var holder;
        var source = (type === &#x27;iframe&#x27;) ? media.Metadata.Source : TAG.Worktop.Database.fixPath(media.Metadata.Source);
        switch (type) {
            case &quot;image&quot;:
                holder = $(document.createElement(&#x27;img&#x27;));
                break;
            case &quot;video&quot;:
                holder = $(document.createElement(&#x27;video&#x27;));
                holder.attr(&#x27;id&#x27;, &#x27;videoInPreview&#x27;);
                holder.attr(&#x27;poster&#x27;, (media.Metadata.Thumbnail &amp;&amp; !media.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(media.Metadata.Thumbnail) : &#x27;&#x27;);
                holder.attr(&#x27;identifier&#x27;, media.Identifier);
                holder.attr(&quot;preload&quot;, &quot;none&quot;);
                holder.attr(&quot;controls&quot;, &quot;&quot;);
                holder.css({ &quot;width&quot;: &quot;100%&quot;, &quot;max-width&quot;: &quot;100%&quot;, &quot;max-height&quot;: &quot;100%&quot; });
                TAG.Worktop.Database.getConvertedVideoCheck(
                function (output) {
                    if (output !== &quot;&quot; &amp;&amp; output !== &quot;False&quot; &amp;&amp; output !== &quot;Error&quot;) {
                        holder.removeAttr(&#x27;src&#x27;);
                        var sourceWithoutExtension = source.substring(0, source.lastIndexOf(&#x27;.&#x27;));
                        var sourceMP4 = sourceWithoutExtension + &quot;.mp4&quot;;
                        var sourceWEBM = sourceWithoutExtension + &quot;.webm&quot;;
                        var sourceOGV = sourceWithoutExtension + &quot;.ogv&quot;;

                        addSourceToVideo(holder, sourceMP4, &#x27;video/mp4&#x27;);
                        addSourceToVideo(holder, sourceWEBM, &#x27;video/webm&#x27;);
                        addSourceToVideo(holder, sourceOGV, &#x27;video/ogv&#x27;);
                        $(document.getElementsByClassName(&quot;convertVideoBtn&quot;)[0]).hide().data(&#x27;disabled&#x27;, true);
                    } else {
                        if (output === &quot;False&quot;) {
                            $(document.getElementsByClassName(&quot;convertVideoBtn&quot;)[0]).hide().data(&#x27;disabled&#x27;, true);
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            conversionVideos.push(artwork.Identifier);
                        } else if (output === &quot;Error&quot;) {
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;There is an error occured when converting this video. Please try again&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg, true));
                        } else {
                            if (media.Extension !== &quot;.mp4&quot;) {
                                $(&quot;#videoErrorMsg&quot;).remove();
                                $(&quot;#leftLoading&quot;).remove();
                                var msg = &quot;The video format is not supported.&quot;;
                                viewer.append(LADS.Util.createConversionLoading(msg, true));
                            }
                        }
                        holder.attr(&#x27;src&#x27;, source);
                    }
                }, null, media.Identifier);
                if (conversionVideos.indexOf(media.Identifier) &gt; -1) {
                    var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                    viewer.append(TAG.Util.createConversionLoading(msg));
                } else {
                    holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer, media.Metadata.Converted);
                }
                fixVolumeBar(holder);
                break;
            case &quot;audio&quot;:
                holder = $(document.createElement(&#x27;audio&#x27;));
                holder.attr(&quot;preload&quot;, &quot;none&quot;);
                holder.attr(&quot;controls&quot;, &quot;&quot;);
                holder.css({ &#x27;width&#x27;: &#x27;80%&#x27; });
                break;
            case &quot;iframe&quot;:
                holder = $(document.createElement(&#x27;iframe&#x27;));
                holder.attr({
                    src: source,
                    frameborder: &#x27;0&#x27;
                });
                holder.css({
                    width: &#x27;100%&#x27;,
                    height: &#x27;100%&#x27;
                });
                break;
            case &quot;text&quot;:
            default:
                holder = $(document.createElement(&#x27;div&#x27;));
                holder.css({
                    &quot;font-size&quot;: &quot;24px&quot;,
                    &quot;top&quot;: &quot;20%&quot;,
                    &quot;width&quot;: &quot;80%&quot;,
                    &quot;text-align&quot;: &quot;center&quot;,
                    &quot;color&quot;: &quot;white&quot;
                });
                holder.html(media.Name + &quot;&lt;br /&gt;&lt;br /&gt;&quot; + media.Metadata.Description);
                holder.crossOrigin = &quot;&quot;;
                break;
        }
        (source &amp;&amp; type !== &#x27;text&#x27;) &amp;&amp; holder.attr(&#x27;src&#x27;, source);

        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;40%&#x27;,
            &#x27;top&#x27;: &#x27;40%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;
        };
        var circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        var selectedLabel = prevSelectedMiddleLabel;

        switch (type) {
            case &quot;image&quot;:
                holder.load(function () {
                    // If the selection has changed since we started loading then return
                    if (prevSelectedMiddleLabel &amp;&amp; prevSelectedMiddleLabel.text() !== media.Name) {
                        TAG.Util.removeProgressCircle(circle);
                        return;
                    }
                    TAG.Util.removeProgressCircle(circle);
                    // Set the image as a background image
                    viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + source + &#x27;) no-repeat center / contain&#x27;);
                });
                break;
            case &quot;video&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                viewer.append(holder);
                break;
            case &quot;audio&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                //center the the audio element in the viewer
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + &quot;px&quot;;
                var top = viewer.height() /2 - holder.height() /2 + &quot;px&quot;;
                holder.css({ &quot;position&quot;: &quot;absolute&quot;, &quot;left&quot;: left, &quot;top&quot; : top });
                break;
            case &quot;iframe&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                viewer.append(holder);
                break;
            case &quot;text&quot;:
                TAG.Util.removeProgressCircle(circle);
                viewer.css({ &#x27;background&#x27;: &#x27;black&#x27;});
                viewer.append(holder);
                var left = viewer.width() / 2 - holder.width() / 2 + &quot;px&quot;;
                var top = viewer.height() / 2 - holder.height() / 2 + &quot;px&quot;;
                holder.css({ &quot;position&quot;: &quot;absolute&quot;, &quot;left&quot;: left, &quot;top&quot;: top });
                break;
            default:
                TAG.Util.removeProgressCircle(circle);
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
                break;
        }

        // Create labels
        var titleInput = createTextInput(TAG.Util.htmlEntityDecode(media.Name) || &quot;&quot;, true, 55);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(media.Metadata.Description).replace(/\n/g,&#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, true);

        titleInput.focus(function () {
            if (titleInput.val() === &#x27;Title&#x27;)
                titleInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Description&#x27;)
                descInput.select();
        });

        onChangeUpdateText(titleInput, null, 40);
        onChangeUpdateText(descInput, null, 40);

        var title = createSetting(&#x27;Title&#x27;, titleInput);
        var desc = createSetting(&#x27;Description&#x27;, descInput);
        var yearMetadataDivSpecs = createYearMetadataDiv(media);

        settingsContainer.append(title);
        settingsContainer.append(desc);
        settingsContainer.append(yearMetadataDivSpecs.yearMetadataDiv);

        //Automatically save changes
        currentMetadataHandler = function () {
            if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                titleInput.val(&quot;Untitled Asset&quot;);
            }
            saveAssocMedia(media, {
                titleInput: titleInput,
                descInput: descInput
            });
        };

        // Create buttons
        
        var assocButton = createButton(&#x27;Associate to Artworks&#x27;,
            function () { assocToArtworks(media); changesHaveBeenMade = true;},
            {
                &#x27;float&#x27;: &#x27;left&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        
        leftButton = assocButton;
        var deleteButton = createButton(&#x27;Delete&#x27;,
            function () {deleteAssociatedMedia(media); changesHaveBeenMade = true; },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;,
            });

        var generateAssocMediaThumbnailButton = createButton(&#x27;Generate Thumbnail&#x27;,
            function () {
                generateAssocMediaThumbnail(media);
                changesHaveBeenMade = true;
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });

        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                    titleInput.val(&quot;Untitled Asset&quot;);
                }
                saveAssocMedia(media, {
                    titleInput: titleInput,
                    descInput: descInput,
                    yearInput: yearMetadataDivSpecs.yearInput,                     
                    monthInput: yearMetadataDivSpecs.monthInput,                  
                    dayInput: yearMetadataDivSpecs.dayInput,                       
                    timelineYearInput: yearMetadataDivSpecs.timelineYearInput,     
                    timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,  
                    timelineDayInput: yearMetadataDivSpecs.timelineDayInput   

                });
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });

        var thumbnailButton = createButton(&#x27;Capture Thumbnail&#x27;,
            function () {
                saveThumbnail(media, false);
                changesHaveBeenMade = true;
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });

        buttonContainer.append(assocButton);
        if (media.Metadata.ContentType.toLowerCase() === &#x27;video&#x27;) {
            var convertBtn = createButton(&#x27;Convert Video&#x27;,
                    function () {
                        var source = media.Metadata.Source;
                        var newFileName = source.slice(8, source.length);
                        var index = newFileName.lastIndexOf(&quot;.&quot;);
                        var fileExtension = newFileName.slice(index);
                        var baseFileName = newFileName.slice(0, index);
                        if (media.Metadata.Converted !== &quot;True&quot;) {
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, newFileName, fileExtension, baseFileName, media.Identifier);
                            conversionVideos.push(media.Identifier);
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            holder[0].onerror = TAG.Util.videoErrorHandler(holder, viewer, &quot;False&quot;);
                            convertBtn.hide().data(&#x27;disabled&#x27;, true);
                        }
                    }, {
                        &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                        &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                        &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                        &#x27;margin-left&#x27;: &#x27;0.5%&#x27;,
                        &#x27;float&#x27;: &#x27;right&#x27;
                    })
            convertBtn.attr(&#x27;class&#x27;, &#x27;convertVideoBtn&#x27;);
            if (media.Metadata.Converted!==&quot;True&quot; &amp;&amp; conversionVideos.indexOf(media.Identifier) === -1) {
                convertBtn.show().data(&#x27;disabled&#x27;, false);
            } else {
                convertBtn.hide().data(&#x27;disabled&#x27;, true);
            }
            buttonContainer.append(thumbnailButton).append(convertBtn);
        } else if (media.Metadata.ContentType.toLowerCase() === &#x27;image&#x27; &amp;&amp; !media.Metadata.Thumbnail &amp;&amp; media.Metadata.Source &amp;&amp; media.Metadata.Source[0] === &#x27;/&#x27; &amp;&amp; !source.match(/.mp3/)) {
            // hacky way to see if asset was imported recently enough to support thumbnailing (these are /Images/_____.__
            // rather than http:// _______/Images/_______.__
            buttonContainer.append(generateAssocMediaThumbnailButton);
        }
        buttonContainer.append(deleteButton).append(saveButton); //SAVE BUTTON//
    }

    /**Save an associated media
     * @method saveAssocMedia
     * @param {Object} media    associated media to save
     * @param {Object} inputs   keys for media title and description
     */
    function saveAssocMedia(media, inputs) {
        var name = inputs.titleInput.val(),
            year = inputs.yearInput.val(),
            month = inputs.monthInput.val(),
            day = inputs.dayInput.val(),
            timelineYear = inputs.timelineYearInput.val(),
            timelineMonth = inputs.timelineMonthInput.val(),
            timelineDay = inputs.timelineDayInput.val(),
            desc = inputs.descInput.val();

        pCL = displayLoadingSettings();
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();

        var name = inputs.titleInput.val();
        var desc = inputs.descInput.val();
        //prepareViewer(true);

        TAG.Worktop.Database.changeHotspot(media, {
            Name: name,
            Description: desc,
            Year: year,
            Month: month,
            Day: day,
            TimelineYear: timelineYear,
            TimelineMonth: timelineMonth,
            TimelineDay: timelineDay,
        }, function () {
            associatedMediaIsLoading = false;
            if (backButtonClicked &amp;&amp; !(generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don&#x27;t continue if more sections are still loading - wait for them to finish
                backButtonClickHandler();
            };
            if (!backButtonClicked &amp;&amp; (prevSelectedSetting &amp;&amp; prevSelectedSetting === nav[NAV_TEXT.media.text])) {
                //hideLoading();
                //hideLoadingSettings(pCL);
                loadAssocMediaView(previousIdentifier); //eventually don&#x27;t want this here? - reloads everything
            };
            hideLoading();
            hideLoadingSettings(pCL);
            saveArray.splice(saveArray.indexOf(media.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.media.text]) {
                LADS.Worktop.Database.getAssocMedia();
                return;
            }
        }, authError, conflict(media, &quot;Update&quot;, loadAssocMediaView), error(loadAssocMediaView));
    }

    /**Delete associated media
     * @method deleteAssociatedMedia
     * @param {Object} media    media to be deleted
     */
    function deleteAssociatedMedia(media) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // stupid way to force associated artworks to increment their linq counts and refresh their lists of media
            TAG.Worktop.Database.changeHotspot(media.Identifier, { Name: media.Name }, function () {
            // success handler
            TAG.Worktop.Database.deleteDoq(media.Identifier, function () {
                console.log(&quot;deleted&quot;);
                loadAssocMediaView();
            }, function () {
                console.log(&quot;noauth error&quot;);
            }, function () {
                console.log(&quot;conflict error&quot;);
            }, function () {
                console.log(&quot;general error&quot;);
            });
            }, function () {
            // unauth handler
            }, function () {
            // conflict handler
            }, function () {
            // error handler
            });
            }, &quot;Are you sure you want to delete &quot; + media.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { $(confirmationBox).hide(); });
            root.append(confirmationBox);
            $(confirmationBox).show();
    }

    /**Brings up an artwork chooser for a particular associated media
     * @method assocToArtworks
     * @param {Object} media    media to associate to artworks
     */
    function assocToArtworks(media) {
        artworkAssociations = [[]];
        numFiles = 1;
        TAG.Util.UI.createAssociationPicker(root, &quot;Choose artworks&quot;, { comp: media, type: &#x27;media&#x27; }, &quot;artwork&quot;, [{
            name: &quot;All Artworks&quot;,
            getObjs: TAG.Worktop.Database.getArtworks
        }], {
            getObjs: TAG.Worktop.Database.getArtworksAssocTo,
            args: [media.Identifier]
        }, function () { });
    }

    /**Generate thumbnail for associated media
     * @method generateAssocMediaThumbnail
     * @param {Object} media        media to generate thumbnail for
     */
    function generateAssocMediaThumbnail(media) {
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.changeHotspot(media.Identifier, { Thumbnail: &#x27;generate&#x27; }, function () {
            loadAssocMediaView(media.Identifier);
        }, unauth, conflict, error);
    }

    // TODO document
    function createIframeAsset(src) { //TODO IFRAME ASSOC MEDIA: iframe asset creation would look something like this
        var options = {
            Source: src,
            Name: src
        };
        function onSuccess(doqData) {
            var newDoq = new Worktop.Doq(doqData.responseText);
            function done() {
                loadAssocMediaView(newDoq.Identifier);
            }
            TAG.Worktop.Database.changeHotspot(newDoq.Identifier, options, done, TAG.Util.multiFnHandler(authError, done), TAG.Util.multiFnHandler(conflict(newDoq, &quot;Update&quot;, done)), error(done));

        };
        TAG.Worktop.Database.createIframeAssocMedia(options, onSuccess);
    }

    /**
     * Create a dialog for inputting an iframe source for new associated media
     * @method createIframeSourceDialog
     */
    function createIframeSourceDialog() {
        var overlay = TAG.Util.UI.popupInputBox({
            confirmAction: createIframeAsset,
            container: root,
            message: &#x27;Enter URL for your embedded web asset&#x27;,
            //placeholder: &#x27;E.g., http://www.youtube.com/embed/g794oDdc1l0&#x27;,
            confirmText: &#x27;Save&#x27;
        });

        root.append(overlay);
        overlay.fadeIn(500);
    }

    /**
     * @method createAsset
     */
    function createAsset() {
        uploadFile(TAG.Authoring.FileUploadTypes.AssociatedMedia, function (urls, names, contentTypes, files) {
            var check, i, url, name, done = 0, total = urls.length, durations = [], toScroll, alphaName;
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            if(files.length &gt; 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === &#x27;Video&#x27;) {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else if (contentTypes[j] === &#x27;Audio&#x27;) {
                    files[j].properties.getMusicPropertiesAsync().done(function (MusicProperties) {
                        durations.push(MusicProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (error) {
                        console.log(error);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }

            function incrDone() {
                done++;
                if (done &gt;= total) {
                    loadAssocMediaView(toScroll.Identifier);
                } else {
                    durationHelper(done);
                }
            }

            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                    var options = { Name: names[j] };
                    if (durations[j]) {
                        options.Duration = durations[j];
                    }
                    TAG.Worktop.Database.changeHotspot(newDoq.Identifier, options, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, &quot;Update&quot;, incrDone)), error(incrDone));
                    if (contentTypes[j] === &quot;Video&quot;) {

                        //conversionVideos.push(newDoq.Identifier);
                        var source = newDoq.Metadata.Source;
                        var newFileName = source.slice(8, source.length);
                        var index = newFileName.lastIndexOf(&quot;.&quot;);
                        var fileExtension = newFileName.slice(index);
                        var baseFileName = newFileName.slice(0, index);
                        var confirmBox = TAG.Util.UI.PopUpConfirmation(function () {
                            //$(document.getElementById(&quot;leftLoading&quot;)).remove();
                            //viewer.append(LADS.Util.createConversionLoading(&quot;This video is being converted to compatible formats for different browsers&quot;));
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                            conversionVideos.push(newDoq.Identifier);
                            var mediaElement = $(document.getElementById(&quot;videoInPreview&quot;));
                            if (mediaElement[0]) {
                                var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                                viewer.append(TAG.Util.createConversionLoading(msg));
                                $(&quot;#videoErrorMsg&quot;).remove();
                                $(&quot;#leftLoading&quot;).remove();
                            }
                        }, &quot;Would you like to convert&quot; + newFileName + &quot;?&quot;, &quot;Yes&quot;, true, function () {
                            if (fileExtension !== &quot;.mp4&quot;) {
                                var msg = &quot;The video format is not supported.&quot;;
                                viewer.append(LADS.Util.createConversionLoading(msg, true));
                            }
                            $(&quot;.convertVideoBtn&quot;).show().data(&quot;disabled&quot;, false);
                        });

                        root.append(confirmBox);
                        $(confirmBox).show();
                    }
                } catch (error) {
                    done++;
                    console.log(&quot;error in uploading: &quot; + error.message);
                    return;
                }
                if (!alphaName || names[j] &lt; alphaName) {
                    toScroll = newDoq;                          //Alphabetical order
                    alphaName = names[j];
                }
            }
        }, true, [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;, &#x27;.mp3&#x27;, &#x27;.mp4&#x27;, &#x27;.webm&#x27;, &#x27;.ogv&#x27;]);
    }

    /**Create an associated media (import), possibly more than one
     * @method createMedia
     */
    function createMedia() {
        batchAssMedia();
    }

    /**
     * @method batchAssMedia
     */
    function batchAssMedia() {
        var uniqueUrls = []; // Used to make sure we don&#x27;t override data for the wrong media (not actually airtight but w/e)
        mediaMetadata = [];
        artworkAssociations = [];
        numFiles = 0;
        isUploading = true;
        assetUploader = TAG.Authoring.FileUploader( // multi-file upload now
            root,
            TAG.Authoring.FileUploadTypes.AssociatedMedia,
            function (files, localURLs) { // localCallback
                var file, localURL, i;
                var img, video, audio;
                var contentType;
                numFiles = files.length;
                for (i = 0; i &lt; files.length; i++) {
                    artworkAssociations.push([]);
                    file = files[i];
                    localURL = localURLs[i];
                    if (file.contentType.match(/image/)) {
                        contentType = &#x27;Image&#x27;;
                    } else if (file.contentType.match(/video/)) {
                        contentType = &#x27;Video&#x27;;
                    } else if (file.contentType.match(/audio/)) {
                        contentType = &#x27;Audio&#x27;;
                    }
                    uniqueUrls.push(localURL);
                    mediaMetadata.push({
                        &#x27;title&#x27;: file.displayName,
                        &#x27;contentType&#x27;: contentType,
                        &#x27;localUrl&#x27;: localURL,
                        &#x27;assetType&#x27;: &#x27;Asset&#x27;,
                        &#x27;assetLinqID&#x27;: undefined,
                        &#x27;assetDoqID&#x27;: undefined
                    });
                }
            },
            function (dataReaderLoads) { // finished callback: set proper contentUrls, if not first, save it
                var i, dataReaderLoad;
                for (i = 0; i &lt; dataReaderLoads.length; i++) {
                    dataReaderLoad = dataReaderLoads[i];
                    mediaMetadata[i].contentUrl = dataReaderLoad;
                }

                // chooseAssociatedArtworks(); // need to send in media objects here TODO
            },
            [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;, &#x27;.mp3&#x27;], // filters
            false, // useThumbnail
            null, // errorCallback
            true // multiple file upload enabled?
        );
    }

    /**
     * @method saveAssMedia
     * @param i the index of the asset 
     */
    function saveAssMedia(i) {
        var len = artworkAssociations[i].length;
        uploadHotspotHelper(i, 0, len);
    }

    /**
     * Uploads hotspot i to artwork j in its list of artworks to associate to.
     * @method uploadHotspotHelper
     * @param i    the index of the asset we&#x27;re uploading
     * @param j    each asset has a list of artworks it&#x27;ll be associated with; j is the index in this list
     * @param len  the length of the list above
     */
    function uploadHotspotHelper(i, j, len) {
        // uploads hotspot hotspot i to artwork j in its list
        var activeMM = mediaMetadata[i];
        uploadHotspot(artworkAssociations[i][j], { // this info isn&#x27;t changing, so maybe we can do this more easily in uploadHotspot
            title: TAG.Util.encodeXML(activeMM.title || &#x27;Untitled media&#x27;),
            desc: TAG.Util.encodeXML(&#x27;&#x27;),
            pos: null, // bogus entry for now -- should set it to {x: 0, y: 0} in uploadHotspot
            contentType: activeMM.contentType,
            contentUrl: activeMM.contentUrl,
            assetType: activeMM.assetType,
            metadata: {
                assetLinqID: activeMM.assetLinqID,
                assetDoqID: activeMM.assetDoqID
            }
        },
        i, j, len);
    }

    /**
     * @method uploadHotspot
     * @param artwork
     * @param info
     * @param i
     * @param j
     * @param len
     */
    function uploadHotspot(artwork, info, i, j, len) {
        var title = info.title,
            desc = info.desc,
            pixel = info.pos,
            contentType = info.contentType,
            contentUrl = info.contentUrl,
            assetType = info.assetType,
            worktopInfo = info.metadata || {},
            dzPos = pixel ? zoomimage.viewer.viewport.pointFromPixel(pixel) : { x: 0, y: 0 },
            rightbarLoadingSave;

        var options = {
            Name: title,
            ContentType: contentType,
            Duration: duration,
            Source: contentUrl,
            LinqTo: artwork.Identifier,
            X: dzPos.x,
            Y: dzPos.y,
            LinqType: assetType,
            Description: desc
        };

        TAG.Worktop.Database.createHotspot(artwork.CreatorID, artwork.Identifier, createHotspotHelper);

        /**
         * @method createHotspotHelper
         * @param isNewAsset
         * @param xmlHotspot
         */
        function createHotspotHelper(isNewAsset, xmlHotspot) { // currently for creating both hotspots and assoc media
            var $xmlHotspot,
                hotspotId,
                hotspotContentId,
                hotspotContentDoq,
                $hotspotContentDoq,
                titleField,
                metadata,
                descField,
                contentTypeField,
                sourceField,
                position;
            $xmlHotspot = $(xmlHotspot);
            hotspotId = $xmlHotspot.find(&quot;Identifier&quot;).text();
            hotspotContentId = $xmlHotspot.find(&quot;BubbleContentID:last&quot;).text();
            hotspotContentDoq = $.parseXML(TAG.Worktop.Database.getDoqXML(hotspotContentId));
            $hotspotContentDoq = $(hotspotContentDoq);
            // update doq info and send back to server
            titleField = $hotspotContentDoq.find(&#x27;Name&#x27;).text(title);
            metadata = $hotspotContentDoq.find(&#x27;Metadata&#x27;);
            descField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;Description&#x27;) + d3p1\\:Value&quot;).text(desc);
            contentTypeField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;ContentType&#x27;) + d3p1\\:Value&quot;).text(contentType);
            sourceField = metadata.find(&quot;d3p1\\:Key:contains(&#x27;Source&#x27;) + d3p1\\:Value&quot;).text(contentUrl);
            position = $xmlHotspot.find(&#x27;Offset &gt; d2p1\\:_x&#x27;).text(dzPos.x); // why is position getting reset?
            position = $xmlHotspot.find(&#x27;Offset &gt; d2p1\\:_y&#x27;).text(dzPos.y);
            //add linq type : Hotspot vs. Asset
            $xmlHotspot.find(&quot;d3p1\\:Key:contains(&#x27;Type&#x27;) + d3p1\\:Value&quot;).text(assetType);
            TAG.Worktop.Database.pushLinq(xmlHotspot, hotspotId);
            TAG.Worktop.Database.pushXML(hotspotContentDoq, hotspotContentId);
            if (j &lt; len - 1) {
                uploadHotspotHelper(i, j + 1, len);
            }
            else if (j === len - 1 &amp;&amp; i &lt; numFiles - 1) {
                saveAssMedia(i + 1);
            }
            else {
                isUploading = false;
                isCreatingMedia = false;
                //$topProgressDiv.css(&quot;visibility&quot;, &quot;hidden&quot;);
            }
        }
    }

    // Art Functions:

    /**Loads art view
     * @method loadArtView
     * @param {Object} id   id of middle label to start on
     */
    function loadArtView(id) {
        
        prepareNextView(true, &quot;Import&quot;, createArtwork);
        prepareViewer(true);
        clearRight();
        var cancel = false;

        if (generalIsLoading || collectionsIsLoading ||
          artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
            hideLoading();
            hideLoadingSettings(pCL);
        };
        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
        artworksIsLoading &amp;&amp; showLoading();
        (saveArray.indexOf(previousIdentifier) &lt; 0) &amp;&amp; function () { hideLoading(); hideLoadingSettings(pCL); };

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = true;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = false;

        // Make an async call to get artworks
        TAG.Worktop.Database.getArtworks(function (result) {
            if (cancel) return;
            sortAZ(result);
            currentList = result;
            currentIndex = 0;
            artworkList = result;
            if (result[0] &amp;&amp; result[0].Metadata) {
                $.each(result, function (i, val) {
                    if (cancel) return;
                    // Add each label in a separate function in the queue
                    // so the UI doesn&#x27;t lock up
                    val.Name = TAG.Util.htmlEntityDecode(val.Name);
                    middleQueue.add(function () {
                        if (cancel) return;
                        if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                            return;
                        }
                        var label;
                        var imagesrc;
                        switch (val.Metadata.Type) {
                            case &#x27;Artwork&#x27;:
                                imagesrc = TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail);
                                break;
                            case &#x27;VideoArtwork&#x27;:
                                imagesrc = val.Metadata.Thumbnail ? TAG.Worktop.Database.fixPath(val.Metadata.Thumbnail) : tagPath + &quot;images/video_icon.svg&quot;;
                                break
                            default:
                                imagesrc = null;
                        }
                        if (!prevSelectedMiddleLabel &amp;&amp;
                            ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                            // Select the first one
                            middleLoading.before(selectLabel(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                previousIdentifier = val.identifier;
                                loadArtwork(val);
                                currentIndex = i;
                            }, val.Identifier, false, function () {
                                editArtwork(val);
                            }, true, val.Extension), true));


                            // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                            if (middlebar.scrollTop() === 0 &amp;&amp; label.offset().top - middlebar.height() &gt; 0) {
                                middlebar.animate({
                                    scrollTop: (label.offset().top - middlebar.height() / 2)
                                }, 1000);
                            }

                            prevSelectedMiddleLabel = label;
                            currentSelected = prevSelectedMiddleLabel;
                            currentIndex = i;
                            loadArtwork(val);
                        } else {
                            middleLoading.before(label = createMiddleLabel(val.Name, imagesrc, function () {
                                //keep track of identifiers for autosaving
                                if (changesHaveBeenMade) {
                                    saveArray.push(previousIdentifier);
                                    currentMetadataHandler &amp;&amp; saveQueue.add(currentMetadataHandler());
                                    changesHaveBeenMade = false;
                                } else {
                                    loadArtwork(val); //immediately loading the next artwork that has been clicked on if no changes have been made
                                    //otherwise the next artwork is loaded when saving is complete
                                };
                                previousIdentifier = val.Identifier;
                                currentIndex = i;
                            }, val.Identifier, false, function () {
                                editArtwork(val);
                            }, true, val.Extension));
                        }
                        // Hide if it doesn&#x27;t match search criteria
                        if (!LADS.Util.searchString(val.Name, searchbar.val())) {
                            label.hide();
                        }
                    });
                });
                // Hide the loading label when we&#x27;re done
                middleQueue.add(function () {
                    middleLoading.hide();
                });
            } else {
                middleLoading.hide();
            }
        });

        cancelLastSetting = function () { cancel = true; };
    }
    /*nest source tag inside video element*/
    function addSourceToVideo(element, src, type) {
        var source = document.createElement(&#x27;source&#x27;);

        source.src = src;
        source.type = type;

        element[0].appendChild(source);
    }
    /**Loads an artwork to the right side
     * @method loadArtwork
     * @param {Object} artwork  artwork to load
     */
    function loadArtwork(artwork) {
        prepareViewer(true);
        clearRight();
        deleteType = deleteArtwork;
        toDelete = artwork;

        // Create an img element to load the image
        var mediaElement;
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            mediaElement = $(document.createElement(&#x27;img&#x27;));
            mediaElement.attr(&#x27;src&#x27;, TAG.Worktop.Database.fixPath(artwork.URL));
        } else {
            mediaElement = $(document.createElement(&#x27;video&#x27;));
            mediaElement.attr(&#x27;id&#x27;, &#x27;videoInPreview&#x27;);
            fixVolumeBar(mediaElement);
            mediaElement.attr(&#x27;poster&#x27;, (artwork.Metadata.Thumbnail &amp;&amp; !artwork.Metadata.Thumbnail.match(/.mp4/)) ? TAG.Worktop.Database.fixPath(artwork.Metadata.Thumbnail) : &#x27;&#x27;);
            mediaElement.attr(&#x27;identifier&#x27;, artwork.Identifier);
            mediaElement.attr(&quot;preload&quot;, &quot;none&quot;);
            mediaElement.attr(&quot;controls&quot;, &quot;&quot;);
            mediaElement.css({ &quot;width&quot;: &quot;100%&quot;, &quot;max-width&quot;: &quot;100%&quot;, &quot;max-height&quot;: &quot;100%&quot; });
            var source = TAG.Worktop.Database.fixPath(artwork.Metadata.Source);

            TAG.Worktop.Database.getConvertedVideoCheck(
                function (output) {
                    if (output !== &quot;&quot; &amp;&amp; output !== &quot;False&quot; &amp;&amp; output !== &quot;Error&quot;) {
                        var sourceWithoutExtension = source.substring(0, source.lastIndexOf(&#x27;.&#x27;));
                        var sourceMP4 = sourceWithoutExtension + &quot;.mp4&quot;;
                        var sourceWEBM = sourceWithoutExtension + &quot;.webm&quot;;
                        var sourceOGV = sourceWithoutExtension + &quot;.ogv&quot;;

                        addSourceToVideo(mediaElement, sourceMP4, &#x27;video/mp4&#x27;);
                        addSourceToVideo(mediaElement, sourceWEBM, &#x27;video/webm&#x27;);
                        addSourceToVideo(mediaElement, sourceOGV, &#x27;video/ogv&#x27;);
                        $(document.getElementsByClassName(&quot;convertVideoBtn&quot;)[0]).hide().data(&#x27;disabled&#x27;, true);
                    } else {
                        if (output === &quot;False&quot;) {
                            $(document.getElementsByClassName(&quot;convertVideoBtn&quot;)[0]).hide().data(&#x27;disabled&#x27;, true);
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            conversionVideos.push(artwork.Identifier);
                        } else if (output === &quot;Error&quot;) {
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;There is an error occured when converting this video. Please try again&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg, true));
                        } else {
                            if (artwork.Extension !== &quot;.mp4&quot;) {
                                $(&quot;#videoErrorMsg&quot;).remove();
                                $(&quot;#leftLoading&quot;).remove();
                                var msg = &quot;The video format is not supported.&quot;;
                                viewer.append(TAG.Util.createConversionLoading(msg, true));
                            }
                        }
                        mediaElement.attr(&#x27;src&#x27;, source);
                    }
                }, null, artwork.Identifier);
            if (conversionVideos.indexOf(artwork.Identifier) &gt; -1) {
                var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                viewer.append(TAG.Util.createConversionLoading(msg));
            } else {
                mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer, artwork.Metadata.Converted);
            }
        }
        mediaElement.crossOrigin = &quot;&quot;;
        // Create a progress circle
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;40%&#x27;,
            &#x27;top&#x27;: &#x27;40%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;
        };
        var circle;
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            circle = TAG.Util.showProgressCircle(viewer, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
        }
        var selectedLabel = prevSelectedMiddleLabel;

        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            mediaElement.load(function () {
                // If the selection has changed since we started loading then return
                if (prevSelectedMiddleLabel &amp;&amp; prevSelectedMiddleLabel.text() !== artwork.Name) {
                    TAG.Util.removeProgressCircle(circle);
                    return;
                }
                TAG.Util.removeProgressCircle(circle);
                // Set the image as a background image
                viewer.css(&#x27;background&#x27;, &#x27;black url(&#x27; + TAG.Worktop.Database.fixPath(artwork.URL) + &#x27;) no-repeat center / contain&#x27;);
            });
        } else {
            viewer.append(mediaElement);
        }

        var titleInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Name), true, 55);
        var artistInput = createTextInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Artist), true, 55);
        var descInput = createTextAreaInput(TAG.Util.htmlEntityDecode(artwork.Metadata.Description).replace(/\n/g, &#x27;&lt;br /&gt;&#x27;) || &quot;&quot;, &quot;&quot;, false);
        var customInputs = {};
        var customSettings = {};
        var desc = createSetting(&#x27;Description&#x27;, descInput);
        var yearMetadataDivSpecs = createYearMetadataDiv(artwork);

        titleInput.focus(function () {
            if (titleInput.val() === &#x27;Title&#x27;)
                titleInput.select();
        });
        artistInput.focus(function () {
            if (artistInput.val() === &#x27;Artist&#x27;)
                artistInput.select();
        });
        descInput.focus(function () {
            if (descInput.val() === &#x27;Description&#x27;)
                descInput.select();
        });

        onChangeUpdateText(titleInput, null, 40);
        onChangeUpdateText(artistInput, null, 40);
        onChangeUpdateText(yearMetadataDivSpecs.yearInput, null, 40);
        onChangeUpdateText(descInput, null, 40);

        var title = createSetting(&#x27;Title&#x27;, titleInput);
        var artist = createSetting(&#x27;Artist&#x27;, artistInput);

        if (artwork.Metadata.InfoFields) {
            $.each(artwork.Metadata.InfoFields, function (key, val) {
                customInputs[key] = createTextInput(TAG.Util.htmlEntityDecode(val), true);
                customSettings[key] = createSetting(key, customInputs[key]);
            });
        }
        
        settingsContainer.append(title);
        settingsContainer.append(artist);
        settingsContainer.append(yearMetadataDivSpecs.yearMetadataDiv);
        settingsContainer.append(desc);

        $.each(customSettings, function (key, val) {
            settingsContainer.append(val);
        });
        //Automatically save changes
        currentMetadataHandler = function () {
            if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                titleInput.val(&quot;Untitled Artwork&quot;);
            }
            saveArtwork(artwork, {
                artistInput: artistInput,
                nameInput: titleInput,
                yearInput: yearInput,
                descInput: descInput,
                customInputs: customInputs,
            });
        };
        // Create buttons
        editArt = createButton(&#x27;Enter Artwork Editor&#x27;,
            function () { editArtwork(artwork); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        leftButton = editArt;
        editArt.attr(&quot;id&quot;, &quot;artworkEditorButton&quot;);
        var deleteArt = createButton(&#x27;Delete Artwork&#x27;,
            function () { deleteArtwork(artwork); },
            {
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
            });
        var inputs = {
            artistInput: artistInput,                                      //Artwork artist
            nameInput: titleInput,                                         //Artwork title
            yearInput: $(yearMetadataDivSpecs.yearInput),                     //Artwork year or era
            monthInput: yearMetadataDivSpecs.monthInput,                   //Artwork month
            dayInput: yearMetadataDivSpecs.dayInput,                       //Artwork day
            timelineYearInput: yearMetadataDivSpecs.timelineYearInput,     //Artwork year on timeline
            timelineMonthInput: yearMetadataDivSpecs.timelineMonthInput,   //Artwork month on timeline 
            timelineDayInput: yearMetadataDivSpecs.timelineDayInput,       //Artwork day on timeline 
            descInput: descInput,                                          //Artwork description
            customInputs: customInputs,                                    //Artwork custom info fields
        };
        var saveButton = createButton(&#x27;Save Changes&#x27;,
            function () {
                if (titleInput.val() === undefined || titleInput.val() === &quot;&quot;) {
                    titleInput.val(&quot;Untitled Artwork&quot;);
                }
                saveArtwork(artwork, inputs);
            }, {
                &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;.5%&#x27;,
                &#x27;float&#x27;: &#x27;right&#x27;
            });
        var xmluploaderbtn = createButton(&#x27;Upload XML&#x27;,
                        function () {
                            uploadXML(artwork, inputs, settingsContainer);
                        },
                        {
                            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
                        });


        var thumbnailButton = createButton(&#x27;Capture Thumbnail&#x27;,
            function () {
                saveThumbnail(artwork, true);
            }, {
                &#x27;margin-right&#x27;: &#x27;0%&#x27;,
                &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                &#x27;margin-left&#x27;: &#x27;2%&#x27;,
                &#x27;float&#x27;: &#x27;left&#x27;
            });
        if (artwork.Metadata.Type !== &#x27;VideoArtwork&#x27;) {
            buttonContainer.append(editArt).append(deleteArt).append(saveButton).append(xmluploaderbtn); //SAVE BUTTON//
        } else {
            var convertBtn = createButton(&#x27;Convert Video&#x27;,
                    function () {
                        var source = artwork.Metadata.Source;
                        var newFileName = source.slice(8, source.length);
                        var index = newFileName.lastIndexOf(&quot;.&quot;);
                        var fileExtension = newFileName.slice(index);
                        var baseFileName = newFileName.slice(0, index);
                        if (artwork.Metadata.Converted !== &quot;True&quot;) {
                            TAG.Worktop.Database.convertVideo(function () {
                            }, null, newFileName, fileExtension, baseFileName, artwork.Identifier);
                            conversionVideos.push(artwork.Identifier);
                            $(&quot;#videoErrorMsg&quot;).remove();
                            $(&quot;#leftLoading&quot;).remove();
                            var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            mediaElement[0].onerror = TAG.Util.videoErrorHandler(mediaElement, viewer, &quot;False&quot;);
                            convertBtn.hide().data(&#x27;disabled&#x27;, true);
                        }
                    }, {
                        &#x27;margin-right&#x27;: &#x27;3%&#x27;,
                        &#x27;margin-top&#x27;: &#x27;1%&#x27;,
                        &#x27;margin-bottom&#x27;: &#x27;1%&#x27;,
                        &#x27;margin-left&#x27;: &#x27;1.5%&#x27;,
                        &#x27;float&#x27;: &#x27;right&#x27;
                    })
            convertBtn.attr(&#x27;class&#x27;, &#x27;convertVideoBtn&#x27;);
            if (artwork.Metadata.Converted!==&quot;True&quot; &amp;&amp; conversionVideos.indexOf(artwork.Identifier) === -1) {
                convertBtn.show().data(&#x27;disabled&#x27;, false);
            } else {
                convertBtn.hide().data(&#x27;disabled&#x27;, true);
            }
            buttonContainer.append(thumbnailButton).append(deleteArt).append(saveButton).append(convertBtn).append(xmluploaderbtn); //SAVE BUTTON//
        }
    }

    /**Save Thumbnail image 
     * @method saveThumbnail
     * @param {Object} component
     * @param {Boolean} isArtwork
     */
    function saveThumbnail(component, isArtwork) {
        var id = $(&#x27;#videoInPreview&#x27;).attr(&#x27;identifier&#x27;);
        var pop = Popcorn(&#x27;#videoInPreview&#x27;);
        var time = $(&#x27;#videoInPreview&#x27;)[0].currentTime;
        var dataurl = pop.capture({ type: &#x27;jpg&#x27; }); // modified popcorn.capture a bit to
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.uploadImage(dataurl, function (imageURL) {
            if (isArtwork) {
                TAG.Worktop.Database.changeArtwork(id, { Thumbnail: imageURL }, function () {
                    console.log(&quot;success?&quot;);
                    loadArtView(component.Identifier);
                }, unauth, conflict, error);
            
            } else { // here, it must be a video assoc media
                TAG.Worktop.Database.changeHotspot(id, { Thumbnail: imageURL }, function () {
                    console.log(&quot;success?&quot;);
                    loadAssocMediaView(component.Identifier);
                }, unauth, conflict, error);
            }
        }, unauth, error);
    }

    function unauth() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, &quot;Thumbnail not saved.  You must log in to save changes.&quot;);
        $(&#x27;body&#x27;).append(popup);
        $(popup).show();
    }

    function conflict(jqXHR, ajaxCall) {
        ajaxCall.force();
    }

    function error() {
        dialogOverlay.hide();
        var popup = TAG.Util.UI.popUpMessage(null, &quot;Thumbnail not saved.  There was an error contacting the server.&quot;);
        $(&#x27;body&#x27;).append(popup);
        $(popup).show();
    }

    /**Create an artwork (import), possibly more than one
     * @method createArtwork
     */
    function createArtwork() {
        uploadFile(TAG.Authoring.FileUploadTypes.DeepZoom, function (urls, names, contentTypes, files) {
            var check, i, url, name, done=0, total=urls.length, durations=[], toScroll, alphaName;
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            function incrDone() {
                done++;
                if (done &gt;= total) {
                    loadArtView(toScroll.Identifier);       //Scroll down to a newly-added artwork
                } else {
                    durationHelper(done);
                }
            }

            //////////
            if (files.length &gt; 0) {
                durationHelper(0);
            }

            function durationHelper(j) {
                if (contentTypes[j] === &#x27;Video&#x27;) {
                    files[j].properties.getVideoPropertiesAsync().done(function (VideoProperties) {
                        durations.push(VideoProperties.duration / 1000); // duration in seconds
                        updateDoq(j);
                    }, function (err) {
                        console.log(err);
                    });
                } else {
                    durations.push(null);
                    updateDoq(j);
                }
            }
            ///////////
            function updateDoq(j) {
                var newDoq;
                try {
                    newDoq = new Worktop.Doq(urls[j]);
                } catch (error) {
                    done++;
                    console.log(&quot;error in uploading: &quot; + error.message);
                    return;
                }
                var ops = { Name: names[j] };
                if (durations[j]) {
                    ops.Duration = durations[j];
                }
                if (!alphaName || names[j] &lt; alphaName) {
                    toScroll = newDoq;                          //Alphabetical order
                    alphaName = names[j];
                }
                TAG.Worktop.Database.changeArtwork(newDoq.Identifier, ops, incrDone, TAG.Util.multiFnHandler(authError, incrDone), TAG.Util.multiFnHandler(conflict(newDoq, &quot;Update&quot;, incrDone)), error(incrDone));
                var source = newDoq.Metadata.Source;
                if (contentTypes[j] === &quot;Video&quot;) {
                    var newFileName = source.slice(8, source.length);
                    var index = newFileName.lastIndexOf(&quot;.&quot;);
                    var fileExtension = newFileName.slice(index);
                    var baseFileName = newFileName.slice(0, index);
                    var confirmBox = TAG.Util.UI.PopUpConfirmation(function () {
                        TAG.Worktop.Database.convertVideo(function () {
                        }, null, newFileName, fileExtension, baseFileName, newDoq.Identifier);
                        conversionVideos.push(newDoq.Identifier);
                        var mediaElement = $(document.getElementById(&quot;videoInPreview&quot;));
                        if (mediaElement[0]) {
                            var msg = &quot;This video is being converted to compatible formats for different browsers&quot;;
                            viewer.append(TAG.Util.createConversionLoading(msg));
                            $(&quot;#videoErrorMsg&quot;).remove();
                        }
                        $(&quot;.convertVideoBtn&quot;).hide().data(&quot;disabled&quot;, true);
                    }, &quot;Would you like to convert &quot; + newFileName + &quot;?&quot;, &quot;Yes&quot;, true, function () {
                        if (fileExtension !== &quot;.mp4&quot;) {
                            var msg = &quot;The video format is not supported.&quot;;
                            viewer.append(LADS.Util.createConversionLoading(msg, true));
                        }
                        $(&quot;.convertVideoBtn&quot;).show().data(&quot;disabled&quot;, false);
                    });

                    root.append(confirmBox);
                    $(confirmBox).show();
                }
            }

        }, true, [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.mp4&#x27;, &#x27;.mp3&#x27;, &#x27;.webm&#x27;, &#x27;.ogv&#x27;, &#x27;.mpeg&#x27;, &#x27;.avi&#x27;, &#x27;.flv&#x27;, &#x27;.wmv&#x27;, &#x27;.mov&#x27;]);
    }
    /*upload xml for single artwork
   artwork
   inputs: all the input fields in the settingsContainer
   settingsContainer
   */
    function uploadXML(artwork, inputs, settingsContainer) {
        var parsingOverlay = $(TAG.Util.UI.blockInteractionOverlay()),
            parsingOverlayText = $(document.createElement(&#x27;label&#x27;)),
            parsingPicker = $(document.createElement(&#x27;div&#x27;)),
            parsingPickerHeader = $(document.createElement(&#x27;div&#x27;)),
            parsingInfo = $(document.createElement(&#x27;div&#x27;)),
            curtitle = artwork.Name,
            curdata,
            isrightdata = false,
            customFields = [],
            mtinputs = {};
        if (artwork.Metadata.InfoFields) {
            customFields = Object.keys(artwork.Metadata.InfoFields);
        };
        var metadataspec = {
            title: &quot;title&quot;,
            description: &quot;description&quot;,
            year: &quot;year&quot;,
            artist: &quot;artist&quot;,
            extra1: customFields[0] || &quot;&quot;,
            extra2: customFields[1] || &quot;&quot;,
            extra3: customFields[2] || &quot;&quot;,
            extra4: customFields[3] || &quot;&quot;,
        };
        parsingOverlay.addClass(&#x27;parsingOverlay&#x27;);
        parsingOverlay.css(&#x27;z-index&#x27;, TAG.TourAuthoring.Constants.aboveRinZIndex);
        parsingOverlayText.css({ &#x27;color&#x27;: &#x27;white&#x27;, &#x27;width&#x27;: &#x27;10%&#x27;, &#x27;height&#x27;: &#x27;5%&#x27;, &#x27;top&#x27;: &#x27;38%&#x27;, &#x27;left&#x27;: &#x27;35%&#x27;, &#x27;position&#x27;: &#x27;relative&#x27;, &#x27;font-size&#x27;: &#x27;250%&#x27; });
        parsingOverlayText.text(&#x27;Parsing Metadata File now. Please wait.&#x27;);
        parsingOverlay.append(parsingOverlayText);
        parsingOverlayText.hide();
        root.append(parsingOverlay);
        parsingPicker.addClass(&quot;parsingPicker&quot;);
        parsingPicker.css({
            position: &#x27;absolute&#x27;,
            width: &#x27;29%&#x27;,
            height: &#x27;49%&#x27;,
            padding: &#x27;1%&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
            &#x27;border&#x27;: &#x27;3px double white&#x27;,
            top: &#x27;25%&#x27;,
            left: &#x27;35%&#x27;,
        });
        parsingOverlay.append(parsingPicker);
        parsingOverlay.fadeIn();
        parsingPickerHeader.addClass(&#x27;parsingPickerHeader&#x27;);
        parsingPickerHeader.text(&quot;Please change if you have different names for the metadata fields below in your xml file.&quot;);
        parsingPickerHeader.css({
            &#x27;font-size&#x27;: &#x27;160%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;float&#x27;: &#x27;left&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
        });
        parsingPicker.append(parsingPickerHeader);
        parsingInfo.css({
            position: &#x27;absolute&#x27;,
            left: &#x27;3%&#x27;,
            top: &#x27;17%&#x27;,
            padding: &#x27;1%&#x27;,
            height: &#x27;66%&#x27;,
            width: &#x27;94%&#x27;,
            overflow: &#x27;auto&#x27;,
        });
        parsingPicker.append(parsingInfo);
        $.each(metadataspec, function (key, val) {
            var input = createTextInput(val, null, null, false, false);
            var field = createSetting(key, input, null, &#x27;7px&#x27;);
            field.addClass(&quot;metadataspec&quot;);
            field.css(&#x27;color&#x27;, &#x27;white&#x27;);
            field.css({
                float: &#x27;left&#x27;,
                background: &#x27;#222&#x27;,
                width: &#x27;96%&#x27;,
                height: &#x27;11%&#x27;,
                padding: &#x27;2px&#x27;,
                margin: &#x27;1px&#x27;,
            });
            mtinputs[key] = input;// { field: field, input: input };
            field.show().data(&#x27;visible&#x27;, true);
            parsingInfo.append(field);
        });

        //buttons
        var parsingPickerConfirm = $(document.createElement(&#x27;button&#x27;));
        parsingPickerConfirm.attr(&quot;id&quot;, &quot;parsingPickerConfirm&quot;);
        //parsingPickerConfirm.attr(&#x27;disabled&#x27;, true);
        parsingPickerConfirm.text(&quot;Confirm&quot;);
        parsingPickerConfirm.css({
            position: &#x27;absolute&#x27;,
            bottom: &#x27;2%&#x27;,
            right: &#x27;22%&#x27;,
        });
        parsingPickerConfirm.click(function () {
            //parsingPickerOverlay.fadeOut();
            $.each(metadataspec, function (key, val) {
                // update spec according to inputs val
                var newval = mtinputs[key].val();
                //if (newval !== val){// &amp;&amp; newval!==&quot;&quot;) {
                metadataspec[key] = newval;
                //}
            });
            parsingPicker.fadeOut();
            parsingOverlayText.fadeIn();
            initFilepicker(metadataspec);
        });
        parsingPicker.append(parsingPickerConfirm);

        var parsingPickerCancel = document.createElement(&#x27;button&#x27;);
        var $parsingPickerCancel = $(parsingPickerCancel);
        $parsingPickerCancel.text(&quot;Cancel&quot;);
        $parsingPickerCancel.css({
            position: &#x27;absolute&#x27;,
            bottom: &#x27;2%&#x27;,
            right: &#x27;5%&#x27;,
        });

        // cancel button click handler
        $parsingPickerCancel.click(function () {
            parsingOverlay.fadeOut();
            parsingPickerCancel.disabled = true;
        });
        parsingPicker.append($parsingPickerCancel);
        function initFilepicker(spec) {
            var filepicker = new Windows.Storage.Pickers.FileOpenPicker();
            filepicker.fileTypeFilter.replaceAll([&quot;.xml&quot;]);
            filepicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.desktop;
            filepicker.pickSingleFileAsync().then(function (file) {
                if (file) {
                    var size;
                    var maxFileSize = 30 * 1024 * 1024;
                    var toparse;
                    file.getBasicPropertiesAsync().then(
                        function (basicProperties) {
                            size = basicProperties.size;
                            if (size &lt; maxFileSize) {
                                toparse = true;
                                parsefile();
                            } else {
                                var warningBox = TAG.Util.UI.PopUpConfirmation(function () {
                                    toparse = true;
                                    parsefile();
                                }, &quot;The file is larger than 30MB. Parsing it might crash your computer. Are you sure you want to continue?&quot;, &quot;Confirm&quot;, true, function () {
                                    toparse = false;
                                });
                                root.append(warningBox);
                                $(warningBox).show();
                            }

                            //picked the xml file and parse the strings
                            function parsefile() {
                                $.ajax({
                                    type: &quot;GET&quot;,
                                    url: window.URL.createObjectURL(file),
                                    dataType: &quot;xml&quot;,
                                    success: function (xml) {
                                        // Parse the xml file and get data
                                        var lists = [];
                                        var elements = xml.documentElement.childNodes;
                                        var i, curname;
                                        for (i = 0; i &lt; elements.length; i++) {//each artwork
                                            if (isrightdata === false) {
                                                curname = elements[i].localName;
                                                if (curname !== null) {
                                                    var metadatas = elements[i].childNodes;
                                                    var list = {};
                                                    var j, name;
                                                    for (j = 0; j &lt; metadatas.length; j++) {//each metadata field in the artwork
                                                        name = metadatas[j].localName;
                                                        if (name !== null) {
                                                            name = name.toLowerCase();
                                                            if (metadatas[j].childNodes[0]) {
                                                                list[name] = metadatas[j].childNodes[0].nodeValue;
                                                                if (name === spec.title &amp;&amp; metadatas[j].childNodes[0].nodeValue === curtitle) {
                                                                    isrightdata = true;
                                                                }
                                                            } else {
                                                                list[name] = &quot;&quot;;
                                                            }
                                                        }
                                                    }
                                                    lists.push(list);
                                                    if (isrightdata === true) {
                                                        curdata = list;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (isrightdata === true) {
                                            //find the match and update the artwork info using curdata
                                            //$(&quot;.parsingOverlay&quot;).fadeOut();
                                            updateArtwork(artwork, inputs, curdata, settingsContainer, spec);
                                            $(&quot;.parsingOverlay&quot;).remove();

                                        } else {//make a metadata picker for them to choose the metadata they want if no match found
                                            _metadatapicker(artwork, inputs, settingsContainer, lists, spec);
                                            $(&quot;.parsingOverlay&quot;).remove();

                                        }
                                    }
                                });
                            }
                        });

                }
            });
            //$(&quot;.parsingOverlay&quot;).remove();
        }
    }
    /*update artwork inputs after parse xml file
    @param: artwork: the artwork you are going to update metadata for
        inputs: all the input fields on settingsContainer. 
        data: the metadata that is going to be updated for the artwork
    */
    function updateArtwork(artwork, inputs, data, settingsContainer, spec) {
        var counter = 0;//counter to keep track of customfields. now 4max
        var infoFields = {};
        var customSettings = {};

        var title = data[spec.title];
        var artist = data[spec.artist];
        var year = data[spec.year];
        var description = data[spec.description];
        var ele;
        var curval;
        if (!title)
            title = &quot;&quot;;
        delete data[spec.title];
        delete spec.title;
        if (!year)
            year = &quot;&quot;;
        delete data[spec.year];
        delete spec.year;
        if (!artist)
            artist = &quot;&quot;;
        delete data[spec.artist];
        delete spec.artist;
        if (!description)
            description = &quot;&quot;;
        delete data[spec.description];
        delete spec.description;
        $.each(spec, function (key, val) {
            if (val !== &quot;&quot;) {
                infoFields[val] = &quot;&quot;;
            }
        });
        if (Object.keys(data).length &gt; 0) {//if there are more fields:
            $.each(infoFields, function (key, val) {
                curval = data[key];
                if (curval) {
                    delete data[key];
                    infoFields[key] = curval;
                }
                delete spec[key];
                counter++;
            });
            for (ele in data) {
                if (counter &lt; 4) {
                    infoFields[ele] = data[ele];
                    // create input field for new cus field
                    inputs.customInputs[ele] = createTextInput(TAG.Util.htmlEntityDecode(data[ele]), true);
                    customSettings[ele] = createSetting(ele, inputs.customInputs[ele]);
                    counter++;
                }
            }

            $.each(customSettings, function (key, val) {
                settingsContainer.append(val);
            });

        }
        //$(&quot;.parsingOverlay&quot;).remove();
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        prepareViewer(true);
        TAG.Worktop.Database.changeArtwork(artwork, {
            Name: title,
            Artist: artist,
            Year: year,
            Description: description,
            InfoFields: JSON.stringify(infoFields),
        }, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                return;
            }
            loadArtView(artwork.Identifier);
        }, authError, conflict(artwork, &quot;Update&quot;, loadArtView), error(loadArtView));
    }
    /*a picker for user to choose metadata when nothing matches in the file
    @params: artwork: doq of artwork
            inputs: all the input fields in settingsContainer 
            settingsContainer: settingsContainer, passed in for adding new input later
            metadatalist: a list of metadata that parsed in xml file
    */
    function _metadatapicker(artwork, inputs, settingsContainer, metadatalist, spec) {
        var allTitles = {};
        var metadataPickerOverlay = $(TAG.Util.UI.blockInteractionOverlay());
        var metadataPicker = $(document.createElement(&#x27;div&#x27;));
        var metadataPickerHeader = $(document.createElement(&#x27;div&#x27;));
        var searchbar = $(document.createElement(&#x27;input&#x27;));
        //var searchresults;
        var metadataLists = $(document.createElement(&#x27;div&#x27;));
        var metadataInfos = $(document.createElement(&#x27;div&#x27;));
        var metadataholder = $(document.createElement(&#x27;div&#x27;));
        var fields = {};//fields to store all the metadata elements
        //get all metadata titles from metadatalist.
        var selectedmetadata;
        var i;
        var counter = 0;
        var curlast;
        var curlist = metadatalist;
        metadataPickerOverlay.addClass(&#x27;metadataPickerOverlay&#x27;);
        metadataPickerOverlay.css(&#x27;z-index&#x27;, TAG.TourAuthoring.Constants.aboveRinZIndex);

        metadataPicker.addClass(&quot;metadataPicker&quot;);
        metadataPicker.css({
            position: &#x27;absolute&#x27;,
            width: &#x27;71%&#x27;,
            height: &#x27;65%&#x27;,
            padding: &#x27;1%&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
            &#x27;border&#x27;: &#x27;3px double white&#x27;,
            top: &#x27;17%&#x27;,
            left: &#x27;14%&#x27;,
        });
        metadataPickerOverlay.append(metadataPicker);
        metadataPickerHeader.addClass(&#x27;metadataPickerHeader&#x27;);
        metadataPickerHeader.text(&quot;No match found. Please select the metadata you would like to import for &quot; + artwork.Name);
        metadataPickerHeader.css({
            &#x27;font-size&#x27;: &#x27;160%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;float&#x27;: &#x27;left&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
            &#x27;background-color&#x27;: &#x27;black&#x27;,
        });
        metadataPicker.append(metadataPickerHeader);

        searchbar.css({
            &#x27;margin-left&#x27;: &#x27;1%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;width&#x27;: &#x27;29%&#x27;,
        });
        searchbar.on(&#x27;keyup&#x27;, function (event) {
            event.stopPropagation();
        });
        searchbar.attr(&#x27;type&#x27;, &#x27;text&#x27;);
        searchbar.attr(&#x27;placeholder&#x27;, &quot;Search metadata by Title&quot;);
        searchbar.keyup(function () {
            searchtitles(searchbar.val(), allTitles);//, IGNORE_IN_SEARCH);
        });
        searchbar.change(function () {
            searchtitles(searchbar.val(), allTitles);//, IGNORE_IN_SEARCH);
        });
        metadataPicker.append(searchbar);
        //search function in terms of titles
        function searchtitles(tofind, alltitles, container) {
            var searchresults = [];
            curlist = [];
            var title, ind;
            for (ind in alltitles) {
                title = alltitles[ind];
                if (TAG.Util.searchString(title, tofind)) {
                    searchresults.push(ind);
                    curlist.push(metadatalist[ind]);
                }
            }
            //generate mtholders for the results
            metadataLists.empty();
            for (var mtfield in fields) {
                fields[mtfield].field.hide();
            }
            counter = 0;
            var num = searchresults.length &lt; 30 ? searchresults.length : 30;
            for (var j = 0; j &lt; num; j++) {
                var curtitle = alltitles[searchresults[j]];
                var titlediv = makemtholder(curtitle, searchresults[j]);
                counter++;
                if (j === 0)
                    titlediv.click();
            }
        }
        // creates a panel for all the metadata objects
        metadataLists.addClass(&#x27;metadataLists&#x27;);
        metadataLists.css({
            position: &#x27;absolute&#x27;,
            &#x27;border-right&#x27;: &#x27;1px solid white&#x27;,
            top: &#x27;13%&#x27;,
            padding: &#x27;1%&#x27;,
            height: &#x27;73%&#x27;,
            width: &#x27;28%&#x27;,
            overflow: &#x27;auto&#x27;,
        });
        metadataPicker.append(metadataLists);
        metadataLists.bind(&#x27;scroll&#x27;, function () {
            if ($(this).scrollTop() + $(this).innerHeight() &gt;= this.scrollHeight) {
                if (counter &lt; curlist.length) {
                    var num = counter + 30 &lt;= curlist.length ? 30 : curlist.length - counter;
                    for (var k = 0; k &lt; num; k++) {
                        if (counter + k &lt; curlist.length) {
                            makemtholder(allTitles[counter + k], counter + k);
                            counter++;
                        }
                    }
                }
            }
        })
        // creates a panel for all metadata&#x27;s detailed info
        metadataInfos.addClass(&#x27;metadataInfos&#x27;);
        metadataInfos.css({
            position: &#x27;absolute&#x27;,
            left: &#x27;33%&#x27;,
            top: &#x27;13%&#x27;,
            padding: &#x27;1%&#x27;,
            height: &#x27;73%&#x27;,
            width: &#x27;62%&#x27;,
            overflow: &#x27;auto&#x27;,
        });
        metadataPicker.append(metadataInfos);
        metadataholder.attr(&#x27;class&#x27;, &#x27;metadataHolder&#x27;);
        metadataInfos.append(metadataholder);

        for (i = 0; i &lt; metadatalist.length; i++) {
            var mt = metadatalist[i];
            var title = mt[&quot;title&quot;];
            if (!mt[&#x27;title&#x27;])
                title = &quot;Untitled&quot;;
            allTitles[i] = title;
            if (i &lt; 30) {
                var mtHolder = makemtholder(title, i);
                //set the first one selected once we firstly open the picker
                if (i === 0) {
                    mtHolder.click();
                }
                counter++;
            }
        };

        function makemtholder(ttl, index) {
            var mtHolder = $(document.createElement(&#x27;div&#x27;));
            mtHolder.addClass(&#x27;mtHolder&#x27;);
            mtHolder.attr(&#x27;id&#x27;, index);
            mtHolder.css({
                width: &#x27;100%&#x27;,
                height: &#x27;9%&#x27;,
                &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;,
                margin: &#x27;1px 0px 1px 0px&#x27;,
                &#x27;font-size&#x27;: &#x27;120%&#x27;,
                &#x27;padding-left&#x27;: &#x27;3%&#x27;,
                &#x27;padding-top&#x27;: &#x27;3%&#x27;,
                &#x27;color&#x27;: &#x27;white&#x27;,
                &#x27;background-color&#x27;: &#x27;black&#x27;
            });
            mtHolder.text(ttl);
            metadataLists.append(mtHolder);
            makemtClickable(mtHolder);
            return mtHolder;
        }
        //click function for each metadata element
        function makemtClickable(mtholder) {
            mtholder.click(function () {
                $(&quot;.mtHolder&quot;).css(&#x27;background&#x27;, &#x27;black&#x27;);
                mtholder.css(&#x27;background&#x27;, &#x27;#999&#x27;);

                var selected = mtholder.attr(&#x27;id&#x27;);
                selectedmetadata = metadatalist[selected];
                if (selectedmetadata) {
                    $(&quot;#metadataPickerImport&quot;).attr(&#x27;disabled&#x27;, false);
                    for (var ele in fields) {//if there is already a field for that element, change the value and show it.
                        if (ele in selectedmetadata) {
                            fields[ele].input.val(selectedmetadata[ele]);
                            fields[ele].field.show().data(&#x27;visible&#x27;, true);
                        } else {
                            fields[ele].field.hide().data(&#x27;visible&#x27;, false);
                        }
                    }
                    for (var rest in selectedmetadata) {
                        //if there are extra fields, add them
                        if (!fields[rest]) {
                            var input = createTextInput(selectedmetadata[rest], null, null, false, true);
                            var field = createSetting(rest, input, null, &#x27;7px&#x27;);
                            field.addClass(&quot;metadataField&quot;);
                            field.attr(&#x27;title&#x27;, rest);
                            field.css(&#x27;color&#x27;, &#x27;white&#x27;);
                            field.css({
                                float: &#x27;left&#x27;,
                                background: &#x27;#222&#x27;,
                                width: &#x27;96%&#x27;,
                                height: &#x27;25%&#x27;,
                                padding: &#x27;2px&#x27;,
                                margin: &#x27;1px&#x27;,
                            });
                            fields[rest] = { field: field, input: input };
                            field.show().data(&#x27;visible&#x27;, true);
                            metadataholder.append(field);
                        }
                    }
                }
            });
        }

        var metadataPickerImport = $(document.createElement(&#x27;button&#x27;));
        metadataPickerImport.attr(&quot;id&quot;, &quot;metadataPickerImport&quot;);
        metadataPickerImport.attr(&#x27;disabled&#x27;, true);
        if (selectedmetadata)
            metadataPickerImport.attr(&#x27;disabled&#x27;, false);
        metadataPickerImport.text(&quot;Import&quot;);
        metadataPickerImport.css({
            position: &#x27;absolute&#x27;,
            bottom: &#x27;2%&#x27;,
            right: &#x27;22%&#x27;,
        });
        metadataPickerImport.click(function () {
            updateArtwork(artwork, inputs, selectedmetadata, settingsContainer, spec);
            $(&#x27;.metadataInfos&#x27;).empty();
            metadataPickerOverlay.fadeOut();
        });
        metadataPicker.append(metadataPickerImport);

        var metadataPickerCancel = document.createElement(&#x27;button&#x27;);
        var $metadataPickerCancel = $(metadataPickerCancel);
        $metadataPickerCancel.text(&quot;Cancel&quot;);
        $metadataPickerCancel.css({
            position: &#x27;absolute&#x27;,
            bottom: &#x27;2%&#x27;,
            right: &#x27;5%&#x27;,
        });

        // cancel button click handler
        $metadataPickerCancel.click(function () {
            metadataPickerOverlay.fadeOut();
            $(&#x27;.metadataInfos&#x27;).empty();
            metadataPickerCancel.disabled = true;
        });
        metadataPicker.append(metadataPickerCancel);
        root.append(metadataPickerOverlay);
        $(&quot;.parsingOverlay&quot;).fadeOut();
        metadataPickerOverlay.fadeIn();
    }
    /**Edit an artwork
     * @method editArtwork
     * @param {Object} artwork   artwork to edit
     */
    function editArtwork(artwork) {
        // Overlay doesn&#x27;t spin... not sure how to fix without redoing tour authoring to be more async
        loadingOverlay(&#x27;Loading Artwork...&#x27;);
        middleQueue.clear();
        rightQueue.clear();
        setTimeout(function () {
            TAG.Util.UI.slidePageLeft((TAG.Layout.ArtworkEditor(artwork)).getRoot());
        }, 1);
    }

    /**Delete an artwork
     * @method deleteArtwork
     * @param {Object} artwork      artwork to delete
     */
    function deleteArtwork(artwork) {
        var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
            prepareNextView(false);
            clearRight();
            prepareViewer(true);

            // actually delete the artwork
            TAG.Worktop.Database.deleteDoq(artwork.Identifier, function () {
                if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                    return;
                }
                loadArtView();
            }, authError, authError);
        }, &quot;Are you sure you want to delete &quot; + artwork.Name + &quot;?&quot;, &quot;Delete&quot;, true, function () { $(confirmationBox).hide() });
        root.append(confirmationBox);
        $(confirmationBox).show();
    }

    /**Save an artwork
     * @method saveArtwork
     * @param {Object} artwork      artwork to save
     * @param {Object} inputs       keys for artwork info from input fields
     */
    function saveArtwork(artwork, inputs) {
        var name = inputs.nameInput.val(),
            artist = inputs.artistInput.val(),
            year = inputs.yearInput.val(),
            month = inputs.monthInput.val(),
            day = inputs.dayInput.val(),
            timelineYear = inputs.timelineYearInput.val(),
            timelineMonth = inputs.timelineMonthInput.val(),
            timelineDay = inputs.timelineDayInput.val(),
            description = inputs.descInput.val();

        var infoFields = {};
        $.each(inputs.customInputs, function (key, val) {
            infoFields[key] = val.val();
        });

        pCL = displayLoadingSettings();
        prepareNextView(false, null, null, &quot;Saving...&quot;);
        clearRight();
        //prepareViewer(true);
        
        TAG.Worktop.Database.changeArtwork(artwork, {
            Name: name,
            Artist: artist,
            Year: year,
            Month: month,
            Day: day,
            TimelineYear: timelineYear,
            TimelineMonth: timelineMonth,
            TimelineDay: timelineDay,
            Description: description,
            InfoFields: JSON.stringify(infoFields),
        }, function () {
            artworksIsLoading = false;
            if (backButtonClicked &amp;&amp; !(generalIsLoading || collectionsIsLoading ||
                artworksIsLoading || associatedMediaIsLoading || toursIsLoading)) { //don&#x27;t continue if more sections are still loading - wait for them to finish
                backButtonClickHandler();
            };
            if (!backButtonClicked &amp;&amp; (prevSelectedSetting &amp;&amp; prevSelectedSetting === nav[NAV_TEXT.art.text])) {
                //hideLoading();
                //hideLoadingSettings(pCL);
                loadArtView(previousIdentifier); //eventually don&#x27;t want this here? - reloads everything
            };
            hideLoading();
            hideLoadingSettings(pCL);
            saveArray.splice(saveArray.indexOf(artwork.Identifier), 1); //removes identifier from save array
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.art.text]) {
                LADS.Worktop.Database.getMain();
                return;
            }
        }, authError, conflict(artwork, &quot;Update&quot;, loadArtView), error(loadArtView)); 
    }

    // Feedback Functions:

    /**Loads Feedback view
     * @method loadFeedbackView
     * @param {Object} id   id of middle label to start on
     */
    function loadFeedbackView(id) {
        prepareNextView(true, &quot;&quot;);
        prepareViewer(false);
        clearRight();
        var cancel = false;

        if (generalIsLoading || collectionsIsLoading ||
               artworksIsLoading || associatedMediaIsLoading || toursIsLoading) {
            hideLoading();
            hideLoadingSettings(pCL);
        };
        generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);

        inGeneralView = false;
        inCollectionsView = false;
        inArtworkView = false;
        inAssociatedView = false;
        inToursView = false;
        inFeedbackView = true;

        // Make an async call to get feedback
        TAG.Worktop.Database.getFeedback(function (result) {
            if (cancel) return;
            sortDate(result);
            currentList = result;
            currentIndex = 0;
            $.each(result, function (i, val) {
                if (cancel) return false;
                // Add each label as a separate function to the queue so the UI doesn&#x27;t lock up
                middleQueue.add(function () {
                    if (cancel) return;
                    if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                        return;
                    }
                    var label;
                    var text = $.datepicker.formatDate(&#x27;(m/dd/yy) &#x27;, new Date(val.Metadata.Date * 1000)) + val.Metadata.Feedback;
                    if (!prevSelectedMiddleLabel &amp;&amp;
                        ((id &amp;&amp; val.Identifier === id) || (!id &amp;&amp; i === 0))) {
                        // Select the first one
                        middleLoading.before(selectLabel(label = createMiddleLabel(text, null, function () {
                            loadFeedback(val);
                            currentIndex = i;
                        }, val.Identifier, true)));

                        // Scroll to the selected label if the user hasn&#x27;t already scrolled somewhere
                        if (middlebar.scrollTop() === 0 &amp;&amp; label.offset().top - middlebar.height() &gt; 0) {
                            middlebar.animate({
                                scrollTop: (label.offset().top - middlebar.height())
                            }, 1000);
                        }

                        prevSelectedMiddleLabel = label;
                        currentSelected = prevSelectedMiddleLabel;
                        loadFeedback(val);
                    } else {
                        middleLoading.before(label = createMiddleLabel(text, null, function () {
                            loadFeedback(val);
                            currentIndex = i;
                        }, val.Identifier, true));
                    }
                    // Hide if it doesn&#x27;t match search criteria
                    if (!TAG.Util.searchString(text, searchbar.val())) {
                        label.hide();
                    }
                });
            });
            // Hide the loading label when we&#x27;re done
            middleQueue.add(function () {
                middleLoading.hide();
            });
        });
        cancelLastSetting = function () { cancel = true; };
    }

    /** Loads feedback to right side of screen
     * @method loadFeedback
     * @param {Object} feedback     feedback to load
     */
    function loadFeedback(feedback) {
        clearRight();
        prepareViewer(true, feedback.Metadata.Feedback);
        deleteType = deleteFeedback;
        toDelete = feedback;

        var sourceLabel = createLabel(&#x27;Loading...&#x27;);
        var dateLabel = createLabel($.datepicker.formatDate(&#x27;DD, MM d, yy &#x27;, new Date(feedback.Metadata.Date * 1000)));
        var source = createSetting(&#x27;Submitted From&#x27;, sourceLabel);
        var dateSetting = createSetting(&#x27;Date&#x27;, dateLabel);

        settingsContainer.append(source);
        var sourceType = feedback.Metadata.SourceType === &quot;Exhibition&quot; ? &quot;Collection&quot; : feedback.Metadata.SourceType;
        if (feedback.Metadata.SourceID) {
            getSourceName(feedback, function (sourceName) {
                sourceLabel.text(sourceName + &#x27; (&#x27; + sourceType + &#x27;)&#x27;);
                var sourceButton = createButton(sourceName + &#x27; (&#x27; + sourceType + &#x27;)&#x27;, function () {
                    followSource(feedback);
                });
                var sourceSetting = createSetting(&#x27;Submitted From&#x27;, sourceButton);
                source.remove();
                dateSetting.prepend(sourceSetting);
            }, function (sourceName) {
                sourceLabel.text(sourceName + &#x27; (&#x27; + sourceType + &#x27;, Deleted)&#x27;);
            }, function () {
                sourceLabel.text(&#x27;Deleted&#x27;);
            });
        } else {
            sourceLabel.text(sourceType + &quot; Page (No &quot; + sourceType + &quot; Selected)&quot;);
        }
        settingsContainer.append(dateSetting);

        var deleteButton = createButton(&#x27;Delete Feedback&#x27;, function () {
            deleteFeedback(feedback);
        },
        {
            &#x27;margin-left&#x27;: &#x27;2%&#x27;,
            &#x27;margin-top&#x27;: &#x27;1%&#x27;,
            &#x27;margin-right&#x27;: &#x27;0%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;3%&#x27;,
        });
        leftButton = deleteButton;
        buttonContainer.append(deleteButton);
    }

    /**Get source of feedback
     * @method getSourceName
     * @param {Object} feedback     feedback to get source of
     * @param {Function} onSuccess  function called if source found
     * @param {Function} onDeleted  function called if source has been deleted
     * @param {Function} onError    function called if there is an error 
     */
    function getSourceName(feedback, onSuccess, onDeleted, onError) {
        TAG.Worktop.Database.getDoq(feedback.Metadata.SourceID,
            function (doq) {
                if (doq.Metadata.Deleted) {
                    onDeleted(doq.Name);
                } else {
                    onSuccess(doq.Name);
                }
            }, function () {
                onError();
            });
    }

    /**Switch view to source of feedback
     * @method followSource
     * @param {Object} feedback     feedback to follow source of
     */
    function followSource(feedback) {
        switch (feedback.Metadata.SourceType) {
            case &quot;Exhibition&quot;:
            case &quot;Exhibitions&quot;:
                switchView(&quot;Exhibitions&quot;, feedback.Metadata.SourceID);
                break;
            case &quot;Tour&quot;:
            case &quot;Tours&quot;:
                switchView(&quot;Tours&quot;, feedback.Metadata.SourceID);
                break;
            case &quot;Art&quot;:
            case &quot;Artwork&quot;:
            case &quot;Artworks&quot;:
                switchView(&quot;Artworks&quot;, feedback.Metadata.SourceID);
                break;
        }
    }

    /**Delete a feedback
     * @method deleteFeedback
     * @param {Object} feedback     feedback to delete
     */
    function deleteFeedback(feedback) {
        prepareNextView(false);
        clearRight();

        // actually delete the feedback
        TAG.Worktop.Database.deleteDoq(feedback.Identifier, function () {
            if (prevSelectedSetting &amp;&amp; prevSelectedSetting !== nav[NAV_TEXT.feedback.text]) {
                return;
            }
            loadFeedbackView();
        }, authError, conflict(feedback), error(loadFeedbackView));
    }

    //Middle Bar Functions:

    /**Create a middle label 
     * @method createMiddleLabel
     * @param  {String} text            the text of the label
     * @param imagesrc                  the source for the image. If not specified no image added
     * @param {Function} onclick        the onclick function for the label
     * @param {Object} id               id to set if specified
     * @param {Function} onDoubleClick  function for double click
     * @param {Boolean} inArtMode 
     * @param extension                 to check if is video or static art
     * @return {Object} container       the container of the new label
     */
    function createMiddleLabel(text, imagesrc, onclick, id, noexpand, onDoubleClick, inArtMode, extension) {
        var container = $(document.createElement(&#x27;div&#x27;));
        text = TAG.Util.htmlEntityDecode(text);
        container.attr(&#x27;class&#x27;, &#x27;middleLabel&#x27;);
        if (id) {
            container.attr(&#x27;id&#x27;, id);
        }

        if (inArtMode) {
            if(extension.match(/mp4/) || extension.match(/ogv/) || extension.match(/webm/)) {
                container.data(&#x27;isVideoArtwork&#x27;, true);
            } else {
                container.data(&#x27;isStaticArtwork&#x27;, true);
            }
        }

        container.mousedown(function () {
            container.css({
                &#x27;background&#x27;: HIGHLIGHT
            });
        });
        container.mouseup(function () {
           container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.mouseleave(function () {
            container.css({
                &#x27;background&#x27;: &#x27;transparent&#x27;
            });
        });
        container.click(function () {
            if (prevSelectedMiddleLabel == container) {
                return;
            }
            //autosave for general settings - switching between customization and password settings
            if (inGeneralView &amp;&amp; changesHaveBeenMade) {
                currentMetadataHandler &amp;&amp; saveQueue.add(currentMetadataHandler());
                changesHaveBeenMade = false;
                generalProgressCircle &amp;&amp; hideLoadingSettings(generalProgressCircle);
            }
            resetLabels(&#x27;.middleLabel&#x27;);
            selectLabel(container, !noexpand);
            if (onclick) {
                onclick();
            }
            prevSelectedMiddleLabel = container;
            currentSelected = container;
        });
        if (onDoubleClick) {
            container.dblclick(onDoubleClick);
        }
        var width;
        if (imagesrc) {
            var image = $(document.createElement(&#x27;img&#x27;));
            image.attr(&#x27;src&#x27;, imagesrc);
            image.css({
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;20%&#x27;,
                &#x27;margin-right&#x27;: &#x27;5%&#x27;,
            });
            container.append(image);
            

            var progressCircCSS = {
                &#x27;position&#x27;: &#x27;absolute&#x27;,
                &#x27;left&#x27;: &#x27;5%&#x27;,
                &#x27;z-index&#x27;: &#x27;50&#x27;,
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;10%&#x27;,
                &#x27;top&#x27;: &#x27;20%&#x27;,
            };
            var circle = TAG.Util.showProgressCircle(container, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, false);
            image.load(function () {
                TAG.Util.removeProgressCircle(circle);
            });
            width = &#x27;75%&#x27;;
        } else {
            width = &#x27;95%&#x27;;
        }

        var label = $(document.createElement(&#x27;div&#x27;));
        label.attr(&#x27;class&#x27;, &#x27;labelText&#x27;);
        label.css({&#x27;width&#x27;: width});

        if (!imagesrc) {
            label.css({
                &#x27;padding-top&#x27;: &#x27;0.4%&#x27;,
                &#x27;padding-left&#x27;: &#x27;1.3%&#x27;,
            });
        }
        label.text(text);

        container.append(label);

        return container;
    }

    /**Set up the middle bar for the next view
     * @method prepareNextView
     * @param {Boolean} showSearch      if true show search bar, otherwise hide
     * @param {String} newText          text for the &#x27;New&#x27; button
     * @param {Function} newBehavior    onclick function for the &#x27;New&#x27; button
     * @param {String} loadingText      Text to display while middle bar loading
     */
    function prepareNextView(showSearch, newText, newBehavior, loadingText) {
        middleQueue.clear();
        middleLabelContainer.empty();
        middleLabelContainer.append(middleLoading);
        middleLoading.show();
        secondaryButton.css(&quot;display&quot;, &quot;none&quot;);
        newButton.text(newText);
        newButton.unbind(&#x27;click&#x27;).click(newBehavior);
        if (!newText) newButton.hide();
        else newButton.show();
        prevSelectedMiddleLabel = null;
        if (cancelLastSetting) cancelLastSetting();

        if (loadingText) {
            middleLoading.children(&#x27;label&#x27;).text(loadingText);
        } else {
            middleLoading.children(&#x27;label&#x27;).text(&#x27;Loading...&#x27;);
        }

        if (showSearch) {
            searchContainer.show();
            searchContainer.css(&#x27;display&#x27;, &#x27;inline-block&#x27;);
            searchbar.val(&quot;&quot;);
        } else {
            searchContainer.hide();
        }
    }

    /**Clears the right side
     * @method clearRight
     */
    function clearRight() {
        settingsContainer.empty();
        buttonContainer.empty();
        rightQueue.clear();
    }

    /**Prepares the viewer on the right side
     * @method prepareViewer
     * @param {Boolean} showViewer    whether the preview window is shown 
     * @param {String} text           text to add to the viewer (in a textbox)
     * @param {Boolean} showButtons   whether the buttonContainer is shown
     */
    function prepareViewer(showViewer,text, showButtons) { 
        viewer.empty();
        viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
        if (showViewer) {
            viewer.show();
            buttonContainer.show();
            buttonContainer.css({
                &#x27;top&#x27;: $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO + &#x27;px&#x27;,
                &#x27;margin-top&#x27;: &#x27;0.35%&#x27;,
            });
            settings.css({
                &#x27;height&#x27;: getSettingsHeight() + &#x27;px&#x27;,
            });
            if (text) {
                var textbox = $(document.createElement(&#x27;textarea&#x27;));
                if (typeof text == &#x27;string&#x27;)
                    text = text.replace(/&lt;br \/&gt;/g, &#x27;\n&#x27;).replace(/&lt;br&gt;/g, &#x27;\n&#x27;).replace(/&lt;br\/&gt;/g, &#x27;\n&#x27;);
                textbox.val(text);
                textbox.css({
                    &#x27;padding&#x27;: &#x27;.5%&#x27;,
                    &#x27;width&#x27;: &#x27;100%&#x27;,
                    &#x27;height&#x27;: &#x27;100%&#x27;,
                    &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
                    &#x27;margin&#x27;: &#x27;0px&#x27;,
                });
                textbox.attr(&#x27;readonly&#x27;, &#x27;true&#x27;);
                viewer.append(textbox);
                viewer.css(&#x27;background&#x27;, &#x27;transparent&#x27;);
            } else {
                viewer.css(&#x27;background&#x27;, &#x27;black&#x27;);
            }
        } else {
            viewer.hide();
            settings.css({
                &#x27;height&#x27;: ($(window).height() * CONTENT_HEIGHT / 100) -
                (BUTTON_HEIGHT * 1) + &#x27;px&#x27;,
            });
        }
        if (showButtons===false){
            buttonContainer.hide();
        }
    }

    //Helper methods for label interaction:

    /**Clicks an element determined by a jquery selector when it is added to the page
     * @method clickWhenReady
     * @param selector
     * @param maxtries
     * @param tries
     */
    function clickWhenReady(selector, maxtries, tries) {
        doWhenReady(selector, function (elem) { elem.click(); }, maxtries, tries);
    }

    /** Calls passed in function when the element determined by the selector
     *  is added to the page
     * @method doWhenReady
     * @param {Object} selector     class or id of object(s) on which fn is performed     
     * @param {Function} fn
     * @param maxtries
     * @param tries
     */
    function doWhenReady(selector, fn, maxtries, tries) {
        maxtries = maxtries || 100;
        tries = tries || 0;
        if (tries &gt; maxtries) return;
        if ($.contains(document.documentElement, $(selector)[0])) {
            fn($(selector));
        } else {
            rightQueue.add(function () {
                doWhenReady(selector, fn, maxtries, tries + 1);
            });
        }
    }

    /**Reset mouse interaction for labels
     * @method resetLabels
     * @param {Object} selector     class of labels to reset
     */
    function resetLabels(selector) {
        
        $(selector).css(&#x27;background&#x27;, &#x27;transparent&#x27;);
        $.each($(selector), function (i, current) {
            
            if ($(current).attr(&#x27;disabled&#x27;) === &#x27;disabled&#x27;) {
                return;
            }
            
            $(current).mousedown(function () {
                
                $(current).css({
                    &#x27;background&#x27;: HIGHLIGHT
                });
            });
            $(current).mouseup(function () {
                
                $(current).css({
                    &#x27;background&#x27;: &#x27;transparent&#x27;
                });
            });
            $(current).mouseleave(function () {
                
                $(current).css({
                    &#x27;background&#x27;: &#x27;transparent&#x27;
                });
            });
        });
    }

    /**Select a label by unbinding mouse events and highlighting
     * @method selectLabel
     * @param {Object} label    label to select
     * @param {Boolean} expand  if label expands when selected 
     * @param {Integer} index   index of the selected label in it&#x27;s relvant list.  
     * @return {Object} label   selected label   
     */
    function selectLabel(label, expand) {
        label.css(&#x27;background&#x27;, HIGHLIGHT);
        label.unbind(&#x27;mousedown&#x27;).unbind(&#x27;mouseleave&#x27;).unbind(&#x27;mouseup&#x27;);
        
        if (expand) {
            label.css(&#x27;height&#x27;, &#x27;&#x27;);
            label.children(&#x27;div&#x27;).css(&#x27;white-space&#x27;, &#x27;&#x27;);

            if (prevSelectedMiddleLabel) {
                prevSelectedMiddleLabel.children(&#x27;div&#x27;).css(&#x27;white-space&#x27;, &#x27;nowrap&#x27;);
            }
        }
        return label;
    }

    /**Disable a label, unbinding mouse events
     * @method disableLabel
     * @param {Object} label         label to disable
     * @return {Object} label        disabled label
     */
    function disableLabel(label) {
        label.css({
            &#x27;color&#x27;: &#x27;gray&#x27;,
        });
        label.unbind(&#x27;mousedown&#x27;).unbind(&#x27;mouseleave&#x27;).unbind(&#x27;mouseup&#x27;).unbind(&#x27;click&#x27;).attr(&#x27;disabled&#x27;, true);
        return label;
    }

   
    //Settings functions:

    /**Gets the height of the settings section since the viewer has to be positioned absolutely,
     *the entire right bar needs to be position absolutely. Settings has bottom: 0, so the height needs to be correct
     * to not have this be under the buttons container.  If any of the heights of the right components changes it should be
     * updated here.
     * @method getSettingsHeight
     * @return height       appropriate height for settings
     */
    function getSettingsHeight() {
        var height =
        // Start with the entire height of the right side
        ($(window).height() * CONTENT_HEIGHT / 100) -
        // Subtract:
        (
            // Height of the viewer
            $(window).width() * RIGHT_WIDTH / 100 * 1 / VIEWER_ASPECTRATIO +
            // Height of the button container
            BUTTON_HEIGHT * 1 +
            // Height of the padding of the button container
            $(window).width() * RIGHT_WIDTH / 100 * 0.0285
        );
        return height;
    }

    /**Creates a setting to be inserted into the settings container
     * @method createSetting
     * @param {String} text     text for the setting
     * @param {Object} input    the input for the setting
     * @param width             if not falsey then assumed to be number represengint percent, must be less than 95
     * @return container        container of new setting
     */
    function createSetting(text, input, width, labelLeft) {
        var container = $(document.createElement(&#x27;div&#x27;));
        container.css({
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;4%&#x27;,
        });

        var label = $(document.createElement(&#x27;div&#x27;));
        label.css({
            //&#x27;font-size&#x27;: SETTING_FONTSIZE,
            &#x27;width&#x27;: width ? 45 - (width - 50) + &#x27;%&#x27; : &#x27;45%&#x27;,
            &#x27;overflow&#x27;: &#x27;hidden&#x27;,
            &#x27;text-overflow&#x27;: &#x27;ellipsis&#x27;,
            &#x27;font-style&#x27;: &#x27;italic&#x27;,
            &#x27;display&#x27;: &#x27;inline-block&#x27;,
            &#x27;margin-left&#x27;: labelLeft,
        });
        label.text(text);

        if (width) {
            width = width + &#x27;%&#x27;;
        } else {
            width = &#x27;50%&#x27;;
        }
        input.css({
            &#x27;width&#x27;: width,
            //&#x27;font-size&#x27;: INPUT_FONTSIZE,
            &#x27;float&#x27;: &#x27;right&#x27;,
            &#x27;margin-right&#x27;: &#x27;3%&#x27;,
            &#x27;box-sizing&#x27;: &#x27;border-box&#x27;,
        });

        var clear = $(document.createElement(&#x27;div&#x27;));
        clear.css(&#x27;clear&#x27;, &#x27;both&#x27;);

        container.append(label);
        container.append(input);
        container.append(clear);

        return container;
    }

    //Helper functions:


    /* Create a linked year metadata input div 
    * @method createYearMetadataDiv
    * @param {Object} work                      artwork or media you are editting
    * @return {Object} yearMetadataDivSpecs     div with year and timeline year options, list of input fields
    */
    function createYearMetadataDiv(work){
        
        var yearInput,
            monthInput,
            dayInput,
            timelineInputText,
            timelineYearInput,
            timelineYearJustChanged = false,
            timelineMonthInput,
            timelineDayInput,
            timelineYearDiv = $(document.createElement(&#x27;div&#x27;)),
            yearDiv = $(document.createElement(&#x27;div&#x27;)),
            year,
            month,
            day,
            timelineYear,
            timelineMonth,
            timelineDay,
            timelineYearAutofilled = false,
            timelineYearAllowed = true,
            yearMetadataDiv= $(document.createElement(&#x27;div&#x27;)),
            yearMetadataDivSpecs;

        //Create input boxes: 
        yearInput = createTextInput(TAG.Util.htmlEntityDecode(work.Metadata.Year), true, 20);
        monthInput = createSelectInput(getMonthOptions(yearInput.attr(&#x27;value&#x27;)), work.Metadata.Month);
        monthInput.css(&#x27;margin-right&#x27;, &#x27;0%&#x27;);
        dayInput = createSelectInput(getDayOptions(monthInput.attr(&#x27;value&#x27;),yearInput,monthInput), work.Metadata.Day);
        dayInput.css(&#x27;margin-right&#x27;, &#x27;0%&#x27;);
        timelineInputText = work.Metadata.TimelineYear || getTimelineInputText(yearInput);
        timelineYearInput = createTextInput(timelineInputText, true, 20);
        if (timelineYearInput.val()===&#x27;&#x27;){
            timelineYearInput.attr(&#x27;placeholder&#x27;, &#x27;Type valid year&#x27;);
        }
        timelineMonthInput = createSelectInput(getMonthOptions(timelineYearInput.attr(&#x27;value&#x27;)),work.Metadata.TimelineMonth);
        timelineMonthInput.css(&#x27;margin-right&#x27;,&#x27;0%&#x27;);
        timelineDayInput = createSelectInput(getDayOptions(timelineMonthInput.attr(&#x27;value&#x27;),timelineYearInput,timelineMonthInput), work.Metadata.TimelineDay);
        timelineDayInput.css(&#x27;margin-right&#x27;, &#x27;0%&#x27;);
        yearInput.attr(&#x27;id&#x27;, &#x27;yearInput&#x27;);
        //Add focus to inputs:
        yearInput.focus(function () {
            if (yearInput.val() === &#x27;Year&#x27;){
                yearInput.select();
            }
        });
        monthInput.focus(function(){
            if (monthInput.val() === &#x27;Month&#x27;){
                monthInput.select();
            }
        });
        dayInput.focus(function(){
            if (dayInput.val() === &#x27;Day&#x27;){
                dayInput.select();
            }
        });
        timelineYearInput.focus(function(){
            if (timelineYearInput.val() === &#x27;Date on Timeline&#x27;){
                timelineYearInput.select();
            }
        });
        timelineMonthInput.focus(function(){
            if (timelineMonthInput.val() === &quot;Month&quot;){
                timelineMonthInput.select();
            }
        });
        timelineDayInput.focus(function(){
            if (timelineDayInput.val() === &quot;Day&quot;){
                timelineDayInput.select();
            }
        });

        //Set up year div:
        //TO-DO: add (?) icon w/ pop-up
        yearDiv.css({
            width : &#x27;100%&#x27;,
            height : &#x27;20px&#x27;,
            &#x27;margin-bottom&#x27; : &#x27;4%&#x27;
        });
        year = createSetting(&#x27;Year&#x27;, yearInput, 60);
        year.css({
            width: &#x27;32%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        month = createSetting(&#x27;Month&#x27;, monthInput, 60);
        month.css({
            width: &#x27;32%&#x27;,
            &#x27;padding-left&#x27;: &#x27;1%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        toggleAllow(monthInput);
        day = createSetting(&#x27;Day&#x27;, dayInput, 70);
        day.css({
            width: &#x27;30%&#x27;,
            &#x27;padding-left&#x27;: &#x27;2%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        toggleAllow(dayInput);
        yearDiv.append(year)
               .append(month)
               .append(day);

        //Set up timeline year div:
        //TO-DO add (?) icon w/ pop-up
        timelineYearDiv.css({
            width: &#x27;100%&#x27;,
            height: &#x27;20px&#x27;,
            &#x27;margin-bottom&#x27;: &#x27;4%&#x27;
        });
        timelineYear = createSetting(&#x27;Date on Timeline&#x27;, timelineYearInput, 40);
        timelineYear.css({
            width: &#x27;47%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        timelineMonth = createSetting(&#x27;Month&#x27;, timelineMonthInput, 50);
        timelineMonth.css({
            width: &#x27;27%&#x27;,
            &#x27;padding-left&#x27;: &#x27;1%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        toggleAllow(timelineMonthInput);
        timelineDay = createSetting(&#x27;Day&#x27;, timelineDayInput, 60);
        timelineDay.css({
            width : &#x27;20%&#x27;,
            &#x27;padding-left&#x27;: &#x27;2%&#x27;,
            display: &#x27;inline-block&#x27;
        });
        toggleAllow(timelineDayInput);
        timelineYearDiv.append(timelineYear)
                       .append(timelineMonth)
                       .append(timelineDay);

        //Link input values of date fields to dynamically change/disable               
        yearInput.on(&#x27;input&#x27;, function(){
            setOptions(monthInput, getMonthOptions(yearInput.attr(&#x27;value&#x27;)),&#x27;&#x27;);
            toggleAllow(monthInput);
            setOptions(dayInput, getDayOptions(monthInput.attr(&#x27;value&#x27;),yearInput,monthInput));
            toggleAllow(dayInput);
            if (!timelineYearJustChanged|| timelineYearInput.val()===&#x27;&#x27;){
                timelineYearInput.val(getTimelineInputText(yearInput));
                if (timelineYearInput.val()===&#x27;&#x27;){
                    timelineYearInput.attr(&#x27;placeholder&#x27;,&#x27;Type valid year&#x27;);
                }
                timelineYearJustChanged = false;
                setOptions(timelineMonthInput, getMonthOptions(timelineYearInput.attr(&quot;value&quot;)));
                toggleAllow(timelineMonthInput);
                setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr(&quot;value&quot;),timelineYearInput,timelineMonthInput));
                toggleAllow(timelineDayInput);
            }
            timelineYearAutofilled = false;
        });
        monthInput.change(function(){
            setOptions(dayInput,getDayOptions(monthInput.attr(&quot;value&quot;),yearInput,monthInput),dayInput.attr(&#x27;value&#x27;));
            toggleAllow(dayInput);
            if (timelineMonthInput.attr(&quot;value&quot;) === &quot;&quot;) {
                timelineMonthInput.attr(&quot;value&quot;,monthInput.attr(&quot;value&quot;));
                setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr(&quot;value&quot;),timelineYearInput,timelineMonthInput));
                toggleAllow(timelineDayInput);
            }
        });
        dayInput.change(function(){
            if (timelineDayInput.attr(&quot;value&quot;)=== &quot;&quot; &amp;&amp; timelineDayInput.dropDownOptions.length&gt;1){
                timelineDayInput.attr(&quot;value&quot;, dayInput.attr(&quot;value&quot;));
            };
        });
        timelineYearInput.on(&#x27;input&#x27;, function(){
            if (timelineYearInput.attr(&#x27;value&#x27;).length===0 &amp;&amp; !timelineYearAutofilled){
                timelineYearInput.val(getTimelineInputText(yearInput));
                timelineMonthInput.val(monthInput.attr(&quot;value&quot;));
                timelineDayInput.val(dayInput.attr(&quot;value&quot;));
                timelineYearAutofilled = true;
            } 
            timelineYearJustChanged = true;
            if ( timelineYearInput.attr(&#x27;value&#x27;).length&gt;0 &amp;&amp;!isSingleYear(timelineYearInput.attr(&#x27;value&#x27;))){
                timelineYearAllowed = false;
                timelineYearInput.css({
                    &#x27;border-color&#x27;: &#x27;red&#x27;,
                    &#x27;border-width&#x27; : &#x27;medium&#x27;,
                    &#x27;opacity&#x27; : &#x27;0.7&#x27;
                });
            } else {
                timelineYearAllowed = true;
                timelineYearInput.css({
                    &#x27;border-color&#x27; : &#x27;#a7b4ae&#x27;,
                    &#x27;border-width&#x27;: &#x27;thin&#x27;,
                    &#x27;opacity&#x27;: &#x27;1&#x27;
                });
            }
            setOptions(timelineMonthInput, getMonthOptions(timelineYearInput.attr(&#x27;value&#x27;)),&#x27;&#x27;);
            toggleAllow(timelineMonthInput, timelineYearAllowed);
            setOptions(timelineDayInput, getDayOptions(timelineMonthInput.attr(&#x27;value&#x27;),timelineYearInput,timelineMonthInput),&#x27;&#x27;);
            toggleAllow(timelineDayInput, timelineYearAllowed);
        });
        timelineMonthInput.change(function(){
            setOptions(timelineDayInput,getDayOptions(timelineMonthInput.attr(&quot;value&quot;),timelineYearInput,timelineMonthInput),timelineDayInput.attr(&#x27;value&#x27;));
            toggleAllow(timelineDayInput, true);
        });

        //Set up year metadatadiv
        yearMetadataDiv.css({
            &#x27;width&#x27; : &#x27;100%&#x27;
        });
        yearMetadataDiv.append(yearDiv)
                       .append(timelineYearDiv); 

        yearMetadataDivSpecs = {
            yearMetadataDiv : yearMetadataDiv,
            yearInput : yearInput,
            monthInput: monthInput,
            dayInput: dayInput,
            timelineYearInput: timelineYearInput,
            timelineMonthInput: timelineMonthInput,
            timelineDayInput: timelineDayInput
        }

        return yearMetadataDivSpecs;

        //Helper functions:

        /*Get month options based on year
         * @method getMonthOptions
         * @param {String} year         year used to determine month options
         * @return {Array}              list of options to use in month drop down
         */
        function getMonthOptions(year){
            if (!isSingleYear(year)){
                return [&#x27;&#x27;];
            } else {
                return [&#x27;&#x27;,&#x27;January&#x27;,&#x27;February&#x27;,&#x27;March&#x27;,&#x27;April&#x27;,&#x27;May&#x27;,&#x27;June&#x27;,&#x27;July&#x27;,&#x27;August&#x27;,&#x27;September&#x27;,&#x27;October&#x27;,&#x27;November&#x27;,&#x27;December&#x27;];
            }
        }

        /*Get input text for timeline year input
         * @method getTimelineInputText
         * @param {Object} yearInput        year input field
         * @return {String} timelineInputText   text to display in timelineYearInput 
         */
        function getTimelineInputText(yearInput){
            var timelineInputText = TAG.Util.parseDateToYear({ year : yearInput.attr(&#x27;value&#x27;)});
            if (timelineInputText){
                if (timelineInputText&lt;0){
                    return -timelineInputText + &#x27; BCE&#x27;;
                }
                else {
                    return timelineInputText;
                }
            } else{
                return &#x27;&#x27;;
            }
        }

        /* returns whether a date input is a single year
         * @method isSingleYear
         * @param {String} dateString      string to parse
         * @return {Boolean}               whether input string represents single year
         */
        function isSingleYear(dateString){
            dateString = dateString.replace(/bce?/gi,&#x27;&#x27;)
                                   .replace(/ce/gi, &#x27;&#x27;)
                                   .replace(/ad/gi,&#x27;&#x27;)
                                   .replace(/\s/gi,&#x27;&#x27;);
            if (dateString.search(/[^0-9||-]/)&gt;=0 || dateString.length===0){
                return false;
            } else {
                return true;
            }
        }
        
        /*Get day options based on month using test date
         * @method getDayOptions
         * @param {String} month
         * @return {Array} dayArray     array of day drop down options
         */
        function getDayOptions(month, yearIn, monthIn){
            var dayArray = [&#x27;&#x27;],
                testDate,
                daysInMonth,
                i;
            if (month === &#x27;&#x27;) { 
                return dayArray;
            }
            testDate = new Date(TAG.Util.parseDateToYear({year: yearIn.attr(&#x27;value&#x27;)}), monthIn.dropDownOptions.indexOf(month), 0);
            daysInMonth = testDate.getDate();
            for (i=1;i&lt;daysInMonth+1;i++){
                dayArray.push(i);
            }
            return dayArray;
        }
        
        /*Set drop down options of a select input
         * @method setOptions()
         * @param {Object} select       select input
         * @param {Object} options      options to add to drop down
         * @param {String} value        selected value
         */
        function setOptions(select, options, value){
            var option,
                i;
            select.empty();
            select.dropDownOptions = options;
            for (i=0; i&lt;options.length; i++) {
                option = $(document.createElement(&#x27;option&#x27;));
                option.text(options[i]);
                option.attr(&#x27;value&#x27;, options[i]);
                select.append(option);
                options[i].selected = true;
            }
            select.attr(&#x27;value&#x27;, value);
        }

        /*Set styling of a select input based on if its allowed
        * @param {Object} select        select input to style
        * @param {Boolean} allowed      whether its allowed (optional)
        * @return {Boolean}             whether its allowed
        */
        function toggleAllow(select, allowed){
            if (select.dropDownOptions.length === 1 || allowed === &quot;false&quot;){
                select.css({
                    &#x27;background-color&#x27;: &#x27;gray&#x27;,
                    &#x27;opacity&#x27; : &#x27;0.3&#x27;,
                });
                return false;
            }
            else {
                select.css({
                    &#x27;background-color&#x27;: &#x27;white&#x27;,
                    &#x27;opacity&#x27; : &#x27;1&#x27;
                });
                return true;
            } 
        }
    }

    /** Create a button 
     * @method createButton
     * @param {String} text         button text
     * @param {Function} onclick    onclick function for button
     * @param css                   additional css to apply to button if specified
     * @return {Object} button      new button created
     */
    function createButton(text, onclick, css) {
        var button = $(document.createElement(&#x27;button&#x27;)).text(text);
        button.attr(&#x27;type&#x27;, &#x27;button&#x27;);
        button.attr(&#x27;class&#x27;,&#x27;button&#x27;);
        if (css) {
            button.css(css);
        }
        button.click(onclick);
        return button;
    }

    /**Create a label
     * @method createLabel
     * @param {String} text         label text
     * @return {Object} label       new label created
     */
    function createLabel(text) {
        var label = $(document.createElement(&#x27;label&#x27;)).text(text || &quot;&quot;);
        return label;
    }

    /**Create a text input
     * @method createTextInput
     * @param {String} text         the default text for the input
     * @param {Boolean} defaultval  if true, reset to default text if empty and loses focus
     * @param maxlength             max length of the input in characters
     * @param hideOnClick
     * @return input                newly created input
     */
    function createTextInput(text, defaultval, maxlength, hideOnClick, readonly) {
        var input = $(document.createElement(&#x27;input&#x27;)).val(text);
        input.attr(&#x27;autocomplete&#x27;, &#x27;off&#x27;);
        input.attr(&#x27;spellcheck&#x27;, &#x27;false&#x27;);
        input.attr({
            &#x27;type&#x27;: &#x27;text&#x27;,
            &#x27;maxlength&#x27;: maxlength,
            &#x27;readonly&#x27;: !!readonly
        });
        return input;
    }

    /**Create a text area input 
     * @method createTextAreaInput
     * @param {String} text     default text for area
     * @param defaultval
     * @param hideOnClick
     * @return {Object} input    newly creted text input
     */
    function createTextAreaInput(text, defaultval, hideOnClick) {
        if (typeof text === &#x27;string&#x27;)
            text = text.replace(/&lt;br \/&gt;/g, &#x27;\n&#x27;).replace(/&lt;br&gt;/g, &#x27;\n&#x27;).replace(/&lt;br\/&gt;/g, &#x27;\n&#x27;);
        var input = $(document.createElement(&#x27;textarea&#x27;)).val(text);
        input.css(&#x27;overflow-y&#x27;, &#x27;scroll&#x27;);
        //input.autoSize();
        doWhenReady(input, function (elem) {
            var realHeight = input[0].scrollHeight;
            $(input).css(&#x27;height&#x27;, realHeight + &#x27;px&#x27;);
        });
        return input;
    }

    /**Create a drop-down input element with a list to add options to
     * @method createSelectInput
     * @param {Array} options               list of options in the drop-down
     * @param {Object} value                current value of select menu
     * @return {HTML element} selectElt     element of type &#x27;select&#x27;
     */
    function createSelectInput(options, value) {
        var selectElt = $(document.createElement(&#x27;select&#x27;)),
            option,
            i;
        selectElt.css({ &#x27;overflow&#x27;: &#x27;scroll&#x27; });
        selectElt.dropDownOptions = options;
        for (i=0; i&lt;options.length; i++) {
            option = $(document.createElement(&#x27;option&#x27;));
            option.text(options[i]);
            option.attr(&#x27;value&#x27;, options[i]);
            selectElt.append(option);
            options[i].selected = true;
        }
        selectElt.attr(&#x27;value&#x27;, value);
        return selectElt;
    }

    /**Create a color input which modifies the background color
     * of all elements matching the jquery selector &#x27;selector&#x27;.
     * @method creatBGColorInput 
     * @param color 
     * @param selectorBackground            jQuery selector for elements background to be changed
     * @param selectorText                  jQuery selector for color of text in the element to be changed
     * @param {Function} getTransValue      returns a valid transparency value  
     * @return {Object} container           returns container holding new input
     */
    function createBGColorInput(color, selectorBackground, selectorText, getTransValue) {
        if (color.indexOf(&#x27;#&#x27;) !== -1) {
            color = color.substring(1, color.length);
        }
        var container = $(document.createElement(&#x27;input&#x27;));
        container.attr(&#x27;type&#x27;, &#x27;text&#x27;);
        var picker = new jscolor.color(container[0], {});
        var hex = TAG.Util.UI.colorToHex(color);
        container.val(color);
        picker.fromString(color);
        picker.onImmediateChange = function () {
            if(selectorText) {
                updateTextColor(selectorText, container.val());
            } 
            if(selectorBackground) {
                updateBGColor(selectorBackground, container.val(), getTransValue());
            }
        };
        return container;
    }

    /**Set the bg color of elements maching jquery selector &#x27;selector&#x27;
     * @method updateBGColor 
     * @param selector          jQuery selector of elements to be changed
     * @param hex               hex value of color
     * @param trans             transparency of color
     */
    function updateBGColor(selector, hex, trans) {
        $(selector).css(&#x27;background-color&#x27;, TAG.Util.UI.hexToRGB(hex) + trans / 100.0 + &#x27;)&#x27;);

    }

    /**Sets the text color of text in the jQuery selector passed in
     * @method updateTextColor
     * @param {HTML element} selector          jQuery selector, the color of text inside the selector is changed
     * @param {Hex Value} color                color passed in as a hex value
     */
    function updateTextColor(selector, color) {
        $(selector).css({ &#x27;color&#x27;: &#x27;#&#x27; + color });
    }

    /**Prevent a container from being clicked on by added a div on top of it
     * @method preventClickthrough
     * @param {Object} container     container to prevent click through of
     */
    function preventClickthrough(container) {
        var cover = document.createElement(&#x27;div&#x27;);
        $(cover).css({
            &#x27;height&#x27;: &#x27;100%&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;float&#x27;: &#x27;left&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;background-color&#x27;: &#x27;white&#x27;,
            &#x27;opacity&#x27;: &#x27;0&#x27;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;right&#x27;: &#x27;0px&#x27;,
            &#x27;z-index&#x27;: &#x27;499&#x27;,
        });
        $(cover).bind(&#x27;click&#x27;, function () { return false; });
        $(container).append(cover);
    }

    /**Sort a list with propery Name alphabetically, case insensitive
     * @method sortAZ
     * @param {Object} list
     * @return 
     */
    function sortAZ(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aLower = a.Name.toLowerCase();
                var bLower = b.Name.toLowerCase();
                return (aLower &lt; bLower) ? -1 : 1;
            });
        }
    }

    /**Sort a list with date metadata by date with most recent date first
     * @method sortDate
     * @param {Object} list 
     * @return 
     */
    function sortDate(list) {
        if (list.sort) {
            list.sort(function (a, b) {
                var aint = parseInt(a.Metadata.Date, 10);
                var bint = parseInt(b.Metadata.Date, 10);
                if (aint &lt; bint) {
                    return 1;
                } else if (aint &gt; bint) {
                    return -1;
                } else {
                    return 0;
                }
            });
        }
    }

    /**Perform a search 
     * @method search
     * @param val           value to search for
     * @param selector      jQuery selector of elements to search
     * @param childType     selector&#x27;s type
     */
    function search(val, selector, childType) {
        $.each($(selector), function (i, child) {
            if ($(child).attr(&#x27;id&#x27;) === &#x27;middleLoading&#x27;)
                return;
            if (TAG.Util.searchString($(child).children(childType).text(), val)) {
                $(child).show();
            } else {
                $(child).hide();
            }
        });
    }

    /**Search data
     * @param val       value to search for
     * @param selector  jQuery selector for elements to be searched
     */
    function searchData(val, selector) {
        $.each($(selector), function (i, element) {
            var data = $(element).data();
            var show = false;
            $.each(data, function (k, v) {
                if (TAG.Util.searchString(v, val)) {
                    show = true;
                }
            });
            if (show) {
                $(element).show();
            } else {
                $(element).hide();
            }
        });
    }

    /**Update text on change
     * @method onChangeUpdateText
     * @param {Object} input    input to update
     * @param selector          jQuery selector of element to update
     * @param maxLength         maximum text length in characters
     * @return {Object}         updated input
     */
    function onChangeUpdateText(input, selector, maxlength) {
        input.keyup(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        input.keydown(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        input.change(function () {
            if (input.val().length &gt; maxlength) {
                input.val(input.val().substring(0, maxlength));
            }
            $(selector).html(input.val().replace(/\n\r?/g, &#x27;&lt;br /&gt;&#x27;));
        });
        return input;
    }

    /**Update a text input that takes in a number
     * @method onChangeUpdateNum
     * @param {Object} input            input to update
     * @param min                       minimum value of inputted number
     * @param max                       maximum value of inputted number
     * @param {Function} doOnChange     performed if input value is number between min and max   
     */
    function onChangeUpdateNum(input, min, max, doOnChange) {
        input.keyup(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.keydown(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
        input.change(function () {
            var replace = input.val().replace(/[^0-9]/g, &#x27;&#x27;);
            replace = Math.constrain(parseInt(replace, 10), min, max);
            if (isNaN(replace)) replace = 0;
            if (input.val() !== replace + &#x27;&#x27;) {
                input.val(replace);
            }
            if (doOnChange)
                doOnChange(replace);
        });
    }


    /**from JavaScript: The Good Parts
     * @method is_array
     * @param value         value to check
     * @return {Boolean}    if value is an array
     */
    function is_array(value) {
        return Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;;
    }

    /** Upload a file then calls the callback with the url and name of the file.
     * @method uploadFIle
     * @param type                  See TAG.Authoring.FileUploader for &#x27;type&#x27; values
     * @param {Function} callback   
     * @param multiple              for batch upload
     * @param filter    
     */
    function uploadFile(type, callback, multiple, filter) {
        var names = [], locals = [], contentTypes = [], fileArray, i;
        TAG.Authoring.FileUploader( // remember, this is a multi-file upload
            root,
            type,
            // local callback - get filename
            function (files, localURLs) {
                fileArray = files;
                for (i = 0; i &lt; files.length; i++) {
                    names.push(files[i].displayName);
                    if (files[i].contentType.match(/image/)) {
                        contentTypes.push(&#x27;Image&#x27;);
                    } else if (files[i].contentType.match(/video/)) {
                        contentTypes.push(&#x27;Video&#x27;);
                    } else if (files[i].contentType.match(/audio/)) {
                        contentTypes.push(&#x27;Audio&#x27;);
                    } else if (files[i].name.match(&#x27;\.woff&#x27;)) {
                        contentTypes.push(&#x27;Font&#x27;);
                    }
                }
            },
            // remote callback - save correct name
            function (urls) {
                if (!is_array(urls)) { // check to see whether a single file was returned
                    urls = [urls];
                    names = [names];
                }
                for (i = 0; i &lt; urls.length; i++) {
                    console.log(&quot;urls[&quot; + i + &quot;] = &quot; + urls[i] + &quot;, names[&quot; + i + &quot;] = &quot; + names[i]);
                }
                callback(urls, names, contentTypes, fileArray);
            },
            filter || [&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.gif&#x27;, &#x27;.tif&#x27;, &#x27;.tiff&#x27;, &#x27;.woff&#x27;],
            false,
            function () {
                root.append(TAG.Util.UI.popUpMessage(null, &quot;There was an error uploading the file.  Please try again later.&quot;));
            },
            !!multiple // batch upload disabled
            );
    }

    /**Create an overlay over the whole settings view with a spinning circle and centered text. This overlay is intended to be used 
     * only when the page is &#x27;done&#x27;.  The overlay doesn&#x27;t support being removed from the page, so only call this when the page will 
     * be changed!
     * @method loadingOverlay
     * @param {String} text     Text defaults to &#x27;Loading...&#x27; if not specified. 
     */
    function loadingOverlay(text) {
        text = text || &quot;Loading...&quot;;
        var overlay = $(document.createElement(&#x27;div&#x27;));
        overlay.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;0px&#x27;,
            &#x27;top&#x27;: &#x27;0px&#x27;,
            &#x27;width&#x27;: &#x27;100%&#x27;,
            &#x27;height&#x27;: &#x27;100%&#x27;,
            &#x27;background-color&#x27;: &#x27;rgba(0,0,0,0.5)&#x27;,
            &#x27;z-index&#x27;: &#x27;1000&#x27;,
        });
        root.append(overlay);

        var circle = $(document.createElement(&#x27;img&#x27;));
        circle.attr(&#x27;src&#x27;, tagPath + &#x27;images/icons/progress-circle.gif&#x27;);
        circle.css({
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;10%&#x27;,
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;45%&#x27;,
            &#x27;top&#x27;: ($(window).height() - $(window).width() * 0.1) / 2 + &#x27;px&#x27;,
        });
        overlay.append(circle);

        var widthFinder = $(document.createElement(&#x27;div&#x27;));
        widthFinder.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;visibility&#x27;: &#x27;hidden&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;auto&#x27;,
            &#x27;font-size&#x27;: &#x27;200%&#x27;,
        });
        widthFinder.text(text);
        root.append(widthFinder);

        var label = $(document.createElement(&#x27;label&#x27;));
        label.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: ($(window).width() - widthFinder.width()) / 2 + &#x27;px&#x27;,
            &#x27;top&#x27;: ($(window).height() - $(window).width() * 0.1) / 2 + $(window).width() * 0.1 + &#x27;px&#x27;,
            &#x27;font-size&#x27;: &#x27;200%&#x27;,
            &#x27;color&#x27;: &#x27;white&#x27;,
        });
        widthFinder.remove();
        label.text(text);
        overlay.append(label);
    }
    
    /** Authentication error function
     * @method authError
     */
    function authError() {
        var popup = TAG.Util.UI.popUpMessage(function () {
            TAG.Auth.clearToken();
            rightQueue.clear();
            middleQueue.clear();
            TAG.Layout.StartPage(null, function (page) {
                TAG.Util.UI.slidePageRight(page);
            });
        }, &quot;Could not authenticate, returning to the splash page.&quot;, null, true);
        root.append(popup);
        $(popup).show();
    }

    /**Error function
     * @method error
     * @param {Function} fn     function called if specified
     */
    function error(fn) {
        return function () {
            var popup = TAG.Util.UI.popUpMessage(null, &quot;An unknown error occured.&quot;, null, true);
            root.append(popup);
            $(popup).show();
            fn &amp;&amp; fn();
        }
    }

    /**Conflict function
    * @method conflict
    * @param doq            doq for which there is a conflict
    * @param {String} text      
    * @param fail
    */
    function conflict(doq, text, fail) {
        return function (jqXHR, ajaxCall) {
            var confirmationBox = TAG.Util.UI.PopUpConfirmation(function () {
                ajaxCall.force();
                // TODO: Text for change/delete
            }, &quot;Your version of &quot; + doq.Name + &quot; is not up to date.  Are you sure you want to change &quot; + doq.Name + &quot;?&quot;, text, true, fail);
            root.append(confirmationBox);
            $(confirmationBox).show();
        }
    }

    function displayLoadingSettings() {
        settingsContainer.css({ visibility: &#x27;hidden&#x27; });
        settings.css({ overflow: &#x27;hidden&#x27; });
        buttonContainer.css({ visibility: &#x27;hidden&#x27; });
        var changeLabel = createLabel(&#x27;Changes are being saved...&#x27;);
        changeLabel.attr(&#x27;id&#x27;, &#x27;changeLabel&#x27;);
        changeLabel.css({
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;top&#x27;: &#x27;15%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;33%&#x27;,
            &#x27;color&#x27;: &#x27;black&#x27;,
            &#x27;font-size&#x27;: &#x27;140%&#x27;
        });
        var progressCircCSS = {
            &#x27;position&#x27;: &#x27;absolute&#x27;,
            &#x27;left&#x27;: &#x27;40%&#x27;,
            &#x27;top&#x27;: &#x27;20%&#x27;,
            &#x27;z-index&#x27;: &#x27;50&#x27;,
            &#x27;height&#x27;: &#x27;auto&#x27;,
            &#x27;width&#x27;: &#x27;20%&#x27;
        };
        var progressCL = LADS.Util.showProgressCircle(settings, progressCircCSS, &#x27;0px&#x27;, &#x27;0px&#x27;, true);
        settings.append(changeLabel);
        return progressCL;
    };

    function hideLoadingSettings(circle) {
        $(&#x27;#changeLabel&#x27;).remove();
        settingsContainer.css({ visibility: &#x27;visible&#x27; });
        settings.css({ overflow: &#x27;auto&#x27; });
        buttonContainer.css({ visibility: &#x27;visible&#x27; });
        circle &amp;&amp; LADS.Util.removeProgressCircle(circle);
    };

    function showLoading() {
        leftLabelContainer.empty();
        leftLabelContainer.append(createLeftLoading());
        buttonContainer.css({ visibility: &#x27;hidden&#x27; });
        prepareViewer(true);
        pCircle2 = displayLoadingSettings();
    };

    function hideLoading() {
        buttonContainer.css({ visibility: &#x27;visible&#x27; });
        hideLoadingSettings(pCircle2);
    };

    function backButtonClickHandler() {
        LADS.Auth.clearToken();
        rightQueue.clear();
        leftQueue.clear();
        $(&#x27;#backButton&#x27;).off(&#x27;click&#x27;);
        if (backPage) {
            var bpage = backPage();
            LADS.Util.UI.slidePageRight(bpage);
        } else {
            LADS.Layout.StartPage(null, function (page) {
                LADS.Util.UI.slidePageRight(page);
            });
        }
    };

    return that;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
