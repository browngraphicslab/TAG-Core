TAG.Util.makeNamespace("TAG.Layout.ArtworkViewer");

/**
 * The artwork viewer, which contains a sidebar with tools and thumbnails as well
 * as a central area for the deepzoom image.
 * @class TAG.Layout.ArtworkViewer
 * @constructor
 * @param {Object} options              some options for the artwork viewer page
 * @param {HTML Element} container      the root container 
 * @return {Object}                     some public methods
 */
TAG.Layout.ArtworkViewer = function (options, container) { // prevInfo, options, exhibition) {
    "use strict";

    options = options || {}; // cut down on null checks later

    var // DOM-related
        root                = TAG.Util.getHtmlAjax('Artmode.html'),
        sideBar             = root.find('#sideBar'),
        toggler             = root.find('#toggler'),
        togglerImage        = root.find('#togglerImage'),
        backButton          = root.find('#backButton'),
        linkButton          = root.find('#linkButton'),
        linkButtonContainer = root.find('#linkContainer'),
        //locHistoryDiv       = root.find('#locationHistoryDiv'),
        info                = root.find('#info'),
        loadingArea          = root.find('#loadingArea'),
        locHistory          = root.find('#locationHistory'),
        locHistoryContainer = root.find('#locationHistoryContainer'),
        locationPanelDiv = null,
        locHistoryToggle = null,
        isOpen = false,
        that = this,
        locked = TAG.Worktop.Database.getLocked(),     //Check for locked
        // constants
        FIX_PATH = TAG.Worktop.Database.fixPath,
        PRIMARY_FONT_COLOR = options.primaryFontColor ? options.primaryFontColor : TAG.Worktop.Database.getMuseumPrimaryFontColor(),
        SECONDARY_FONT_COLOR = options.secondaryFontColor ? options.secondaryFontColor : TAG.Worktop.Database.getMuseumSecondaryFontColor(),
        FONT = TAG.Worktop.Database.getMuseumFontFamily(),

        // input options
        doq                 = options.doq,              // the artwork doq
        prevPage            = options.prevPage,         // the page we came from (string)
        prevScroll          = options.prevScroll || 0,  // scroll position where we came from
        prevCollection      = options.prevCollection,   // collection we came from, if any
        prevTag             = options.prevTag,          // sort tag of collection we came from, if any
        prevMult            = options.prevMult, 
        prevPreview         = options.prevPreview,      //previous artwork/media that was previewing (could be different than doq for assoc media view)     
        prevPreviewPos       = options.prevPreviewPos,
        previewing 	        = options.previewing, 	   // if we are previewing in authoring (for styling)
        assocMediaToShow    = options.assocMediaToShow,
        wasOnAssocMediaView = options.onAssocMediaView,

        // misc initialized vars  
        locHistoryActive = false,                   // whether location history is open
        locClosing       = false,                   // whether location history is closing
        locOpening       = false,                   // whether location history is opening
        drawers          = [],                      // the expandable sections for assoc media, tours, description, etc...
        mediaHolders     = [],                      // array of thumbnail buttons
        loadQueue        = TAG.Util.createQueue(),  // async queue for thumbnail button creation, etc
        screenWidth      = $('#tagRoot').width(),      // Width of entire tag screen (for split screen styling)
        

        // misc uninitialized vars
        locationList,                               // location history data
        customMapsLength,
        map,                                        // Bing Maps map for location history
        annotatedImage,                             // an AnnotatedImage object
        associatedMedia,                            // object of associated media objects generated by AnnotatedImage
        manipulate;                                 // Manipulation method
                               
    // get things rolling if doq is defined (it better be)
    doq && init();

    return {
        getRoot: getRoot,
    };
    root.attr('unselectable','on');
    root.css({'-moz-user-select':'-moz-none',
           '-o-user-select':'none',
           '-khtml-user-select':'none', 
           '-webkit-user-select':'none',
           '-ms-user-select':'none',
           'user-select':'none'
        });
    root.bind('selectstart', function(){ return false; });
    sideBar.disableSelection();
    sideBar.attr('unselectable','on');
    sideBar.css({'-moz-user-select':'-moz-none',
           '-o-user-select':'none',
           '-khtml-user-select':'none', 
           '-webkit-user-select':'none',
           '-ms-user-select':'none',
           'user-select':'none'
        });
    sideBar.bind('selectstart', function(){ return false; });
    /**
     * Initiate artmode with a root, artwork image and a sidebar on the left
     * @method init
     */
    function init() {
        var head,
            script,
            meta;

        if (!idleTimer && !previewing) {
            idleTimer = TAG.Util.IdleTimer.TwoStageTimer();
            idleTimer.start();
        }
        if (idleTimer && previewing) {
            idleTimer.kill();
        }
        if (locked === doq.Identifier) {
            idleTimer.kill();
        }

        var progressCircCSS = {
            'position': 'absolute',
            'z-index': '50',
            'height': 'auto',
            'width': '5%',
            'left': '47.5%',
            'top': '42.5%'
        };
        
        TAG.Util.showProgressCircle(loadingArea, progressCircCSS, '0px', '0px', false);
        var loadingLabel = $(document.createElement('label'));
        loadingLabel.css({
            'position': 'absolute',
            'left': '40%',
            'top': '55%',
            'font-size': '200%',
            'color': 'white',
            'opacity': '1'
        });
        loadingLabel.text('Loading Viewer');
        loadingArea.append(loadingLabel);

        // add script for displaying bing maps
        
        head = document.getElementsByTagName('head').item(0);
        script = document.createElement("script");
        script.charset = "UTF-8";
        script.type = "text/javascript";
        script.src = "http://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0";
        head.appendChild(script);
        meta = document.createElement('meta');
        meta.httpEquiv = "Content-Type";
        meta.content = "text/html; charset=utf-8";
        head.appendChild(meta);
        
        locationList = TAG.Util.UI.getLocationList(doq.Metadata);

        annotatedImage = TAG.AnnotatedImage({
            root: root,
            doq:  doq,
            callback: function () {
                associatedMedia = annotatedImage.getAssociatedMedia();
                associatedMedia.guids.sort(function (a, b) {
                    return associatedMedia[a].doq.Name.toLowerCase() < associatedMedia[b].doq.Name.toLowerCase() ? -1 : 1;
                });
                try { // TODO figure out why loadDoq sometimes causes a NetworkError (still happening?)
                    annotatedImage.openArtwork(doq);
                } catch(err) {
                    debugger;
                    console.log(err); // TODO if we hit a network error, show an error message
                }
                TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                initSplitscreen();
                createSeadragonControls();
                TAG.Worktop.Database.getMaps(doq.Identifier, function (mps) {
                    customMapsLength = mps.length;
                    makeSidebar();
                });
                    
                
                loadingArea.hide();
            },
            noMedia: false
        });
    }

    /**
     * Initializes splitscreen functionality
     * @method initSplitscreen
     */
    function initSplitscreen() {
        var splitscreenContainer = $(document.createElement('div')),
            splitscreenIcon = $(document.createElement('img'));

        splitscreenContainer.attr('id', 'splitscreenContainer');
        splitscreenContainer.css({
            'background-color': 'rgba(0,0,0,0.6)',
            'border-top-left-radius': '3.5px',
            'height': '10%',
            'position': 'absolute',
            'right': '0%',
            'text-align': 'center',
            'top': '90%',
            'vertical-align': 'center',
            'width': '10%',
            'z-index': '500'
        });

        splitscreenIcon.attr({
            id: 'splitscreen-icon',
            src: tagPath+'images/SplitWhite_dotted.svg'
        });
        splitscreenIcon.css({
            height: '50%',
            left: '2%',
            opacity: '0.6',
            //position: 'absolute',
            'margin-top': '8%',
            width: '75%'
        });

        splitscreenContainer.on('click', function () {
            var collectionsPage,
                collectionsPageRoot;
            if (!TAG.Util.Splitscreen.isOn()) {
                if (isOpen) {
                    locationPanelDiv.animate({ width: '0%' }, 350, function () {
                        locHistory.text("Maps");
                        locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
                        locHistoryContainer.css({ "background-color": "transparent" });
                        locationPanelDiv.hide();
                        locHistoryToggle.hide();
                        isOpen = false;
                        toggler.show();

                        collectionsPage = TAG.Layout.CollectionsPage();

                        collectionsPageRoot = collectionsPage.getRoot();
                        collectionsPageRoot.data('split', 'R');

                        splitscreenContainer.css('display', 'none');
                        TAG.Util.Splitscreen.init(root, collectionsPageRoot);
                        annotatedImage.viewer.scheduleUpdate();
                        //annotatedImage.viewer.viewport.applyConstraints();
                        TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                    });
                } else {
                    locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
                    collectionsPage = TAG.Layout.CollectionsPage();
                    collectionsPage.getRoot().find('#mainCollection').css('width', '60%');

                    collectionsPageRoot = collectionsPage.getRoot();
                    collectionsPageRoot.data('split', 'R');

                    splitscreenContainer.css('display', 'none');
                    TAG.Util.Splitscreen.init(root, collectionsPageRoot);
                    annotatedImage.viewer.scheduleUpdate();
                    //annotatedImage.viewer.viewport.applyConstraints();
                    TAG.Util.Splitscreen.setViewers(root, annotatedImage);
                }
                
            }
        });

        splitscreenContainer.append(splitscreenIcon);

        var splitScreenLabel = $(document.createElement('div')).css({'font-size':'40%', 'bottom':'0%', 'margin-top':'-2%'}).text('Splitscreen').appendTo(splitscreenContainer);

        root.append(splitscreenContainer);
        if (TAG.Util.Splitscreen.isOn()) {
            splitscreenContainer.css('display', 'none');
        }
    }

    /**
     * Add controls and key handlers for manual Seadragon manipulation
     * @method createSeadragonControls
     */
    function createSeadragonControls() {
        var container        = root.find('#seadragonManipContainer'),
            slideButton      = root.find('#seadragonManipSlideButton'),
            tagRoot          = $('#tagRoot'),
            top              = 0,
            count            = 0,
            panDelta         = 20,
            zoomScale        = 1.1,
            containerFocused = true,
            interval;

        // splitscreen
        if (root.data('split') === 'R' && TAG.Util.Splitscreen.isOn()) {
            container.css({
                'right': 'auto',
                'left': '0%'
            });
            slideButton.css({ //fix the rounded edge to be on the correct side
                'border-bottom-left-radius': '0px',
                'border-bottom-right-radius': '3.5px',
            });
        }

        //To-do figure out best max-width, min width
        if (previewing) {
            return;
        }
        container.css('width', Math.max(160,Math.min($('#tagRoot').width() * 0.19,400)));
        var containerHeight = container.width()*(111/163)
        container.css({
            'height': containerHeight + 'px',
            'top' : '-' + containerHeight + 'px',
            'min-width' : container.width()
        });
        slideButton.css({
            'padding-top': 0.05 * container.width() + 'px',
            'padding-bottom': 0.05 * container.width() + 'px'
        })


        slideButton.on('click', function () {
            count = 1 - count;
            container.animate({
                top: top
            });
            if (count === 0){
                top = '0px';
                slideButton.html("Show Controls");
            } else {
                top = '-' + containerHeight + 'px';
                slideButton.html('Hide Controls');
            }   
        });
        
        TAG.Telemetry.register(slideButton,'click','seadragon_button_panel_toggled',function(tobj){
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
            tobj.mode = 'Kiosk';
        });
        container.append(slideButton);
        var sdleftbtn = createButton('leftControl', tagPath + 'images/icons/zoom_left.svg'),
            sdrightbtn = createButton('rightControl', tagPath + 'images/icons/zoom_right.svg'),
            sdupbtn = createButton('upControl', tagPath + 'images/icons/zoom_up.svg'),
            sddownbtn = createButton('downControl', tagPath + 'images/icons/zoom_down.svg');
        container.append(sddownbtn);
        container.append(sdupbtn);

        if (sddownbtn.width()) {
            console.log("got valid height"+ sddownbtn.height());
            sdleftbtn.css('height', sddownbtn.width());
            sdrightbtn.css('height', sddownbtn.width());
        }
        container.append(sdleftbtn);
        container.append(sdrightbtn);

        var radius = (sdrightbtn.position().left - sdleftbtn.position().left + sdrightbtn.width()) / 2;
        var centery = sdleftbtn.position().top + sdleftbtn.height() / 2;
        //sdupbtn.css('top', centery - radius +5+ 'px');
        //sddownbtn.css('top', centery + radius -sdleftbtn.width() +15+ 'px');
        container.append(createButton('zinControl',   tagPath+'images/icons/zoom_plus.svg'));
        container.append(createButton('zoutControl',  tagPath+'images/icons/zoom_minus.svg'));

        var crossfadeSlider = $(document.createElement('input')).attr({
            'id': 'crossfadeSlider',
            'type': 'range',
            'value': 1,
            'min': 0,
            'max': 1,
            'step': 0.05
        });

        crossfadeSlider.on('change mousemove', function() {
            $('.mediaOuterContainer').css('opacity', crossfadeSlider.val());
        });
        crossfadeSlider.on('touchmove', function(e) {
            e.preventDefault();
            $('.mediaOuterContainer').css('opacity', crossfadeSlider.val());
        });


        /**
         * Create a seadragon control button
         * @method createButton
         * @param {String} id        the id for the new button
         * @param {String} imgPath   the path to the button's image
         * @param {Number} left      css left property for button
         * @param {Number} top       css top property for button
         * @return {jQuery obj}      the button
         */
        function createButton(id, imgPath, left, top) {
            var img = $(document.createElement('img'));

            img.attr({
                src: imgPath,
                id:  id
            });

            img.removeAttr('width');
            img.removeAttr('height');
            
            img.css({
                left: left + "px",
                top: top + "px"
            });

            if (id === 'leftControl' || id === 'rightControl'){
                img.addClass('seadragonManipButtonLR');
            } else if (id === 'upControl'|| id === 'downControl'){
                img.addClass('seadragonManipButtonUD');
            } else if (id === 'zinControl'|| id === 'zoutControl'){
                img.addClass('seadragonManipButtoninout');
            }

            return img;
        }
        
        TAG.Telemetry.register(root.find("#leftControl,#rightControl,#downControl,#upControl,#zoutControl,#zinControl"), 'click', 'seadragon_control_clicked', function (tobj) {
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);;
            tobj.mode = 'Kiosk';
        });
        
        /**
         * Keydown handler for artwork manipulation; wrapper around doManip that first
         * prevents default key behaviors
         * @method keyHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function keyHandler(evt, direction) {
            evt.preventDefault();
            clearInterval(interval);
            doManip(evt, direction);
        }

        /**
         * Click handler for button in given direction; a wrapper around doManip that also
         * executes doManip in an interval if the user is holding down a button
         * @method buttonHandler
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function buttonHandler(evt, direction) {
            doManip(evt, direction);
            clearInterval(interval);
            interval = setInterval(function() {
                doManip(evt, direction);
            }, 100);
        }

        /**
         * Do fixed manipulation in response to seadragon controls or key presses
         * @method doManip
         * @param {Object} evt         the event object
         * @param {String} direction   the direction in which to move the artwork
         */
        function doManip(evt, direction) {
            var pivot = annotatedImage.getMediaPivot();
            manipulate = annotatedImage.getToManip();

            if (direction === 'left') {
                manipulate({pivot: pivot, translation: {x: -panDelta, y: 0}, scale: 1}, null, true);
            } else if (direction === 'up') {
                manipulate({pivot: pivot, translation: {x: 0, y: -panDelta}, scale: 1}, null, true);
            } else if (direction === 'right') {
                manipulate({pivot: pivot, translation: {x: panDelta, y: 0}, scale: 1}, null,  true);
            } else if (direction === 'down') {
                manipulate({pivot: pivot, translation: {x: 0, y: panDelta}, scale: 1}, null, true);
            } else if (direction === 'in') {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: zoomScale});
            } else if (direction === 'out') {
                manipulate({pivot: pivot, translation: {x: 0, y: 0}, scale: 1/zoomScale});
            }   
        }


        // tabindex code is to allow key press controls (focus needs to be on the TAG container)
        $('#tagContainer').attr("tabindex", -1);
        $("[tabindex='-1']").focus();
        $("[tabindex='-1']").css('outline', 'none');
        $("[tabindex='-1']").on('click', function() {
            $("[tabindex='-1']").focus();
            containerFocused = true;
            annotatedImage.dzManipPreprocessing();     //Tell AnnotatedImage that the main artwork is active
        });
        $("[tabindex='-1']").focus(function() {
            containerFocused = true;
        });
        $("[tabindex='-1']").focusout(function() {
            containerFocused = false;
        });

        // TODO merge: need to fix the $(...) calls above for splitscreen

        

        $(document).on('keydown', function(evt) {
            if(containerFocused) {
                switch(evt.which) {
                    case 37:
                        keyHandler(evt, 'left');
                        break;
                    case 38:
                        keyHandler(evt, 'up');
                        break;
                    case 39:
                        keyHandler(evt, 'right');
                        break;
                    case 40:
                        keyHandler(evt, 'down');
                        break;
                    case 187:
                    case 61:
                        keyHandler(evt, 'in');
                        break;
                    case 189:
                    case 173:
                        keyHandler(evt, 'out');
                        break;
                }
            }
        });

        $(document).keyup(function(evt){
            clearInterval(interval);
        });

        root.find('#seadragonManipContainer').on('click', function(evt) {
            evt.stopPropagation(); //Prevent the click going through to the main container
            evt.preventDefault();
            TAG.Util.IdleTimer.restartTimer();
        });

        root.find('#leftControl').on('mousedown', function(evt) {
            buttonHandler(evt, 'left');
        });
        root.find('#upControl').on('mousedown', function(evt) {
            buttonHandler(evt, 'up');
        });
        root.find('#rightControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'right');
        });
        root.find('#downControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'down');
        });
        root.find('#zinControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'in');
        });
        root.find('#zoutControl').on('mousedown', function (evt) {
            buttonHandler(evt, 'out');
        });

        root.find('.seadragonManipButtonLR').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        root.find('.seadragonManipButtonUD').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        root.find('.seadragonManipButtoninout').on('mouseup mouseleave', function () {
            clearInterval(interval);
        });

        TAG.Telemetry.register($("[tabindex='-1']"),'keydown','seadragon_key_pressed',function(tobj){
            if (containerFocused===false){
                return true;
            }
            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
             tobj.mode = 'Kiosk';
        });
    }

    /**
     * Makes the artwork viewer sidebar
     * @method makeSidebar
     */
    function makeSidebar(mapslength) {
        var backBttnContainer = root.find("#backBttnContainer"),
            sideBarSections = root.find('#sideBarSections'),
            sideBarInfo = root.find('#sideBarInfo'),
            infoTitle = root.find('#infoTitle'),
            infoArtist = root.find('#infoArtist'),
            infoYear = root.find('#infoYear'),
            assetContainer = root.find('#assetContainer'),
            isBarOpen = true,
            currBottom = 0,
            item,
            fieldTitle,
            fieldValue,
            infoCustom,
            i,
            curr,
            button,
            descriptionDrawer,
            tourDrawer,
            locHistoryButton,
            mediaDrawer,
            xfadeDrawer,
            xfadeSlider,
            xfadeSliderPoint,
            isFading = false;

        sideBarInfo.css({
            'height' : sideBarSections.height()-25 + 'px'
        });
        if (locked !== doq.Identifier) {
            backButton.attr('src', tagPath + 'images/icons/Back.svg');
        } else {
            backButton.hide();
        }
        
        togglerImage.attr("src", tagPath + 'images/icons/Close.svg');
        infoTitle.text(doq.Name);
        infoArtist.text(doq.Metadata.Artist);
        infoYear.text(doq.Metadata.Year);
        infoTitle.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        infoArtist.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        infoYear.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });
        locHistory && locHistory.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });

        // splitscreen
        if (root.data('split') === 'R' && TAG.Util.Splitscreen.isOn()) {
            sideBar.css({
                'left': 'auto',
                'right': '0%'
            });
            toggler.css({
                left: '-12%',
                'border-top-left-radius': '3.5px',
                'border-top-right-radius': '0px',
                'border-bottom-right-radius': '0px',
                'border-bottom-left-radius': '3.5px'
            });
            togglerImage.attr('src', tagPath + 'images/icons/Open.svg')
                        .css('right','0%');
        } else {
            togglerImage.css('left', '0%');
        }
        if (!previewing){
        	sideBar.css('min-width', 0.22 * screenWidth);
        }

        // toggler to hide/show sidebar
        toggler.on('click', function () {
            var opts = {},
                isLeft = root.data('split') === 'L';

            if(isLeft) {
                opts.left = isBarOpen ? '-' + (0.22*screenWidth) + 'px' : '0%';
            } else {
                opts.right = isBarOpen ? '-' + (0.22 * screenWidth) + 'px' : '0%';
            }

            isBarOpen = !isBarOpen;

            sideBar.animate(opts, 1000, function () {
                togglerImage.attr('src', tagPath + 'images/icons/' + ((!!isBarOpen)^(!isLeft) ? 'Close.svg' : 'Open.svg'));
            });
        });

        TAG.Util.UI.setUpBackButton(backButton, goBack);
        TAG.Telemetry.register(backButton, 'click', 'artwork_to_collections', function(tobj) {

            tobj.custom_1 = CryptoJS.SHA1(doq.Name).toString(CryptoJS.enc.Base64);
            tobj.mode = 'Kiosk';
 
        });
        
        if(IS_WEBAPP) {
            linkButton.attr('src', tagPath+'images/link.svg');
            linkButton.on('click', function() {
                var linkOverlay = TAG.Util.UI.showPageLink(urlToParse, {
                    tagpagename: 'artwork',
                    tagguid: doq.Identifier,
                    prevpage: prevCollection.Identifier
                });

                root.append(linkOverlay);
                linkOverlay.fadeIn(500, function() {
                    linkOverlay.find('.linkDialogInput').select();
                });
            });
        } else {
            linkButtonContainer.remove();
        }

        function goBack() {
            var collectionsPage,
                collectionsPageRoot;
            backButton.off('click');

            //idleTimer && idleTimer.kill();
            //idleTimer = null;

            annotatedImage && annotatedImage.unload();
     
            collectionsPage = TAG.Layout.CollectionsPage({
                backScroll:     prevScroll,
                backPreviewPos: prevPreviewPos,
                backArtwork:    prevPreview,
                backCollection: prevCollection,
                backTag : prevTag,
                backMult : prevMult,
                wasOnAssocMediaView: wasOnAssocMediaView,
                splitscreen: root.data('split')
            });
            //if (root.data('split') === 'R') {

            //}
            collectionsPageRoot = collectionsPage.getRoot();
            collectionsPageRoot.data('split', root.data('split') === 'R' ? 'R' : 'L');

            TAG.Util.UI.slidePageRightSplit(root, collectionsPageRoot, function () {
                if (!IS_WINDOWS) {
                    if (collectionsPage.getState().exhibition === prevCollection) {
                        collectionsPage.showArtwork(prevPreview, prevMult && prevMult)();
                    }
                }
            });

            currentPage.name = TAG.Util.Constants.pages.COLLECTIONS_PAGE;
            currentPage.obj  = collectionsPage;
        }


        // add more information for the artwork if curator added in the authoring mode
        for (item in doq.Metadata.InfoFields) {
            if(doq.Metadata.InfoFields.hasOwnProperty(item)) {
                fieldTitle = item;
                fieldValue = doq.Metadata.InfoFields[item];
                infoCustom = $(document.createElement('div'));
                infoCustom.addClass('infoCustom');
                infoCustom.text(fieldTitle + ': ' + fieldValue);
                infoCustom.css({
                    'color': '#' + PRIMARY_FONT_COLOR,
                    //'font-family': FONT
                });
                infoCustom.appendTo(info);
            }
        }

        // make sure the info text fits in the div (TODO is this necessary?)
        TAG.Util.fitText(info, 1.1);

        // create drawers
        if (doq.Metadata.Description) {
            descriptionDrawer = createDrawer("Description");
            descriptionDrawer.contents.html(Autolinker.link(doq.Metadata.Description.replace(/\n/g, "<br />"), {email: false, twitter: false}));
            if (IS_WINDOWS) {
                var links = descriptionDrawer.find('a');
                links.each(function (index, element) {
                    $(element).replaceWith(function () {
                        return $.text([this]);
                    });
                });
            }
            assetContainer.append(descriptionDrawer);
            currBottom = descriptionDrawer.height();
        }
 
        if (customMapsLength>0 || locationList.length > 0) {
            locHistoryButton = initlocationHistory();
            assetContainer.append(locHistoryButton);
            currBottom += locHistoryButton.height();
        } else {
            root.find('#locationHistoryContainer').remove();
        }

        var drawerToggleFn = null;
        if (associatedMedia.guids.length > 0) {
            for (i = 0; i < associatedMedia.guids.length; i++) {
                curr = associatedMedia[associatedMedia.guids[i]];
                /*if (curr.linq.Metadata.Type === 'Layer') {
                    if (!xfadeDrawer) {
                        xfadeSlider = $(document.createElement('div'))
                            .attr('id', 'xfadeSlider');
                        xfadeSlider.css({
                            border: '2px solid rgba(255,255,255,0.8)',
                            height: '25px',
                            left: '10%',
                            margin: '5px 0px 5px 0px',
                            position: 'relative',
                            width: '80%'
                        });
                        xfadeSliderPoint = $(document.createElement('div'))
                            .attr('id', 'xfadeSliderPoint');
                        xfadeSliderPoint.css({
                            'background-color': 'rgba(255,255,255,0.8)',
                            height: '100%',
                            left: '0%',
                            position: 'absolute',
                            top: '0%',
                            width: '50%'
                        });
                        xfadeSlider.append(xfadeSliderPoint);

                        var updateOverlay = function(evt){
                            if (isFading){
                                var leftPercent =  (evt.clientX - xfadeSlider.offset().left)/ xfadeSlider.width();
                                xfadeSliderPoint.css('width', Math.min(leftPercent * 100, 100) + '%');
                                root.find('.xfadeImg').css('opacity', leftPercent);
                            }
                        }

                        xfadeSlider.on('mousedown', function(evt) {
                            isFading = true;
                            updateOverlay(evt)
                        });
                        xfadeSlider.on('mousemove', function (evt) {
                                updateOverlay(evt)
                        });

                        root.on('mouseup', function(evt){
                            isFading = false;
                        });
                        
                        xfadeDrawer = createDrawer('Layers', xfadeSlider);
                    }
                    loadQueue.add(createMediaButton(xfadeDrawer.contents, curr));
                } else { */

                if (!mediaDrawer) {
                    mediaDrawer = createDrawer('Associated Media', null, assocMediaToShow);
                    if (mediaDrawer.drawerToggle) {
                        drawerToggleFn = mediaDrawer.drawerToggle;
                    }
                }

                loadQueue.add(createMediaButton(mediaDrawer.contents, curr));
                //} //TODO ADD BACK LAYERS FUNCTIONALITY
            }
            if (mediaDrawer) {
                assetContainer.append(mediaDrawer);
                currBottom += mediaDrawer.height();
            }
            if (xfadeDrawer) {
                assetContainer.append(xfadeDrawer);
                currBottom += xfadeDrawer.height();
            }
            if (drawerToggleFn && (typeof drawerToggleFn === "function")) {
                loadQueue.add(drawerToggleFn);
            }
        }

        /**
         * Creates a tour thumbnail button
         * @method createTourButton
         * @param {jQuery obj} container     the element to which we'll append this button
         * @param {doq} tour                 the tour doq
         */
        function createTourButton(container, tour) {
            return function() {
                container.append(TAG.Util.Artwork.createThumbnailButton({
                    title: TAG.Util.htmlEntityDecode(tour.Name),
                    year: TAG.Util.htmlEntityDecode(tour.Year|| ""),
                    handler:     tourClicked(tour),
                    buttonClass: 'tourButton',
                    src:         (tour.Metadata.Thumbnail ? FIX_PATH(tour.Metadata.Thumbnail) : tagPath+'images/tour_icon.svg')
                }));
            }
        }

        /**
         * Creates a thumbnail button for an associated media
         * @method createMediaButton
         * @param {jQuery obj} container       the element to which we'll append the button
         * @param {Object} media               an associated media object (from AnnotatedImage)
         */
        function createMediaButton(container, media) {
            return function() {
                var src = '',
                    metadata = media.doq.Metadata,
                    thumb = metadata.Thumbnail;
                switch (metadata.ContentType) {
                    case 'Audio':
                        src = tagPath+'images/audio_icon.svg';
                        break;
                    case 'Video':
                        src = (thumb && !thumb.match(/.mp4/)) ? FIX_PATH(thumb) : tagPath + 'images/video_icon.svg';
                        break;
                    case 'Image':
                        src = thumb ? FIX_PATH(thumb) : FIX_PATH(metadata.Source);
                        break;
                    case 'iframe':
                        src = tagPath + 'images/video_icon.svg';
                        break;
                    default:
                        src = tagPath + 'images/text_icon.svg';
                        break;
                }
                var toAppend = TAG.Util.Artwork.createThumbnailButton({
                    title: TAG.Util.htmlEntityDecode(media.doq.Name),
                    year: TAG.Util.htmlEntityDecode(media.doq.Year || ""),
                    handler: mediaClicked(media),
                    buttonClass: 'mediaButton',
                    buttonID: 'thumbnailButton-' + media.doq.Identifier,
                    src: src
                });
                container.append(toAppend);
                if (toAppend.parents('#metascreen-R').length) {
                    toAppend.attr('id', toAppend.attr('id') + 'R');
                }
            }
        }

        /**
         * Generates a click handler for a specific associated media object
         * Also used when entering from collections page to open a specific associated media (hence the error check for evt)
         * @method mediaClicked
         * @param {Object} media       the associated media object (from AnnotatedImage)
         */
        function mediaClicked(media) {
            //var toggleFunction = toggleLocationPanel;
            return function (evt) {
                evt && evt.stopPropagation();
                locHistoryActive = true;
                media.create(); // returns if already created
                media.toggle();
                TAG.Util.IdleTimer.restartTimer();
                //(media.linq.Metadata.Type !== 'Layer') && media.mediaManipPreprocessing();   // Set the newly opened media as active for manipulation
                media.mediaManipPreprocessing(); //todo delete when layers functionality is added back in
                media.pauseReset();
                // toggleLocationPanel();
            };
        }

        // Load tours and filter for tours associated with this artwork
        TAG.Worktop.Database.getTours(function (tours) {
            var relatedTours,
                maxHeight;

            relatedTours = tours.filter(function (tour) {
                var relatedArtworks;
                if (!tour.Metadata || !tour.Metadata.RelatedArtworks || tour.Metadata.Private === "true") {
                    return false;
                }
                relatedArtworks = JSON.parse(tour.Metadata.RelatedArtworks);
                if(!relatedArtworks || !relatedArtworks.length) {
                    return false;
                }
                return relatedArtworks.indexOf(doq.Identifier) >= 0;
            });

            if (relatedTours.length > 0) {
                tourDrawer = createDrawer('Tours');
                assetContainer.append(tourDrawer);
                currBottom += tourDrawer.height();

                tourDrawer.contents.text('');
                for(i=0; i<relatedTours.length; i++) {
                    loadQueue.add(createTourButton(tourDrawer.contents, relatedTours[i]));
                }
            }

            // set max height of drawers to avoid expanding into minimap area

            maxHeight = Math.max(1, assetContainer.height() - currBottom ); //to account for the height of the drawerLabel of the current drawer.

            root.find(".drawerContents").css({
                "max-height": maxHeight*.8 + "px", //TODO this
                //'max-height':2*0.19 * $('#tagRoot').height() + 'px', //height of two thumbnails
            });
        });

        function tourClicked(tour) {
            return function () {
                var rinData,
                    parentid,
                    prevInfo,
                    rinPlayer,
                    confirmationBox;

                if (TAG.Util.Splitscreen.isOn()) {
                    confirmationBox = $(TAG.Util.UI.PopUpConfirmation(function () {
                            TAG.Util.Splitscreen.exit(root.data('split') || 'L');
                            tourClicked(tour)();
                            TAG.Util.multiLineEllipsis($($($(confirmationBox).children()[0]).children()[0]));
                        },
                        "By opening this tour, you will exit splitscreen mode. Would you like to continue?",
                        "Continue",
                        false,
                        function () {
                            confirmationBox.remove();
                        },
                        root
                    ));
                    confirmationBox.css({
                        'z-index': 10001,
                        'font-size': '60%'
                    });
                    root.append(confirmationBox);
                    confirmationBox.show();
                } else {
                    annotatedImage.unload();
                    prevInfo = { artworkPrev: "artmode", prevScroll: prevScroll, prevTag: prevTag };
                    rinData = JSON.parse(unescape(tour.Metadata.Content));
                    rinPlayer = new TAG.Layout.TourPlayer(rinData, prevCollection, prevInfo, options,tour);

                    TAG.Util.UI.slidePageLeftSplit(root, rinPlayer.getRoot(), rinPlayer.startPlayback);
                }
            };
        }

        /*************************************************************************
         * MINIMAP CODE. bleveque: didn't rewrite this; separate issue
         *                         if some variable names are off now, let me know
         */

        //Create minimapContainer...
        var minimapContainer = root.find('#minimapContainer');

        //if the #info div exceeds the half the length of the sidebar, the div's max-height is set to its default with an auto scroll property.
        info.css({
            'overflow-y' : 'auto',
            'max-height' : sideBar.height()*2/5- (info.offset().top - sideBar.offset().top)+ 'px',

        });

        var minimapDescription = $(document.createElement('div'))
            .addClass('minimapDescription')
            .css({
                'font-size': '80%',
                'margin-top': '-13%',
                'text-align':'center'
            })
            .text('Navigation');
        minimapContainer.append(minimapDescription);
       

    
    //when the #info div's size is not too large, the text inside metadata fields is made as much visible as possible
        assetContainer.css({
            'max-height': sideBarInfo.height()-info.height()+ (info.offset().top - sideBar.offset().top) + 'px',

        });

        

        sideBarSections.append(minimapContainer);

        //A white rectangle for minimap to show the current shown area for artwork
        var minimaprect = root.find('#minimaprect');

        //Load deepzoom thumbnail. 
        var img = new Image();
        var loaded = false;
        var AR = 1;//ratio between width and height.
        var minimapw = 1;//minimap width
        var minimaph = 1;//minimap height
        var minimap;

        /*
        **Load the image of artwork and initialize the minimap rectangle
        * @method minimapLoaded
        */
        function minimapLoaded() {
            if (loaded) return;
            loaded = true;
            //load the artwork image
            minimap = root.find('#minimap');
            minimap.attr('src', TAG.Worktop.Database.fixPath(doq.URL));

            //make the minimap not moveable. 
            minimap.mousedown(function () {
                return false;
            });

            //TAG.Util.disableDrag(minimapContainer);

            AR = img.naturalWidth / img.naturalHeight;
            var heightR = img.naturalHeight / $(minimapContainer).height();//the ratio between the height of image and the container.
            var widthR = img.naturalWidth / $(minimapContainer).width();//ratio between the width of image and the container.
            //make sure the whole image shown inside the container based on the longer one of height and width.
            if (heightR > widthR) {
                minimap.removeAttr("height");
                minimap.removeAttr("width");
                minimap.css({ "height": "100%" });
            }
            else {
                minimap.removeAttr("height");
                minimap.removeAttr("width");
                minimap.css({ "width": "100%" });
            }

            //make the image manipulatable. 
            if (IS_WINDOWS) {
                var gr = TAG.Util.makeManipulatableWin(minimap[0], {
                    onManipulate: onMinimapManipWin,
                    onScroll: onMinimapScrollWin,
                    onTapped: onMinimapTappedWin
                }, false);
            } else {
                var gr = TAG.Util.makeManipulatable(minimap[0], {
                    onManipulate: onMinimapManip,
                    onScroll: onMinimapScroll,
                    onTapped: onMinimapTapped
                }, true);
            }
            /**********************/
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);
            minimaprect.css({
                width: (minimapw - 1) + "px",
                height: (minimaph - 1) + "px",
                top: minimapt + "px",
                left: (minimapl - 1) + "px"
            });
            /*********************/
        }
        /*
        **Implement manipulation function from makeManipulatable.
        * @method onMinimapManip
        * @param {Object} evt        object containing hammer event info 
        */
        function onMinimapManip(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            //find pivot and translation of manipulation event
            var px = evt.pivot.x + (minimap.offset().left - minimapContainer.offset().left);
            var py = evt.pivot.y + (minimap.offset().top - minimapContainer.offset().top);
            var tx = evt.translation.x;
            var ty = evt.translation.y;

            var x = px + tx;
            var y = py + ty;
            x = (x - minimapl) / minimapw;
            y = (y - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1 + (1 - evt.scale);
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /*
        **Implement manipulation function from makeManipulatableWin in win8 app.
        * @method onMinimapManipWin
        * @param {Object} evt        object containing windows event info 
        */
        function onMinimapManipWin(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var px = evt.pivot.x;
            var py = evt.pivot.y;
            var tx = evt.translation.x;
            var ty = evt.translation.y;

            var x = px + tx;
            var y = py + ty;
            x = (x - minimapl) / minimapw;
            y = (y - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));

            var s = 1 + (1 - evt.scale);
            if (s) {
                annotatedImage.viewer.viewport.zoomBy(s, false);
            }
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /**Implement scroll function from makeManipulatable
         * @method onMinimapScroll
         * @param {Number} scale     scale factor
         * @param {Object} pivot     x and y location of event
         */
        function onMinimapScroll(scale, pivot) {
            //create hammer event and pass into onMinimapManip
            onMinimapManip({
                scale: scale,
                translation: {
                    x: 0,
                    y: 0
                },
                pivot: pivot
            });    
        }

        /**Implement scroll function in win8app from makeManipulatableWin
         * @method onMinimapScrollWin
         * @param {Number} delta     change
         * @param {Object} pivot     x and y location of event
         */
        function onMinimapScrollWin(delta, pivot) {
            annotatedImage.viewer.viewport.zoomBy(delta, annotatedImage.viewer.viewport.pointFromPixel(new Seadragon.Point(pivot.x, pivot.y)));
            annotatedImage.viewer.viewport.applyConstraints();
        }


        /**Implement tapped function from makeManipulatable
        * @method onMinimapTapped
        * @param {Object} evt        object containing hammer event info
        */
        function onMinimapTapped(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var xPos = evt.position.x; //+ minimap.offset().left;
            var yPos = evt.position.y; //+ minimap.offset().top;
            var x =(xPos-minimapl)/ minimapw;
            var y = (yPos-minimapt)/minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1;
            if (s) annotatedImage.viewer.viewport.zoomBy(s, false);
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        /**Implement tapped function in win8 from makeManipulatableWin
        * @method onMinimapTapped
        * @param {Object} evt        object containing windows event info
        */
        function onMinimapTappedWin(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();
            var minimapt = minimap.position().top;
            var minimapl = parseFloat(minimap.css('marginLeft'));

            var xPos = evt.position.x;
            var yPos = evt.position.y;
            var x = (xPos - minimapl) / minimapw;
            var y = (yPos - minimapt) / minimaph;
            y = y / AR;
            x = Math.max(0, Math.min(x, 1));
            y = Math.max(0, Math.min(y, 1 / AR));
            var s = 1;
            if (s) {
                annotatedImage.viewer.viewport.zoomBy(s, false);
            }
            annotatedImage.viewer.viewport.panTo(new Seadragon.Point(x, y), true);
            annotatedImage.viewer.viewport.applyConstraints();
        }

        img.onload = minimapLoaded;
        //should be complete image of artwork NOT thumbnail
        img.src = TAG.Worktop.Database.fixPath(doq.URL);
        if (img.complete) {
            minimapLoaded();
        }
        /*
        **Move the minimap rectangle based on the manipulation of the image
        * @method dzMoveHandler
        * @param {event} evt            manipulation event of the image
        */
        function dzMoveHandler(evt) {
            var minimaph = minimap.height();
            var minimapw = minimap.width();

            //centers rectangle
            var minimapt = (minimapContainer.height() / 2) - (minimap.height() / 2);
            var minimapl = (minimapContainer.width() / 2) - (minimap.width() / 2);

            var viewport = evt.viewport;
            var rect = viewport.getBounds(true);
            var tl = rect.getTopLeft();
            var br = rect.getBottomRight();
            var x = tl.x;
            var y = tl.y;
            var xp = br.x;
            var yp = br.y;
            if (x < 0) x = 0;
            if (y < 0) y = 0;
            if (xp > 1) xp = 1;
            if (yp > 1 / AR) yp = 1 / AR;
            y = y * AR;
            yp = yp * AR;
            yp = yp - y;
            xp = xp - x;
            x = minimapl + x * minimapw;
            y = minimapt + y * minimaph;
            xp = xp * minimapw;
            yp = yp * minimaph;
            minimaprect.css({
                width: (xp-1) + "px",
                height: (yp - 1) + "px",
                top: y + "px",
                left: (x-1) + "px"
            });
        }
        
        /*
         * END MINIMAP CODE
         ******************/

        annotatedImage.addAnimateHandler(dzMoveHandler);
        assocMediaToShow && loadQueue.add(mediaClicked(associatedMedia[assocMediaToShow.Identifier]));
        //PART OF CUSTOM BUILD FOR THE SAM
        /*for (i = 0; i < associatedMedia.guids.length; i++) {
            //console.log("THIS THIS: " + Object.keys(associatedMedia[associatedMedia.guids[i]]));
            if (associatedMedia[associatedMedia.guids[i]].linq.Metadata.Type && (associatedMedia[associatedMedia.guids[i]].linq.Metadata.Type === "Hotspot")) {
                loadQueue.add(associatedMedia[associatedMedia.guids[i]].showHotspot());
            }
        };*/
    }



    /**
     * Create a drawer with a disclosure button used to display
     * hotspots, assets, tours. The returned jQuery object has
     * a property called "contents" which should be used to add
     * buttons or messages to the contents of the drawer.
     *
     * @param title, the display title for the drawer
     * @author jastern
     */
    function initlocationHistory() {
        var RLH,  
            toggleContainer = $(document.createElement('div')).addClass('drawerToggleContainer'),
            toggle          = $(document.createElement('img')).addClass("drawerPlusToggle")
                .attr("src", tagPath+'images/icons/plus.svg');      
        isOpen = false;

        locHistoryContainer.on('click', function () { toggleLocationOpen(); });
        toggleContainer.append(toggle);
        locHistoryContainer.append(toggleContainer);

        //panel that slides out when location history is clicked
        RLH = TAG.Util.RLH({
            artwork: doq,
            root: root,
            authoring: false
        });
        locationPanelDiv = RLH.init();
        locationPanelDiv.css({"width":"0%"});
        locHistoryToggle = $(document.createElement('div'))
            .attr("id", "locHistoryToggle")
            .css({
                "left": '100%',
                'border-top-right-radius': '10px',
                'border-bottom-right-radius': '10px',
                "background-color":"rgba(0,0,0,0.7)",
                "top": "43%",
                "width": "4%",
                "height": "14%",
                "z-index": "100",
                "position": "relative"
            });
        var locHistoryToggleImage = $(document.createElement('img'))
            .attr('src', tagPath + 'images/icons/Close.svg')
            .attr("id", "locHistoryToggleImage")
            .css({
                'left': '0%',
                "position":"absolute",
	            "top": "30%",
	            "width":"72%",
	            "height":"42%"
	        });
        locationPanelDiv.append(locHistoryToggle);
        locHistoryToggle.append(locHistoryToggleImage);
        locHistoryToggle.on('click', function () { toggleLocationOpen(); });
        function toggleLocationOpen() {
            isOpen ? locationClose() : locationOpen();    
        }
        if (TAG.Util.Splitscreen.isOn()) {
            locHistory.css({ "color": TAG.Util.UI.dimColor(PRIMARY_FONT_COLOR, 1.7) });
        }
        function locationOpen() { 
            if (!isOpen) {
                if (!TAG.Util.Splitscreen.isOn()) {

                    //close other drawers if any are open
                    root.find(".drawerPlusToggle").attr({
                        src: tagPath+'images/icons/plus.svg',
                        expanded: false
                    });
                    root.find(".drawerContents").slideUp();

                    //and open RLH
                    locationPanelDiv.css({ display: 'inline' });
                    toggle.attr("src", tagPath+'images/icons/minus.svg');      
                    isOpen = true;
                    toggler.hide();
                    locationPanelDiv.show();
                    locationPanelDiv.animate({ width: '65%' }, 350, function () { locHistoryToggle.show(); });
                }
            }
        }

        function locationClose() {
            if (isOpen) {
                toggle.attr("src", tagPath+'images/icons/plus.svg');      
                locHistory.text("Maps");
                locHistoryContainer.css({ "background-color": "transparent" });
                isOpen = false;
                locationPanelDiv.animate({ width: '0%' }, 350, function () { locationPanelDiv.hide(); locHistoryToggle.hide(); toggler.show(); });
            }
        }

        that.locationClose = locationClose

        return locHistoryContainer;
    }

    /**
     * Create a drawer (e.g., for list of related tours or the artwork's description) 
     * @param {String} title            title of the drawer
     * @param {jQuery obj} topContents  an element to be included before the main contents of the drawer
     * @return {jQuery obj}             the drawer
     */
    function createDrawer(title, topContents, assocMediaToShow) {
        var drawer          = $(document.createElement('div')).addClass('drawer'),
            drawerHeader    = $(document.createElement('div')).addClass('drawerHeader'),
            label           = $(document.createElement('div')).addClass('drawerLabel'),
            toggleContainer = $(document.createElement('div')).addClass('drawerToggleContainer'),
            toggle          = $(document.createElement('img')).addClass("drawerPlusToggle"),
            drawerContents  = $(document.createElement('div')).addClass("drawerContents"),
            i;
       
        label.addClass('primaryFont');
        label.text(title);
        label.css({
            'color': '#' + PRIMARY_FONT_COLOR,
            //'font-family': FONT
        });
        toggle.attr({
            src: tagPath+'images/icons/plus.svg',
            expanded: false
        });

        drawer.append(drawerHeader);
        drawerHeader.append(label);
        drawerHeader.append(toggleContainer);
        toggleContainer.append(toggle);
   
        drawer.append(drawerContents);
        topContents && drawerContents.append(topContents);
        var drawerToggle = function (evt) {
            if (toggle.attr('expanded') !== 'true') {
                root.find(".drawerPlusToggle").attr({
                    src: tagPath + 'images/icons/plus.svg',
                    expanded: false
                });

                root.find(".drawerContents").slideUp();

                toggle.attr({
                    src: tagPath + 'images/icons/minus.svg',
                    expanded: true
                });
            } else {
                toggle.attr({
                    src: tagPath + 'images/icons/plus.svg',
                    expanded: false
                });

            }

            drawerContents.slideToggle();
            isOpen && that.locationClose()
        }

        //have the toggler icon minus when is is expanded, plus otherwise.
        drawerHeader.on('click', drawerToggle);

        drawer.contents = drawerContents;
        if (assocMediaToShow && title === 'Associated Media') {
            //drawerHeader.click();
            drawer.drawerToggle = drawerToggle;
        }
        return drawer;
    }

    /**
     * Return art viewer root element
     * @method
     * @return {jQuery obj}    root jquery object
     */
    function getRoot() {
        return root;
    }

    /**
     * Make the map for location History.
     * @method makeMap
     * @param {Function} callback     function to be called when map making is complete
    */
    function makeMap(callback) {
        var mapOptions,
            viewOptions;

        mapOptions = {
            credentials:         "AkNHkEEn3eGC3msbfyjikl4yNwuy5Qt9oHKEnqh4BSqo5zGiMGOURNJALWUfhbmj",
            mapTypeID:           Microsoft.Maps.MapTypeId.road,
            showScalebar:        true,
            enableClickableLogo: false,
            enableSearchLogo:    false,
            showDashboard:       true,
            showMapTypeSelector: false,
            zoom:                2,
            center:              new Microsoft.Maps.Location(20, 0)
        };
        
        viewOptions = {
            mapTypeId: Microsoft.Maps.MapTypeId.road,
        };
        
        map = new Microsoft.Maps.Map(document.getElementById('lpMapDiv'), mapOptions);
        map.setView(viewOptions);

        callback && callback();
    }

};

TAG.Layout.ArtworkViewer.default_options = {
    catalogState: {},
    doq: null,
    split: 'L',
};

